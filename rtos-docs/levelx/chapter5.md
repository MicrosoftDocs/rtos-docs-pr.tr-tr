---
title: Bölüm 5-Azure RTOS LevelX veya desteği
description: Flash belleği, genellikle 512 bayta eşit olarak bölünebilen bloklardan oluşur. Azure RTOS LevelX, her bir veya Flash bloğunu 512 baytlık mantıksal sektörlere böler.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 3a0c73c2b45c32bf3f1ef56de684fa83c334b59e
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/22/2021
ms.locfileid: "104826260"
---
# <a name="chapter-5---azure-rtos-levelx-nor-support"></a><span data-ttu-id="fae3c-104">Bölüm 5-Azure RTOS LevelX veya desteği</span><span class="sxs-lookup"><span data-stu-id="fae3c-104">Chapter 5 - Azure RTOS LevelX NOR support</span></span>

<span data-ttu-id="fae3c-105">Flash belleği, genellikle 512 bayta eşit olarak bölünebilen *bloklardan* oluşur.</span><span class="sxs-lookup"><span data-stu-id="fae3c-105">NOR flash memory is composed of *blocks* that are typically evenly divisible by 512 bytes.</span></span> <span data-ttu-id="fae3c-106">Flash *Page* 'de veya Flash bellekte bir kavram yoktur.</span><span class="sxs-lookup"><span data-stu-id="fae3c-106">There are no concept of a flash *page* in NOR flash memory.</span></span> <span data-ttu-id="fae3c-107">Ayrıca, veya Flash bellekte *yedek* bayt yoktur, bu nedenle Azure RTOS levelx 'in tüm yönetim BILGILERI için veya flash belleğini kullanması gerekir.</span><span class="sxs-lookup"><span data-stu-id="fae3c-107">Also, there are no *spare* bytes in NOR flash memory, hence Azure RTOS LevelX must use the NOR flash memory itself for all management information.</span></span> <span data-ttu-id="fae3c-108">Doğrudan okuma erişimi, veya Flash bellekte mümkündür.</span><span class="sxs-lookup"><span data-stu-id="fae3c-108">Direct read access is possible in NOR flash memory.</span></span> <span data-ttu-id="fae3c-109">Yazma erişimi genellikle özel bir işlem dizisi gerektirir.</span><span class="sxs-lookup"><span data-stu-id="fae3c-109">Write access typically requires a special sequence of operations.</span></span> <span data-ttu-id="fae3c-110">VEYA Flash belleği birden çok kez yazılabilir, bu da bitleri temizlenemekte olabilir.</span><span class="sxs-lookup"><span data-stu-id="fae3c-110">NOR flash memory may be written to multiple times, providing that bits are being cleared.</span></span> <span data-ttu-id="fae3c-111">VEYA Flash belleğindeki bitler, silme bloğu işlemi aracılığıyla yalnızca bir kez ayarlanabilir.</span><span class="sxs-lookup"><span data-stu-id="fae3c-111">Bits in NOR flash memory can only be set once, via the erase block operation.</span></span>

<span data-ttu-id="fae3c-112">LevelX her bir veya Flash bloğunu 512 baytlık mantıksal *kesimlere* böler.</span><span class="sxs-lookup"><span data-stu-id="fae3c-112">LevelX divides each NOR flash block into 512-byte logical *sectors*.</span></span> <span data-ttu-id="fae3c-113">Ayrıca, LevelX, yönetim bilgilerini depolamak için her bir veya Flash bloğunun ilk "n" sektörlerini kullanır.</span><span class="sxs-lookup"><span data-stu-id="fae3c-113">Furthermore, LevelX uses the first "n" sectors of each NOR flash block to store management information.</span></span> <span data-ttu-id="fae3c-114">LevelX veya Flash bellek yönetimi bilgilerinin biçimi:</span><span class="sxs-lookup"><span data-stu-id="fae3c-114">The format of the LevelX NOR flash memory management information is:</span></span>

<span data-ttu-id="fae3c-115">**LevelX veya Block biçimi**</span><span class="sxs-lookup"><span data-stu-id="fae3c-115">**LevelX NOR Block Format**</span></span>

| <span data-ttu-id="fae3c-116">Bayt kayması</span><span class="sxs-lookup"><span data-stu-id="fae3c-116">Byte Offset</span></span>  | <span data-ttu-id="fae3c-117">İçindekiler</span><span class="sxs-lookup"><span data-stu-id="fae3c-117">Contents</span></span>                     |
| ------------ | ---------------------------- |
| <span data-ttu-id="fae3c-118">0</span><span class="sxs-lookup"><span data-stu-id="fae3c-118">0</span></span>            | <span data-ttu-id="fae3c-119">[Blok silme sayısı]</span><span class="sxs-lookup"><span data-stu-id="fae3c-119">[Block Erase Count]</span></span>          |
| <span data-ttu-id="fae3c-120">4</span><span class="sxs-lookup"><span data-stu-id="fae3c-120">4</span></span>            | <span data-ttu-id="fae3c-121">[En az eşlenmiş kesim]</span><span class="sxs-lookup"><span data-stu-id="fae3c-121">[Minimum Mapped Sector]</span></span>      |
| <span data-ttu-id="fae3c-122">8</span><span class="sxs-lookup"><span data-stu-id="fae3c-122">8</span></span>            | <span data-ttu-id="fae3c-123">[Eşlenen en fazla kesim]</span><span class="sxs-lookup"><span data-stu-id="fae3c-123">[Maximum Mapped Sector]</span></span>      |
| <span data-ttu-id="fae3c-124">12</span><span class="sxs-lookup"><span data-stu-id="fae3c-124">12</span></span>           | <span data-ttu-id="fae3c-125">[Serbest sektör bit eşlemesi]</span><span class="sxs-lookup"><span data-stu-id="fae3c-125">[Free Sector Bit Map]</span></span>        |
| <span data-ttu-id="fae3c-126">m</span><span class="sxs-lookup"><span data-stu-id="fae3c-126">m</span></span>            | <span data-ttu-id="fae3c-127">[Sektör 0 eşleme girişi]</span><span class="sxs-lookup"><span data-stu-id="fae3c-127">[Sector 0 Mapping Entry]</span></span>     |
|              | <span data-ttu-id="fae3c-128">…</span><span class="sxs-lookup"><span data-stu-id="fae3c-128">…</span></span>                            |
| <span data-ttu-id="fae3c-129">a + 4 \* (n-1)</span><span class="sxs-lookup"><span data-stu-id="fae3c-129">m+4\*(n-1)</span></span>    | <span data-ttu-id="fae3c-130">[Kesim "n" eşleme girişi]</span><span class="sxs-lookup"><span data-stu-id="fae3c-130">[Sector "n" Mapping Entry]</span></span>   |
|              | <span data-ttu-id="fae3c-131">…</span><span class="sxs-lookup"><span data-stu-id="fae3c-131">…</span></span>                            |
| <span data-ttu-id="fae3c-132">s</span><span class="sxs-lookup"><span data-stu-id="fae3c-132">s</span></span>            | <span data-ttu-id="fae3c-133">[Kesim 0 Içeriği]</span><span class="sxs-lookup"><span data-stu-id="fae3c-133">[Sector 0 Contents]</span></span>          |
|              | <span data-ttu-id="fae3c-134">…</span><span class="sxs-lookup"><span data-stu-id="fae3c-134">…</span></span>                            |
| <span data-ttu-id="fae3c-135">s + 512 \* (n-1)</span><span class="sxs-lookup"><span data-stu-id="fae3c-135">s+512\*(n-1)</span></span> | <span data-ttu-id="fae3c-136">[Kesim "n" Içerik]</span><span class="sxs-lookup"><span data-stu-id="fae3c-136">[Sector "n" Contents]</span></span>         |

<span data-ttu-id="fae3c-137">32 bitlik *blok silme sayısı* , bloğun kaç kez silinme sayısını içerir.</span><span class="sxs-lookup"><span data-stu-id="fae3c-137">The 32-bit *Block Erase Count* contains the number of times the block has been erased.</span></span> <span data-ttu-id="fae3c-138">LevelX 'in ana amacı, herhangi bir bloğun erken bir şekilde erişmesini önlemeye yardımcı olmak için tüm blokların silme sayısını görece şekilde kapatmaktır.</span><span class="sxs-lookup"><span data-stu-id="fae3c-138">The main goal of LevelX is to keep the erase count of all blocks relatively close to help prevent any one block from wearing out prematurely.</span></span> <span data-ttu-id="fae3c-139">32 bitlik *en az eşlenmiş kesim* ve *en fazla eşlenen sektör* alanları yalnızca bloktaki tüm mantıksal kesimlerin eşlendiği ve üzerine yazıldığı durumlarda yazılır.</span><span class="sxs-lookup"><span data-stu-id="fae3c-139">The 32-bit *Minimum Mapped Sector* and *Maximum Mapped Sector* fields are written only when all the logical sectors in the block have been mapped and written to.</span></span> <span data-ttu-id="fae3c-140">Bu alanlar, kesim okuma işleminin iyileştirilmesi için faydalıdır.</span><span class="sxs-lookup"><span data-stu-id="fae3c-140">These fields are useful for optimization of the sector read operation.</span></span> <span data-ttu-id="fae3c-141">*Serbest sektör bit eşleme* girişi, her küme bitinin bloktaki eşlenmemiş kesime karşılık geldiği bir bit haritadır.</span><span class="sxs-lookup"><span data-stu-id="fae3c-141">The *Free Sector Bit Map* entry is a bit map where each set bit corresponds to an unmapped sector in the block.</span></span> <span data-ttu-id="fae3c-142">Bu alan, serbest sektör aramasını daha verimli hale getirmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="fae3c-142">This field is used to make the free sector search more efficient.</span></span> <span data-ttu-id="fae3c-143">Bu, bloktaki her 32 kesim için bir sözcük gerektiren değişken uzunluklu bir alandır.</span><span class="sxs-lookup"><span data-stu-id="fae3c-143">This is a variable length field that requires one word for every 32 sectors in the block.</span></span> <span data-ttu-id="fae3c-144">*Kesim eşleme giriş* dizisi, bloktaki her bir kesime ait eşleme bilgilerini içerir.</span><span class="sxs-lookup"><span data-stu-id="fae3c-144">The *Sector Mapping Entry* array contains mapping information for each sector in the block.</span></span> <span data-ttu-id="fae3c-145">Her giriş aşağıdaki biçimdedir:</span><span class="sxs-lookup"><span data-stu-id="fae3c-145">Each entry has the following format:</span></span>

<span data-ttu-id="fae3c-146">**Kesim eşleme girişi**</span><span class="sxs-lookup"><span data-stu-id="fae3c-146">**Sector Mapping Entry**</span></span>

| <span data-ttu-id="fae3c-147">Bit (lar)</span><span class="sxs-lookup"><span data-stu-id="fae3c-147">Bit(s)</span></span> | <span data-ttu-id="fae3c-148">Anlamı</span><span class="sxs-lookup"><span data-stu-id="fae3c-148">Meaning</span></span>  |
| ------ | -------- |
| <span data-ttu-id="fae3c-149">31</span><span class="sxs-lookup"><span data-stu-id="fae3c-149">31</span></span>     | <span data-ttu-id="fae3c-150">Geçerli bayrak.</span><span class="sxs-lookup"><span data-stu-id="fae3c-150">Valid flag.</span></span> <span data-ttu-id="fae3c-151">Küme ve mantıksal kesim hiçbir zaman eşleme, eşlemenin geçerli olduğunu belirtir</span><span class="sxs-lookup"><span data-stu-id="fae3c-151">When set and logical sector not all ones indicates mapping is valid</span></span> |
| <span data-ttu-id="fae3c-152">30</span><span class="sxs-lookup"><span data-stu-id="fae3c-152">30</span></span>     | <span data-ttu-id="fae3c-153">Kullanım dışı bayrağı.</span><span class="sxs-lookup"><span data-stu-id="fae3c-153">Obsolete flag.</span></span> <span data-ttu-id="fae3c-154">Bu eşleme açık olmadığında veya artık kullanılmıyor olma sürecinde.</span><span class="sxs-lookup"><span data-stu-id="fae3c-154">When clear, this mapping is either obsolete or is in the process of becoming obsolete.</span></span> |
| <span data-ttu-id="fae3c-155">29</span><span class="sxs-lookup"><span data-stu-id="fae3c-155">29</span></span>     | <span data-ttu-id="fae3c-156">Bu bit 0 olduğunda eşleme girişi yazma işlemi tamamlanır</span><span class="sxs-lookup"><span data-stu-id="fae3c-156">Mapping entry write is complete when this bit is 0</span></span> |
| <span data-ttu-id="fae3c-157">0-28</span><span class="sxs-lookup"><span data-stu-id="fae3c-157">0-28</span></span>   | <span data-ttu-id="fae3c-158">Bu fiziksel kesime eşlenmiş mantıksal kesim (hepsi değil).</span><span class="sxs-lookup"><span data-stu-id="fae3c-158">Logical sector mapped to this physical sector—when not all ones.</span></span> |

<span data-ttu-id="fae3c-159">32 bitlik alanın (bit 31) üst biti, mantıksal kesim eşlemesinin geçerli olduğunu göstermek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="fae3c-159">The upper bit of the 32-bit field (bit 31) is used to indicate the logical sector mapping is valid.</span></span> <span data-ttu-id="fae3c-160">Bu bit 0 ise, bu girişteki bilgiler (ve buna karşılık gelen sektör içeriği) artık geçerli değildir.</span><span class="sxs-lookup"><span data-stu-id="fae3c-160">If this bit is 0, the information in this entry (and corresponding sector contents) is no longer valid.</span></span> <span data-ttu-id="fae3c-161">Sonraki bit bit 30-bu sektörün kullanılmıyor olma sürecinde olduğunu ve yeni bir kesimin yazılmakta olduğunu göstermek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="fae3c-161">The next bit - bit 30 - is used to indicate this sector is in the process of becoming obsolete and a new sector is being written.</span></span> <span data-ttu-id="fae3c-162">Eşleme girişi yazma işleminin tamamlandığını göstermek için bit 29 kullanılır.</span><span class="sxs-lookup"><span data-stu-id="fae3c-162">Bit 29 is used to indicate when the mapping entry write is complete.</span></span> <span data-ttu-id="fae3c-163">Bit 29 0 ise, eşleme girişi yazma tamamlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="fae3c-163">If bit 29 is 0, the mapping entry write is complete.</span></span> <span data-ttu-id="fae3c-164">Bit 29 ayarlanmışsa, eşleme girişi yazma süreciydi.</span><span class="sxs-lookup"><span data-stu-id="fae3c-164">If bit 29 is set, the mapping entry was in the process of being written.</span></span> <span data-ttu-id="fae3c-165">BITS 30 ve 29, yeni bir sektör eşlemesini güncelleştirirken olası bir güç kaybından kurtarmak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="fae3c-165">Bits 30 and 29 are used in recovering from a potential power loss while updating a new sector mapping.</span></span> <span data-ttu-id="fae3c-166">Son olarak, alt 29-bit (28-0), sektör için mantıksal kesim numarasını içerir.</span><span class="sxs-lookup"><span data-stu-id="fae3c-166">Finally, the lower 29-bits (28-0) contain the logical sector number for the sector.</span></span> <span data-ttu-id="fae3c-167">Bir sektör eşlenmişse, tüm bitler ayarlanır, yani, 0xFFFFFFFF değerine sahip olur.</span><span class="sxs-lookup"><span data-stu-id="fae3c-167">If a sector has not been mapped, all bits will be set, i.e., it will have a value of 0xFFFFFFFF.</span></span>

## <a name="nor-driver-requirements"></a><span data-ttu-id="fae3c-168">VEYA sürücü gereksinimleri</span><span class="sxs-lookup"><span data-stu-id="fae3c-168">NOR Driver Requirements</span></span>

<span data-ttu-id="fae3c-169">LevelX, temel Flash bölümü ve donanım uygulamasına özel bir temel veya Flash sürücü gerektirir.</span><span class="sxs-lookup"><span data-stu-id="fae3c-169">LevelX requires an underlying NOR flash driver that is specific to the underlying flash part and hardware implementation.</span></span> <span data-ttu-id="fae3c-170">Sürücü, API ***lx_nor_flash_open*** aracılığıyla başlatma sırasında levelx olarak belirtilir.</span><span class="sxs-lookup"><span data-stu-id="fae3c-170">The driver is specified to LevelX during initialization via the API ***lx_nor_flash_open***.</span></span> <span data-ttu-id="fae3c-171">LevelX sürücüsünün prototipi:</span><span class="sxs-lookup"><span data-stu-id="fae3c-171">The prototype of the LevelX driver is:</span></span>

```c
INT nor_driver_initialize(LX_NOR_FLASH *instance);
```

<span data-ttu-id="fae3c-172">"*Örnek*" parametresi, levelx veya denetim bloğunu belirtir.</span><span class="sxs-lookup"><span data-stu-id="fae3c-172">The "*instance*" parameter specifies the LevelX NOR control block.</span></span> <span data-ttu-id="fae3c-173">Sürücü başlatma işlevi, ilişkili LevelX örneği için diğer tüm sürücü düzeyi Hizmetleri ayarlamaktan sorumludur.</span><span class="sxs-lookup"><span data-stu-id="fae3c-173">The driver initialization function is responsible for setting up all the other driver-level services for the associated LevelX instance.</span></span> <span data-ttu-id="fae3c-174">Her bir LevelX veya örnek için gereken hizmetler şunlardır:</span><span class="sxs-lookup"><span data-stu-id="fae3c-174">The services required for each LevelX NOR instance are:</span></span>

- <span data-ttu-id="fae3c-175">Kesimi oku</span><span class="sxs-lookup"><span data-stu-id="fae3c-175">Read Sector</span></span>
- <span data-ttu-id="fae3c-176">Yazma kesimi</span><span class="sxs-lookup"><span data-stu-id="fae3c-176">Write Sector</span></span>
- <span data-ttu-id="fae3c-177">Blok silme</span><span class="sxs-lookup"><span data-stu-id="fae3c-177">Block Erase</span></span>
- <span data-ttu-id="fae3c-178">Blok silinme doğrulaması</span><span class="sxs-lookup"><span data-stu-id="fae3c-178">Block Erased Verify</span></span>
- <span data-ttu-id="fae3c-179">Sistem hata Işleyicisi</span><span class="sxs-lookup"><span data-stu-id="fae3c-179">System Error Handler</span></span>

## <a name="driver-initialization"></a><span data-ttu-id="fae3c-180">Sürücü başlatma</span><span class="sxs-lookup"><span data-stu-id="fae3c-180">Driver Initialization</span></span>

<span data-ttu-id="fae3c-181">Bu hizmetler, sürücünün başlatma işlevindeki **LX_NOR_FLASH** örneğindeki işlev işaretçileri ayarlanarak kurulumlardır.</span><span class="sxs-lookup"><span data-stu-id="fae3c-181">These services are setup via setting function pointers in the **LX_NOR_FLASH** instance within the driver's initialization function.</span></span> <span data-ttu-id="fae3c-182">Sürücü başlatma işlevi de şu şekilde sorumludur:</span><span class="sxs-lookup"><span data-stu-id="fae3c-182">The driver initialization function also is responsible for:</span></span>

1. <span data-ttu-id="fae3c-183">Flaşın temel adresini belirtme.</span><span class="sxs-lookup"><span data-stu-id="fae3c-183">Specifying the base address of the flash.</span></span>
1. <span data-ttu-id="fae3c-184">Toplam blok sayısını ve blok başına sözcük sayısını belirtme.</span><span class="sxs-lookup"><span data-stu-id="fae3c-184">Specifying the total number of blocks and the number of words per block.</span></span>
1. <span data-ttu-id="fae3c-185">Bir Flash kesimini okumak için bir RAM arabelleği (512 bayt) ve ULONG erişimi için hizalanır.</span><span class="sxs-lookup"><span data-stu-id="fae3c-185">A RAM buffer for reading one sector of flash (512 bytes) and aligned for ULONG access.</span></span>

<span data-ttu-id="fae3c-186">Sürücü başlatma işlevi büyük olasılıkla **LX_SUCCESS** döndürmeden önce ek cihaz ve/veya uygulamaya özgü başlatma görevlerini de gerçekleştiriyor.</span><span class="sxs-lookup"><span data-stu-id="fae3c-186">The driver initialization function likely also performs additional device and/or implementation-specific initialization duties before returning **LX_SUCCESS**.</span></span>

## <a name="driver-read-sector"></a><span data-ttu-id="fae3c-187">Sürücü okuma kesimi</span><span class="sxs-lookup"><span data-stu-id="fae3c-187">Driver Read Sector</span></span>

<span data-ttu-id="fae3c-188">LevelX ve sürücü "Read sektör" hizmeti, veya Flash 'un belirli bir bloğundaki belirli bir kesimi okumaktan sorumludur.</span><span class="sxs-lookup"><span data-stu-id="fae3c-188">The LevelX NOR driver "read sector" service is responsible for reading a specific sector in a specific block of the NOR flash.</span></span> <span data-ttu-id="fae3c-189">Mantığın tüm hata denetlemesi ve düzeltilmesi, sürücü hizmetinin sorumluluğundadır.</span><span class="sxs-lookup"><span data-stu-id="fae3c-189">All error checking and correcting logic is the responsibility of the driver service.</span></span> <span data-ttu-id="fae3c-190">Başarılı olursa, LevelX ve sürücü **LX_SUCCESS** döndürür.</span><span class="sxs-lookup"><span data-stu-id="fae3c-190">If successful, the LevelX NOR driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="fae3c-191">Başarılı olmazsa, LevelX ve sürücü *LX_ERROR* döndürür.</span><span class="sxs-lookup"><span data-stu-id="fae3c-191">If not successful, the LevelX NOR driver returns *LX_ERROR*.</span></span> <span data-ttu-id="fae3c-192">LevelX ve sürücü "Read sektör" hizmetinin prototipi şunlardır:</span><span class="sxs-lookup"><span data-stu-id="fae3c-192">The prototype of the LevelX NOR driver "read sector" service is:</span></span>

```c
INT nor_driver_read_sector(
    ULONG *flash_address,
    ULONG *destination, 
    ULONG words);
```

<span data-ttu-id="fae3c-193">Burada "*flash_address*", bir veya Flash bellek bloğu ve "*hedef*" ve "*sözcük*" içindeki mantıksal bir kesimin adresini belirtir, kesim içeriğinin nereye yerleştirileceğini ve kaç 32 bit kelime okuyabileceğiniz belirtilir.</span><span class="sxs-lookup"><span data-stu-id="fae3c-193">Where "*flash_address*" specifies the address of a logical sector within a NOR flash block of memory and "*destination*" and "*words*" specify where to place the sector contents and how many 32-bit words to read.</span></span>

## <a name="driver-write-sector"></a><span data-ttu-id="fae3c-194">Sürücü yazma kesimi</span><span class="sxs-lookup"><span data-stu-id="fae3c-194">Driver Write Sector</span></span>

<span data-ttu-id="fae3c-195">LevelX ve sürücü "yazma kesimi" hizmeti, belirli bir sektörün bir veya Flash bloğuna yazılmasından sorumludur.</span><span class="sxs-lookup"><span data-stu-id="fae3c-195">The LevelX NOR driver "write sector" service is responsible for writing a specific sector into a block of the NOR flash.</span></span> <span data-ttu-id="fae3c-196">Tüm hata denetimi, sürücü hizmetinin sorumluluğundadır.</span><span class="sxs-lookup"><span data-stu-id="fae3c-196">All error checking is the responsibility of the driver service.</span></span> <span data-ttu-id="fae3c-197">Başarılı olursa, LevelX ve sürücü **LX_SUCCESS** döndürür.</span><span class="sxs-lookup"><span data-stu-id="fae3c-197">If successful, the LevelX NOR driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="fae3c-198">Başarılı olmazsa, LevelX ve sürücü **LX_ERROR** döndürür.</span><span class="sxs-lookup"><span data-stu-id="fae3c-198">If not successful, the LevelX NOR driver returns **LX_ERROR**.</span></span> <span data-ttu-id="fae3c-199">LevelX ve sürücü "yazma kesimi" hizmeti prototipi şunlardır:</span><span class="sxs-lookup"><span data-stu-id="fae3c-199">The prototype of the LevelX NOR driver "write sector" service is:</span></span>

```c
INT nor_driver_write_sector(
    ULONG *flash_address,
    ULONG *source, 
    ULONG words);
```

<span data-ttu-id="fae3c-200">Burada "*flash_address*", bir veya Flash bellek bloğunda ve "*kaynak*" ve "*kelimeler*", yazma kaynağını ve kaç 32 bitlik sözcüğün yazılacağını belirten bir mantıksal kesim adresini belirtir.</span><span class="sxs-lookup"><span data-stu-id="fae3c-200">Where "*flash_address*" specifies the address of a logical sector within a NOR flash block of memory and "*source*" and "*words*" specify the source of the write and how many 32-bit words to write.</span></span>

> [!NOTE]
> <span data-ttu-id="fae3c-201">LevelX, yazma kesiminin başarılı olduğunu doğrulamak için sürücüyü kullanır.</span><span class="sxs-lookup"><span data-stu-id="fae3c-201">LevelX relies on the driver to verify that the write sector was successful.</span></span> <span data-ttu-id="fae3c-202">Bu, genellikle programlanmış değeri okunarak, istenen değerin yazılmasına izin verildiğinden yapılır.</span><span class="sxs-lookup"><span data-stu-id="fae3c-202">This is typically done by reading back the programmed value to ensure it matches the requested value to be written.</span></span>

## <a name="driver-block-erase"></a><span data-ttu-id="fae3c-203">Sürücü bloğunu silme</span><span class="sxs-lookup"><span data-stu-id="fae3c-203">Driver Block Erase</span></span>

<span data-ttu-id="fae3c-204">LevelX ve sürücü "blok silme" hizmeti, belirtilen veya Flash bloğunu silmekten sorumludur.</span><span class="sxs-lookup"><span data-stu-id="fae3c-204">The LevelX NOR driver "block erase" service is responsible for erasing the specified block of the NOR flash.</span></span> <span data-ttu-id="fae3c-205">Başarılı olursa, LevelX ve sürücü **LX_SUCCESS** döndürür.</span><span class="sxs-lookup"><span data-stu-id="fae3c-205">If successful, the LevelX NOR driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="fae3c-206">Başarılı olmazsa, LevelX ve sürücü **LX_ERROR** döndürür.</span><span class="sxs-lookup"><span data-stu-id="fae3c-206">If not successful, the LevelX NOR driver returns **LX_ERROR**.</span></span> <span data-ttu-id="fae3c-207">LevelX ve sürücü "blok silme" hizmetinin prototipi:</span><span class="sxs-lookup"><span data-stu-id="fae3c-207">The prototype of the LevelX NOR driver "block erase" service is:</span></span>

```c
INT nor_driver_block_erase(ULONG block,  
    ULONG erase_count);
```

<span data-ttu-id="fae3c-208">Burada "*Block*" ne olduğunu veya silmeyi engellemeyi belirler.</span><span class="sxs-lookup"><span data-stu-id="fae3c-208">Where "*block*" identifies which NOR block to erase.</span></span> <span data-ttu-id="fae3c-209">"*Erase_count*" parametresi, tanılama amacıyla sağlanır.</span><span class="sxs-lookup"><span data-stu-id="fae3c-209">The parameter "*erase_count*" is provided for diagnostic purposes.</span></span> <span data-ttu-id="fae3c-210">Örneğin, sürücü, silme sayısı belirli bir eşiği aştığında, uygulama yazılımının başka bir bölümüne uyarı vermek isteyebilir.</span><span class="sxs-lookup"><span data-stu-id="fae3c-210">For example, the driver may want to alert another portion of the application software when the erase count exceeds a specific threshold.</span></span>

> [!NOTE]
> <span data-ttu-id="fae3c-211">LevelX, silindiklerinden emin olmak için bloğun tüm baytlarını incelemek üzere sürücüyü kullanır (tümünü içerir).</span><span class="sxs-lookup"><span data-stu-id="fae3c-211">LevelX relies on the driver to examine all bytes of the block to ensure they are erased (contain all ones).</span></span>

## <a name="driver-block-erased-verify"></a><span data-ttu-id="fae3c-212">Sürücü bloğunu silinen doğrulama</span><span class="sxs-lookup"><span data-stu-id="fae3c-212">Driver Block Erased Verify</span></span>

<span data-ttu-id="fae3c-213">LevelX veya sürücünün "blok silinmi Verify" hizmeti, belirtilen veya Flash bloğunun silineceğini doğrulamadan sorumludur.</span><span class="sxs-lookup"><span data-stu-id="fae3c-213">The LevelX NOR driver "block erased verify" service is responsible for verifying that the specified block of the NOR flash is erased.</span></span> <span data-ttu-id="fae3c-214">Silinirse, LevelX ve sürücü **LX_SUCCESS** döndürür.</span><span class="sxs-lookup"><span data-stu-id="fae3c-214">If it is erased, the LevelX NOR driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="fae3c-215">Blok silinmeyen, LevelX ve sürücü **LX_ERROR** döndürür.</span><span class="sxs-lookup"><span data-stu-id="fae3c-215">If the block is not erased, the LevelX NOR driver returns **LX_ERROR**.</span></span> <span data-ttu-id="fae3c-216">LevelX ve sürücü "blok silinenler" hizmetinin prototipi:</span><span class="sxs-lookup"><span data-stu-id="fae3c-216">The prototype of the LevelX NOR driver "block erased verify" service is:</span></span>

```c
INT nor_driver_block_erased_verify(ULONG block);
```

<span data-ttu-id="fae3c-217">Burada "*Engelle*", hangi bloğun silindiğini doğrulayabildiğini belirtir.</span><span class="sxs-lookup"><span data-stu-id="fae3c-217">Where "*block*" specifies which block to verify that it is erased.</span></span>

> [!NOTE]
> <span data-ttu-id="fae3c-218">LevelX, silindiklerinden emin olmak için belirtilen tüm baytları incelemek için sürücüyü kullanır (tümünü içerir).</span><span class="sxs-lookup"><span data-stu-id="fae3c-218">LevelX relies on the driver to examine all bytes of the specified to ensure they are erased (contain all ones).</span></span>

## <a name="driver-system-error"></a><span data-ttu-id="fae3c-219">Sürücü sistemi hatası</span><span class="sxs-lookup"><span data-stu-id="fae3c-219">Driver System Error</span></span>

<span data-ttu-id="fae3c-220">Levelx ve sürücü "sistem hatası işleyicisi" hizmeti, LevelX tarafından algılanan sistem hatalarının işlenmesini ayarlamaktan sorumludur.</span><span class="sxs-lookup"><span data-stu-id="fae3c-220">The LevelX NOR driver "system error handler" service is responsible for setting handling system errors detected by LevelX.</span></span> <span data-ttu-id="fae3c-221">Bu yordamın işleme uygulamaya bağımlıdır.</span><span class="sxs-lookup"><span data-stu-id="fae3c-221">The processing in this routine is application dependent.</span></span> <span data-ttu-id="fae3c-222">Başarılı olursa, LevelX ve sürücü **LX_SUCCESS** döndürür.</span><span class="sxs-lookup"><span data-stu-id="fae3c-222">If it is successful, the LevelX NOR driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="fae3c-223">Başarılı olmazsa, LevelX ve sürücü **LX_ERROR** döndürür.</span><span class="sxs-lookup"><span data-stu-id="fae3c-223">If it is not successful, the LevelX NOR driver returns **LX_ERROR**.</span></span> <span data-ttu-id="fae3c-224">LevelX ve sürücü "sistem hatası" hizmetinin prototipi:</span><span class="sxs-lookup"><span data-stu-id="fae3c-224">The prototype of the LevelX NOR driver "system error" service is:</span></span>

```c
INT nor_driver_system_error(UINT error_code);
```

<span data-ttu-id="fae3c-225">Burada "*error_code*" oluşan hatayı temsil eder.</span><span class="sxs-lookup"><span data-stu-id="fae3c-225">Where "*error_code*" represents the error that occurred.</span></span>

## <a name="nor-simulated-driver"></a><span data-ttu-id="fae3c-226">VEYA sanal sürücü</span><span class="sxs-lookup"><span data-stu-id="fae3c-226">NOR Simulated Driver</span></span>

<span data-ttu-id="fae3c-227">LevelX, veya Flash bölümü işleminin benzetimini yapmak için yalnızca RAM kullanan bir benzetimli veya Flash sürücü sağlar.</span><span class="sxs-lookup"><span data-stu-id="fae3c-227">LevelX provides a simulated NOR flash driver that simply uses RAM to simulate the operation of a NOR flash part.</span></span> <span data-ttu-id="fae3c-228">Varsayılan olarak, veya sanal sürücü blok başına 16 512 baytlık sektörle 8 veya Flash blokları sağlar.</span><span class="sxs-lookup"><span data-stu-id="fae3c-228">By default, the NOR simulated driver provides 8 NOR flash blocks with 16 512-byte sectors per block.</span></span>

<span data-ttu-id="fae3c-229">Benzetimli veya Flash sürücü başlatma işlevi, \***lx_nor_flash_simulator_initialize** _ ve _ *_lx_nor_flash_simulator. c_* \* içinde tanımlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="fae3c-229">The simulated NOR flash driver initialization function is ***lx_nor_flash_simulator_initialize** _ and is defined in _*_lx_nor_flash_simulator.c_\*\*.</span></span> <span data-ttu-id="fae3c-230">Bu sürücü Ayrıca, belirli veya Flash sürücüleri yazmak için iyi bir şablon sağlar.</span><span class="sxs-lookup"><span data-stu-id="fae3c-230">This driver also provides a good template for writing specific NOR flash drivers.</span></span>

## <a name="nor-filex-integration"></a><span data-ttu-id="fae3c-231">VEYA FileX tümleştirmesi</span><span class="sxs-lookup"><span data-stu-id="fae3c-231">NOR FileX Integration</span></span>

<span data-ttu-id="fae3c-232">Daha önce belirtildiği gibi, LevelX işlem için FileX 'i kullanmaz.</span><span class="sxs-lookup"><span data-stu-id="fae3c-232">As mentioned earlier, LevelX does not rely on FileX for operation.</span></span> <span data-ttu-id="fae3c-233">Tüm LevelX API 'Leri, ham verileri, LevelX tarafından sunulan mantıksal sektörlerde depolamak/almak için doğrudan uygulama yazılımı tarafından çağrılabilir.</span><span class="sxs-lookup"><span data-stu-id="fae3c-233">All the LevelX APIs may be called directly by the application software to store/retrieve raw data to the logical sectors provided by LevelX.</span></span> <span data-ttu-id="fae3c-234">Ancak, LevelX de Fılex 'i destekler.</span><span class="sxs-lookup"><span data-stu-id="fae3c-234">However, LevelX also supports FileX.</span></span>

<span data-ttu-id="fae3c-235">***Fx_nor_flash_simulated_driver. c*** dosyası, veya flash simülasyonu ile kullanılmak üzere bir örnek FileX sürücüsü içerir.</span><span class="sxs-lookup"><span data-stu-id="fae3c-235">The file ***fx_nor_flash_simulated_driver.c*** contains an example FileX driver for use with the NOR flash simulation.</span></span> <span data-ttu-id="fae3c-236">LevelX için Flash FileX sürücüsü, özel FileX sürücüleri yazmak için iyi bir başlangıç noktası sağlar.</span><span class="sxs-lookup"><span data-stu-id="fae3c-236">The NOR flash FileX driver for LevelX provides a good starting point for writing custom FileX drivers.</span></span>

> [!NOTE]
> <span data-ttu-id="fae3c-237">FileX veya Flash biçimi, veya Flash tarafından sağlanan kesimlerin bir tam blok boyutu olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="fae3c-237">The FileX NOR flash format should be one full block size of sectors less than the NOR flash provides.</span></span> <span data-ttu-id="fae3c-238">Bu, aşınma düzeyi işleme sırasında en iyi performansı sağlamaya yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="fae3c-238">This will help ensure best performance during the wear level processing.</span></span> <span data-ttu-id="fae3c-239">LevelX aşmalar seviyelendirme algoritmasındaki yazma performansını artırmaya yönelik ek teknikler şunlardır:</span><span class="sxs-lookup"><span data-stu-id="fae3c-239">Additional techniques to improve write performance in the LevelX wear leveling algorithm include:</span></span>
> 1. <span data-ttu-id="fae3c-240">Tüm yazmamaların tam olarak bir veya daha fazla küme olduğundan emin olun ve tam küme sınırları üzerinde başlatın.</span><span class="sxs-lookup"><span data-stu-id="fae3c-240">Ensure that all writes are exactly one or more clusters in size and start on exact cluster boundaries.</span></span>
> 2. <span data-ttu-id="fae3c-241">API 'lerin FileX ***fx_file_allocate*** sınıfı aracılığıyla büyük dosya yazma işlemleri gerçekleştirmeden önce kümeleri önceden ayırın.</span><span class="sxs-lookup"><span data-stu-id="fae3c-241">Pre-allocate clusters before performing large file write operations via the FileX ***fx_file_allocate*** class of APIs.</span></span>
> 3.  <span data-ttu-id="fae3c-242">***Lx_nor_flash_defragment*** düzenli olarak kullanımı mümkün olduğunca çok sayıda ve blok ve bu sayede yazma performansını geliştirir.</span><span class="sxs-lookup"><span data-stu-id="fae3c-242">Periodic use of ***lx_nor_flash_defragment*** to free up as many NOR blocks as possible and thus improve write performance.</span></span>
> 4. <span data-ttu-id="fae3c-243">FileX sürücüsünün yayın sektörü bilgilerini alacak şekilde etkinleştirildiğinden emin olun ve sürücü sürüm sektörlerine yapılan istekler ***lx_nor_flash_sector_release*** çağırarak sürücüde işlenir.</span><span class="sxs-lookup"><span data-stu-id="fae3c-243">Ensure the FileX driver is enabled to receive release sector information and requests made to the driver to release sectors are handled in the driver by calling ***lx_nor_flash_sector_release***.</span></span>
