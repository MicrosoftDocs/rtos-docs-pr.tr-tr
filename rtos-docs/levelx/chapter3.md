---
title: Azure RTOS LevelX nve desteği
description: NVE Flash belleği, genellikle dosya sistemlerinin tipik bir örneği olan büyük veri depolama için LevelX içinde kullanılır.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 3286e4ea7f16b28ff55fc95a87a1e0c313ec4240
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/22/2021
ms.locfileid: "104826267"
---
# <a name="chapter-3---azure-rtos-levelx-nand-support"></a><span data-ttu-id="7d4e9-103">Bölüm 3-Azure RTOS LevelX nve desteği</span><span class="sxs-lookup"><span data-stu-id="7d4e9-103">Chapter 3 - Azure RTOS LevelX NAND support</span></span>

<span data-ttu-id="7d4e9-104">NVE Flash belleği genellikle dosya sistemlerinin tipik bir örneği olan büyük veri depolama için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-104">NAND flash memory is commonly utilized for large data storage, which is typical of file systems.</span></span> <span data-ttu-id="7d4e9-105">NVE belleği *bloklardan* oluşur.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-105">NAND memory consists of *blocks*.</span></span> <span data-ttu-id="7d4e9-106">Her nve bloğunun içinde bir dizi *sayfa*.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-106">Within each NAND block is a series of *pages*.</span></span> <span data-ttu-id="7d4e9-107">NAND blokları silinebilir, yani nve bloğu içindeki tüm sayfalar silinir (tümüne ayarlanır).</span><span class="sxs-lookup"><span data-stu-id="7d4e9-107">NAND blocks are erasable, which means that all pages within the NAND block are erased (set to all ones).</span></span> <span data-ttu-id="7d4e9-108">Her nve blok sayfasında, Azure RTOS LevelX tarafından muhasebe, bozuk blok yönetimi ve hata algılama için kullanılan bir dizi *yedek bayt* bulunur.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-108">Each NAND block page has a set of *spare bytes* that are utilized by Azure RTOS LevelX for bookkeeping, bad block management, and error detection.</span></span> <span data-ttu-id="7d4e9-109">NVE blok sayfaları çeşitli boyutlarda kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-109">NAND block pages are available in a variety of sizes.</span></span> <span data-ttu-id="7d4e9-110">En yaygın sayfa boyutları şunlardır:</span><span class="sxs-lookup"><span data-stu-id="7d4e9-110">The most common page sizes are:</span></span> 

| <span data-ttu-id="7d4e9-111">**Sayfa boyutu**</span><span class="sxs-lookup"><span data-stu-id="7d4e9-111">**Page Size**</span></span> | <span data-ttu-id="7d4e9-112">**Yedek baytlar**</span><span class="sxs-lookup"><span data-stu-id="7d4e9-112">**Spare Bytes**</span></span> |
| ------------- | --------------- |
| <span data-ttu-id="7d4e9-113">256</span><span class="sxs-lookup"><span data-stu-id="7d4e9-113">256</span></span>           | <span data-ttu-id="7d4e9-114">8</span><span class="sxs-lookup"><span data-stu-id="7d4e9-114">8</span></span>               |
| <span data-ttu-id="7d4e9-115">512</span><span class="sxs-lookup"><span data-stu-id="7d4e9-115">512</span></span>           | <span data-ttu-id="7d4e9-116">16</span><span class="sxs-lookup"><span data-stu-id="7d4e9-116">16</span></span>              |
| <span data-ttu-id="7d4e9-117">2048</span><span class="sxs-lookup"><span data-stu-id="7d4e9-117">2048</span></span>          | <span data-ttu-id="7d4e9-118">64</span><span class="sxs-lookup"><span data-stu-id="7d4e9-118">64</span></span>              |

<span data-ttu-id="7d4e9-119">NVE belleği, doğrudan erişim bulunmadığından veya bellekten farklıdır; Örneğin, nve bellek, doğrudan işlemciden veya bellekten bellek gibi okunamaz.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-119">NAND memory differs from NOR memory in that there is no direct access, i.e., NAND memory cannot be read directly from the processor like NOR memory.</span></span> <span data-ttu-id="7d4e9-120">NVE belleği yalnızca, sınırlı sayıda silme işleminden sonra yazılabilir.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-120">NAND memory can only be written to after an erase a limited number of times.</span></span> <span data-ttu-id="7d4e9-121">Bu, bu değerden ve yazma isteğinin küme bitlerini temizleme işlemini sağlayan sınırsız sayıda kez yazılabilen bellekten farklıdır.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-121">Again, this differs from NOR memory that can be written an unlimited number of times providing the write request is clearing set bits.</span></span> <span data-ttu-id="7d4e9-122">Son olarak, her sayfayla ilişkili yedek baytlar nve Flash için benzersizdir.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-122">Finally, the spare bytes associated with each page are unique to NAND flash.</span></span> <span data-ttu-id="7d4e9-123">Tipik yedek bayt yapılandırması aşağıdaki tabloda gösterildiği gibidir.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-123">Typical spare byte configurations are as shown in the table below.</span></span>

| <span data-ttu-id="7d4e9-124">**Yedek baytlar**</span><span class="sxs-lookup"><span data-stu-id="7d4e9-124">**Spare Bytes**</span></span> | <span data-ttu-id="7d4e9-125">**Bayt numaraları**</span><span class="sxs-lookup"><span data-stu-id="7d4e9-125">**Byte numbers**</span></span> | <span data-ttu-id="7d4e9-126">**Yapılandırma**</span><span class="sxs-lookup"><span data-stu-id="7d4e9-126">**Configuration**</span></span>     |
| ------------------------- | -------------- | --------------------- |
| <span data-ttu-id="7d4e9-127">8</span><span class="sxs-lookup"><span data-stu-id="7d4e9-127">8</span></span>                         | <span data-ttu-id="7d4e9-128">Bayt 0-2:</span><span class="sxs-lookup"><span data-stu-id="7d4e9-128">Bytes 0-2:</span></span>     | <span data-ttu-id="7d4e9-129">ECC bayt sayısı</span><span class="sxs-lookup"><span data-stu-id="7d4e9-129">ECC bytes</span></span>             |
|                           | <span data-ttu-id="7d4e9-130">Bayt 3, 4, 6, 7:</span><span class="sxs-lookup"><span data-stu-id="7d4e9-130">Bytes 3,4,6,7:</span></span> | <span data-ttu-id="7d4e9-131">LevelX kesim eşleme</span><span class="sxs-lookup"><span data-stu-id="7d4e9-131">LevelX Sector Mapping</span></span> |
|                           | <span data-ttu-id="7d4e9-132">Bayt 5:</span><span class="sxs-lookup"><span data-stu-id="7d4e9-132">Byte 5:</span></span>        | <span data-ttu-id="7d4e9-133">Hatalı blok bayrağı</span><span class="sxs-lookup"><span data-stu-id="7d4e9-133">Bad block flag</span></span>        |
| <span data-ttu-id="7d4e9-134">16</span><span class="sxs-lookup"><span data-stu-id="7d4e9-134">16</span></span>                        | <span data-ttu-id="7d4e9-135">Bayt 0-3, 6-7:</span><span class="sxs-lookup"><span data-stu-id="7d4e9-135">Bytes 0-3,6-7:</span></span> | <span data-ttu-id="7d4e9-136">ECC bayt sayısı</span><span class="sxs-lookup"><span data-stu-id="7d4e9-136">ECC bytes</span></span>             |
|                           | <span data-ttu-id="7d4e9-137">Bayt 8-11:</span><span class="sxs-lookup"><span data-stu-id="7d4e9-137">Bytes 8-11:</span></span>    | <span data-ttu-id="7d4e9-138">LevelX kesim eşleme</span><span class="sxs-lookup"><span data-stu-id="7d4e9-138">LevelX Sector Mapping</span></span> |
|                           | <span data-ttu-id="7d4e9-139">Bayt 12-15:</span><span class="sxs-lookup"><span data-stu-id="7d4e9-139">Bytes 12-15:</span></span>   | <span data-ttu-id="7d4e9-140">Kullanılmıyor</span><span class="sxs-lookup"><span data-stu-id="7d4e9-140">Unused</span></span>                |
|                           | <span data-ttu-id="7d4e9-141">Bayt 5:</span><span class="sxs-lookup"><span data-stu-id="7d4e9-141">Byte 5:</span></span>        | <span data-ttu-id="7d4e9-142">Hatalı blok bayrağı</span><span class="sxs-lookup"><span data-stu-id="7d4e9-142">Bad block flag</span></span>        |
| <span data-ttu-id="7d4e9-143">64</span><span class="sxs-lookup"><span data-stu-id="7d4e9-143">64</span></span>                        | <span data-ttu-id="7d4e9-144">Bayt 0:</span><span class="sxs-lookup"><span data-stu-id="7d4e9-144">Byte 0:</span></span>        | <span data-ttu-id="7d4e9-145">Hatalı blok bayrağı</span><span class="sxs-lookup"><span data-stu-id="7d4e9-145">Bad block flag</span></span>        |
|                           | <span data-ttu-id="7d4e9-146">Bayt 2-5:</span><span class="sxs-lookup"><span data-stu-id="7d4e9-146">Bytes 2-5:</span></span>     | <span data-ttu-id="7d4e9-147">LevelX kesim eşleme</span><span class="sxs-lookup"><span data-stu-id="7d4e9-147">LevelX Sector Mapping</span></span> |
|                           | <span data-ttu-id="7d4e9-148">Bayt 6-39:</span><span class="sxs-lookup"><span data-stu-id="7d4e9-148">Bytes 6-39:</span></span>    | <span data-ttu-id="7d4e9-149">Kullanılmıyor</span><span class="sxs-lookup"><span data-stu-id="7d4e9-149">Unused</span></span>                |
|                           | <span data-ttu-id="7d4e9-150">Bayt 40-63:</span><span class="sxs-lookup"><span data-stu-id="7d4e9-150">Bytes 40-63:</span></span>   | <span data-ttu-id="7d4e9-151">ECC bayt sayısı</span><span class="sxs-lookup"><span data-stu-id="7d4e9-151">ECC bytes</span></span>             |

<span data-ttu-id="7d4e9-152">LevelX, fiziksel nve sayfasıyla eşleştirilmiş mantıksal sektörün izlenmesini sağlamak için her bir nve sayfanın yedek baytından oluşan 4 ' ü kullanır.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-152">LevelX Utilizes 4 of the spare bytes of each NAND page for keeping track of the logical sector mapped to the physical NAND page.</span></span> <span data-ttu-id="7d4e9-153">Bu 4 bayt, bir LevelX özel biçimiyle 32 bitlik işaretsiz bir tamsayı uygulamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-153">These 4 bytes are used to implement a 32-bit unsigned integer with a LevelX proprietary format.</span></span> <span data-ttu-id="7d4e9-154">32 bitlik alanın (bit 31) üst biti, mantıksal kesim-sayfa eşlemesinin geçerli olduğunu göstermek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-154">The upper bit of the 32-bit field (bit 31) is used to indicate the logical sector-to-page mapping is valid.</span></span> <span data-ttu-id="7d4e9-155">Bu bit 0 ise, bu sayfadaki bilgiler artık geçerli değildir.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-155">If this bit is 0, the information in this page is no longer valid.</span></span> <span data-ttu-id="7d4e9-156">Sonraki bit — bit 30 — bu sayfanın kullanılmıyor olma sürecinde olduğunu ve yeni bir sektör yazıldığını belirtmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-156">The next bit—bit 30—is used to indicate this page is in the process of becoming obsolete and a new sector is being written.</span></span> <span data-ttu-id="7d4e9-157">Eşleme girişi yazma işleminin tamamlandığını göstermek için bit 29 kullanılır.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-157">Bit 29 is used to indicate when the mapping entry write is complete.</span></span> <span data-ttu-id="7d4e9-158">Bit 29 0 ise, eşleme girişi yazma tamamlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-158">If bit 29 is 0, the mapping entry write is complete.</span></span> <span data-ttu-id="7d4e9-159">Bit 29 ayarlanmışsa, eşleme girişi yazma süreciydi.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-159">If bit 29 is set, the mapping entry was in the process of being written.</span></span> <span data-ttu-id="7d4e9-160">BITS 30 ve 29, yeni bir Flash sayfası güncelleştirilirken olası bir güç kaybından kurtarmak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-160">Bits 30 and 29 are used in recovering from a potential power loss while updating a new flash page.</span></span> <span data-ttu-id="7d4e9-161">Son olarak, daha düşük 29 bit (28-0) sayfanın mantıksal sektör numarasını içerir.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-161">Finally, the lower 29-bits (28-0) contain the logical sector number for the page.</span></span>

<span data-ttu-id="7d4e9-162">**LevelX eşleme girişi**</span><span class="sxs-lookup"><span data-stu-id="7d4e9-162">**LevelX Mapping Entry**</span></span>

| <span data-ttu-id="7d4e9-163">Bit (lar)</span><span class="sxs-lookup"><span data-stu-id="7d4e9-163">Bit(s)</span></span> | <span data-ttu-id="7d4e9-164">Anlamı</span><span class="sxs-lookup"><span data-stu-id="7d4e9-164">Meaning</span></span> |
| ------ | ------- |
| <span data-ttu-id="7d4e9-165">31</span><span class="sxs-lookup"><span data-stu-id="7d4e9-165">31</span></span>     | <span data-ttu-id="7d4e9-166">Geçerli bayrak.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-166">Valid flag.</span></span> <span data-ttu-id="7d4e9-167">Set ve mantıksal kesim her ikisi de, eşlemenin geçerli olduğunu belirtir</span><span class="sxs-lookup"><span data-stu-id="7d4e9-167">When set and logical sector is not all ones indicates mapping is valid</span></span> |
| <span data-ttu-id="7d4e9-168">30</span><span class="sxs-lookup"><span data-stu-id="7d4e9-168">30</span></span>     | <span data-ttu-id="7d4e9-169">Kullanım dışı bayrağı.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-169">Obsolete flag.</span></span> <span data-ttu-id="7d4e9-170">Bu eşleme açık olmadığında veya artık kullanılmıyor olma sürecinde.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-170">When clear, this mapping is either obsolete or is in the process of becoming obsolete.</span></span> |
| <span data-ttu-id="7d4e9-171">29</span><span class="sxs-lookup"><span data-stu-id="7d4e9-171">29</span></span>     | <span data-ttu-id="7d4e9-172">Bu bit 0 olduğunda eşleme girişi yazma işlemi tamamlanır</span><span class="sxs-lookup"><span data-stu-id="7d4e9-172">Mapping entry write is complete when this bit is 0</span></span> |
| <span data-ttu-id="7d4e9-173">0-28</span><span class="sxs-lookup"><span data-stu-id="7d4e9-173">0-28</span></span>   | <span data-ttu-id="7d4e9-174">Bu fiziksel sayfayla eşlenen mantıksal kesim (hepsi değil).</span><span class="sxs-lookup"><span data-stu-id="7d4e9-174">Logical sector mapped to this physical page—when not all ones.</span></span> |

<span data-ttu-id="7d4e9-175">LevelX, blok silme sayısı için her nve bloğunun ilk sayfasından ve blok dolduğunda eşlenen sayfaların listesine de yararlanır.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-175">LevelX also utilizes the first page of each NAND block for the block erase count as well as the list of mapped pages when the block is full.</span></span> <span data-ttu-id="7d4e9-176">LevelX içindeki bir nve bloğunun ilk sayfasının biçimi aşağıda gösterilmiştir:</span><span class="sxs-lookup"><span data-stu-id="7d4e9-176">The format of the first page of a NAND block in LevelX is shown below:</span></span>

| <span data-ttu-id="7d4e9-177">LevelX blok sayfası 0 biçimi</span><span class="sxs-lookup"><span data-stu-id="7d4e9-177">LevelX Block Page 0 Format</span></span> |
|:--------------------------:|
| <span data-ttu-id="7d4e9-178">[Blok silme sayısı]</span><span class="sxs-lookup"><span data-stu-id="7d4e9-178">[Block Erase Count]</span></span>        |
| <span data-ttu-id="7d4e9-179">[Sayfa 1 kesim eşleme]</span><span class="sxs-lookup"><span data-stu-id="7d4e9-179">[Page 1 Sector Mapping]</span></span>    |
| <span data-ttu-id="7d4e9-180">...</span><span class="sxs-lookup"><span data-stu-id="7d4e9-180">...</span></span>                        |
| <span data-ttu-id="7d4e9-181">[Sayfa "n" kesim eşleme]</span><span class="sxs-lookup"><span data-stu-id="7d4e9-181">[Page "n" Sector Mapping]</span></span>  |
| <span data-ttu-id="7d4e9-182">[0xF0F0F0F0]</span><span class="sxs-lookup"><span data-stu-id="7d4e9-182">[0xF0F0F0F0]</span></span>               |

> [!NOTE]
> <span data-ttu-id="7d4e9-183">Sayfa eşleme bilgileri yalnızca blok dolduğunda yazılır, yani bloktaki tüm sayfalar üzerine yazılır.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-183">The page mapping information is only written when the block is full, i.e., all the pages of the block have been written to.</span></span> <span data-ttu-id="7d4e9-184">Bu, çalışma zamanında Ücretsiz sayfalar ve mantıksal kesim eşlemesi için daha hızlı arama yapmanızı sağlar.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-184">This enables faster search for free pages and logical sector mapping during run-time.</span></span>

## <a name="nand-bad-block-support"></a><span data-ttu-id="7d4e9-185">NVE hatalı blok desteği</span><span class="sxs-lookup"><span data-stu-id="7d4e9-185">NAND Bad Block Support</span></span>

<span data-ttu-id="7d4e9-186">NVE belleğin bozuk blokları veya belleği da daha yüksektir.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-186">NAND memory is also more likely to have bad blocks than NOR memory.</span></span> <span data-ttu-id="7d4e9-187">Bu çoğu büyük bir deyişle, nve üreticileri kötü bloklara izin vererek ve yazılımın bu tür hatalı bloklar üzerinde çalışmasını gerektirerek verimi artırabilir.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-187">This is largely because NAND manufacturers can increase yield by allowing bad blocks and requiring software to work-around such bad blocks.</span></span> <span data-ttu-id="7d4e9-188">LevelX yalnızca hatalı bloklar etrafında eşleme yaparak nve hatalı blok yönetimini işler.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-188">LevelX handles NAND bad block management by simply mapping around bad blocks.</span></span>

<span data-ttu-id="7d4e9-189">LevelX, yeni ECC kodlarını hesaplamak için kullanılacak temel LevelX sürücüsü için 256 baytlık bir hata düzeltme kodları (ECC) için API 'Ler sağlar veya sayfanın her 256-Byte bölümünde sayfa okuma sırasında 1 bit hata düzeltmesi gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-189">LevelX also provides APIs for 256-byte Hamming Error Correction Codes (ECC) for the underlying LevelX driver to utilize for calculating new ECC codes or to perform 1-bit error correction on page reading within each 256-byte section of the page.</span></span>

## <a name="nand-driver-requirements"></a><span data-ttu-id="7d4e9-190">NVE sürücü gereksinimleri</span><span class="sxs-lookup"><span data-stu-id="7d4e9-190">NAND Driver Requirements</span></span>

<span data-ttu-id="7d4e9-191">LevelX, temel alınan Flash bölümü ve donanım uygulamasına özel bir temel nve Flash sürücüsü gerektirir.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-191">LevelX requires an underlying NAND flash driver that is specific to the underlying flash part and hardware implementation.</span></span> <span data-ttu-id="7d4e9-192">Sürücü, API ***lx_nand_flash_open*** aracılığıyla başlatma sırasında levelx olarak belirtilir.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-192">The driver is specified to LevelX during initialization via the API ***lx_nand_flash_open***.</span></span> <span data-ttu-id="7d4e9-193">LevelX sürücüsünün prototipi aşağıdaki gibidir.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-193">The prototype of the LevelX driver is as follows.</span></span>

```c
INT nand_driver_initialize(LX_NAND_FLASH *instance);
```

<span data-ttu-id="7d4e9-194">*Örnek* parametresi, LEVELX NAND denetim bloğunu belirtir.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-194">The *instance* parameter specifies the LevelX NAND control block.</span></span> <span data-ttu-id="7d4e9-195">Sürücü başlatma işlevi, ilişkili LevelX örneği için diğer tüm sürücü düzeyi Hizmetleri ayarlamaktan sorumludur.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-195">The driver initialization function is responsible for setting up all the other driver-level services for the associated LevelX instance.</span></span> <span data-ttu-id="7d4e9-196">Her bir LevelX NAND örneği için gereken hizmetler aşağıdaki listede gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-196">The services required for each LevelX NAND instance are shown in the list below.</span></span>

- <span data-ttu-id="7d4e9-197">Sayfayı oku</span><span class="sxs-lookup"><span data-stu-id="7d4e9-197">Read Page</span></span>
- <span data-ttu-id="7d4e9-198">Yazma sayfası</span><span class="sxs-lookup"><span data-stu-id="7d4e9-198">Write Page</span></span>
- <span data-ttu-id="7d4e9-199">Blok silme</span><span class="sxs-lookup"><span data-stu-id="7d4e9-199">Block Erase</span></span>
- <span data-ttu-id="7d4e9-200">Blok silinme doğrulaması</span><span class="sxs-lookup"><span data-stu-id="7d4e9-200">Block Erased Verify</span></span>
- <span data-ttu-id="7d4e9-201">Sayfa silindi doğrula</span><span class="sxs-lookup"><span data-stu-id="7d4e9-201">Page Erased Verify</span></span>
- <span data-ttu-id="7d4e9-202">Engelleme durumu Al</span><span class="sxs-lookup"><span data-stu-id="7d4e9-202">Block Status Get</span></span>
- <span data-ttu-id="7d4e9-203">Blok durumu kümesi</span><span class="sxs-lookup"><span data-stu-id="7d4e9-203">Block Status Set</span></span>
- <span data-ttu-id="7d4e9-204">Ek baytları engelle al</span><span class="sxs-lookup"><span data-stu-id="7d4e9-204">Block Extra Bytes Get</span></span>
- <span data-ttu-id="7d4e9-205">Fazla bayt kümesini engelle</span><span class="sxs-lookup"><span data-stu-id="7d4e9-205">Block Extra Bytes Set</span></span>
- <span data-ttu-id="7d4e9-206">Sistem hata Işleyicisi</span><span class="sxs-lookup"><span data-stu-id="7d4e9-206">System Error Handler</span></span>

## <a name="driver-initialization"></a><span data-ttu-id="7d4e9-207">Sürücü başlatma</span><span class="sxs-lookup"><span data-stu-id="7d4e9-207">Driver Initialization</span></span>

<span data-ttu-id="7d4e9-208">Bu hizmetler, sürücünün başlatma işlevindeki **LX_NAND_FLASH** örneğindeki işlev işaretçileri ayarlanarak kurulumlardır.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-208">These services are setup via setting function pointers in the **LX_NAND_FLASH** instance within the driver's initialization function.</span></span> <span data-ttu-id="7d4e9-209">Sürücü başlatma işlevi aynı zamanda toplam blok sayısını, blok başına sayfa sayısını, sayfa başına baytları ve bir sayfadan oluşan belleği okumak için yeterince büyük bir RAM alanını belirtir.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-209">The driver initialization function also specifies the total number of block, pages per block, bytes per page, and a RAM area large enough to read one page into memory.</span></span> <span data-ttu-id="7d4e9-210">Sürücü başlatma işlevi büyük olasılıkla **LX_SUCCESS** döndürmeden önce ek cihaz ve/veya uygulamaya özgü başlatma görevlerini de gerçekleştiriyor.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-210">The driver initialization function likely also performs additional device and/or implementation-specific initialization duties before returning **LX_SUCCESS**.</span></span>

## <a name="driver-read-page"></a><span data-ttu-id="7d4e9-211">Sürücü okuma sayfası</span><span class="sxs-lookup"><span data-stu-id="7d4e9-211">Driver Read Page</span></span>

<span data-ttu-id="7d4e9-212">LevelX nve sürücü "okuma sayfası" hizmeti, nve Flash 'ın belirli bir bloğundaki belirli bir sayfayı okumaktan sorumludur.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-212">The LevelX NAND driver "read page" service is responsible for reading a specific page in a specific block of the NAND flash.</span></span> <span data-ttu-id="7d4e9-213">Mantığın tüm hata denetlemesi ve düzeltilmesi, sürücü hizmetinin sorumluluğundadır.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-213">All error checking and correcting logic is the responsibility of the driver service.</span></span> <span data-ttu-id="7d4e9-214">Başarılı olursa, LevelX nve sürücüsü **LX_SUCCESS** döndürür.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-214">If successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="7d4e9-215">Başarılı olmazsa, LevelX nve sürücüsü **LX_ERROR** döndürür.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-215">If not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="7d4e9-216">LevelX nve sürücü "okuma sayfası" hizmetinin prototipi aşağıda verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-216">The prototype of the LevelX NAND driver "read page" service is given below.</span></span>

```c
INT nand_driver_read_page(
    ULONG block,
    ULONG page,
    ULONG *destination, 
    ULONG words);
```

<span data-ttu-id="7d4e9-217">Burada *blok* ve *sayfa* hangi sayfanın okunacağını ve *hedef* ve *sözcükleri* belirler sayfa içeriğinin nereye yerleştirileceğini ve kaç 32 bitlik kelime okunacağını belirtir.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-217">Where *block* and *page* identify which page to read and *destination* and *words* specify where to place the page contents and how many 32-bit words to read.</span></span>

## <a name="driver-write-page"></a><span data-ttu-id="7d4e9-218">Sürücü yazma sayfası</span><span class="sxs-lookup"><span data-stu-id="7d4e9-218">Driver Write Page</span></span>

<span data-ttu-id="7d4e9-219">LevelX nve sürücü "yazma sayfası" hizmeti, belirli bir sayfanın belirtilen nve Flash bloğuna yazmasından sorumludur.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-219">The LevelX NAND driver "write page" service is responsible for writing a specific page into the specified block of the NAND flash.</span></span> <span data-ttu-id="7d4e9-220">Tüm hata denetimi ve ECC hesaplama, sürücü hizmetinin sorumluluğundadır.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-220">All error checking and ECC computation is the responsibility of the driver service.</span></span> <span data-ttu-id="7d4e9-221">Başarılı olursa, LevelX nve sürücüsü **LX_SUCCESS** döndürür.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-221">If successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="7d4e9-222">Başarılı olmazsa, LevelX nve sürücüsü **LX_ERROR** döndürür.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-222">If not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="7d4e9-223">LevelX nve sürücü "yazma sayfası" hizmetinin prototipi aşağıda gösterilmiştir.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-223">The prototype of the LevelX NAND driver "write page" service is shown below.</span></span>

```c
INT nand_driver_write_page(
    ULONG block, 
    ULONG page,
    ULONG *source, 
    ULONG words);
```

<span data-ttu-id="7d4e9-224">Burada *blok* ve *sayfa* hangi sayfanın yazılacağını ve *kaynak* ve *sözcükleri* belirler, yazma kaynağını ve kaç 32 bitlik sözcük yazılacağını belirtir.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-224">Where *block* and *page* identify which page to write and *source* and *words* specify the source of the write and how many 32-bit words to write.</span></span>

> [!NOTE]
> <span data-ttu-id="7d4e9-225">LevelX, genellikle sayfanın geri okunmasını ve yazma işleminin başarılı olduğundan emin olmak için yazma arabelleğini karşılaştırarak, Flash sayfasına yazarken alt düzey hata algılaması için sürücüyü kullanır.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-225">LevelX relies on the driver for low-level error detection when writing to the flash page, which typically involves reading back the page and comparing with the write buffer to ensure the write was successful.</span></span>

## <a name="driver-block-erase"></a><span data-ttu-id="7d4e9-226">Sürücü bloğunu silme</span><span class="sxs-lookup"><span data-stu-id="7d4e9-226">Driver Block Erase</span></span>

<span data-ttu-id="7d4e9-227">LevelX nve sürücü "blok silme" hizmeti, nve Flash 'un belirtilen bloğunu silmekten sorumludur.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-227">The LevelX NAND driver "block erase" service is responsible for erasing the specified block of the NAND flash.</span></span> <span data-ttu-id="7d4e9-228">Başarılı olursa, LevelX nve sürücüsü **LX_SUCCESS** döndürür.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-228">If successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="7d4e9-229">Başarılı olmazsa, LevelX nve sürücüsü **LX_ERROR** döndürür.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-229">If not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="7d4e9-230">LevelX nve sürücü "blok silme" hizmetinin prototipi aşağıdaki gibidir.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-230">The prototype of the LevelX NAND driver "block erase" service is as follows.</span></span>

```c
INT nand_driver_block_erase(ULONG block,  
    ULONG erase_count);
```

<span data-ttu-id="7d4e9-231">Burada *blok* hangi bloğun silinecek bloğunu belirler.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-231">Where *block* identifies which block to erase.</span></span> <span data-ttu-id="7d4e9-232">*Erase_count* parametresi, tanılama amacıyla sağlanır.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-232">The parameter *erase_count* is provided for diagnostic purposes.</span></span> <span data-ttu-id="7d4e9-233">Örneğin, sürücü, silme sayısı belirli bir eşiği aştığında, uygulama yazılımının başka bir bölümüne uyarı vermek isteyebilir.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-233">For example, the driver may want to alert another portion of the application software when the erase count exceeds a specific threshold.</span></span>

> [!NOTE]
> <span data-ttu-id="7d4e9-234">LevelX, blok silinince alt düzey hata algılaması için sürücüyü kullanır. Bu, genellikle bloktaki tüm sayfaların tümünün olduğundan emin olmayı içerir.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-234">LevelX relies on the driver for low-level error detection when the block is erased, which typically involves ensuring that all pages of the block are all ones.</span></span>

## <a name="driver-block-erased-verify"></a><span data-ttu-id="7d4e9-235">Sürücü bloğunu silinen doğrulama</span><span class="sxs-lookup"><span data-stu-id="7d4e9-235">Driver Block Erased Verify</span></span>

<span data-ttu-id="7d4e9-236">LevelX nve sürücü "blok silinenler" hizmeti, nve Flash 'un belirtilen bloğunun silindiğini doğrulamaktan sorumludur.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-236">The LevelX NAND driver "block erased verify" service is responsible for verifying that the specified block of the NAND flash is erased.</span></span> <span data-ttu-id="7d4e9-237">Silinirse, LevelX nve sürücüsü **LX_SUCCESS** döndürür.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-237">If it is erased, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="7d4e9-238">Blok silinmeyen, LevelX nve sürücüsü **LX_ERROR** döndürür.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-238">If the block is not erased, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="7d4e9-239">LevelX nve sürücü "blok silinenler" hizmetinin prototipi:</span><span class="sxs-lookup"><span data-stu-id="7d4e9-239">The prototype of the LevelX NAND driver "block erased verify" service is:</span></span>

```c
INT nand_driver_block_erased_verify(ULONG block);
```

<span data-ttu-id="7d4e9-240">Burada *blok* , hangi bloğun silindiğini doğrulayabildiğini belirtir.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-240">Where *block* specifies which block to verify that it is erased.</span></span>

> [!NOTE]
> <span data-ttu-id="7d4e9-241">LevelX, tüm sayfaları ve her bir sayfanın (yedek ve veri baytları dahil olmak üzere) silindiklerinden emin olmak için sürücüyü temel alır.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-241">LevelX relies on the driver to examine all pages and all bytes of each page – including spare and data bytes – to ensure they are erased (contain all ones).</span></span>

## <a name="driver-page-erased-verify"></a><span data-ttu-id="7d4e9-242">Sürücü sayfası silinme doğrulaması</span><span class="sxs-lookup"><span data-stu-id="7d4e9-242">Driver Page Erased Verify</span></span>

<span data-ttu-id="7d4e9-243">LevelX nve Driver "sayfa silinenler" hizmeti, belirtilen nve Flash bloğunun belirtilen sayfasının silinmesinden emin olmak için sorumludur.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-243">The LevelX NAND driver "page erased verify" service is responsible for verifying that the specified page of the specified block of the NAND flash is erased.</span></span> <span data-ttu-id="7d4e9-244">Silinirse, LevelX nve sürücüsü **LX_SUCCESS** döndürür.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-244">If it is erased, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="7d4e9-245">Sayfa silinmeyen, LevelX nve sürücüsü **LX_ERROR** döndürür.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-245">If the page is not erased, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="7d4e9-246">LevelX nve sürücü "sayfa silinverify" hizmetinin prototipi:</span><span class="sxs-lookup"><span data-stu-id="7d4e9-246">The prototype of the LevelX NAND driver "page erased verify" service is:</span></span>

```c
INT nand_driver_page_erased_verify(
    ULONG block,  
    ULONG page);
```
<span data-ttu-id="7d4e9-247">Burada *blok* , hangi bloğun ve *sayfanın* silineceğini doğrulamak için sayfayı belirtir.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-247">Where *block* specifies which block and *page* specifies the page to verify that it is erased.</span></span>

> [!NOTE]
> <span data-ttu-id="7d4e9-248">LevelX belirtilen sayfanın tüm baytlarını (yedek ve veri baytları dahil olmak üzere) inceleyerek, silindiklerinden emin olmak için sürücüyü kullanır (tümünü içerir).</span><span class="sxs-lookup"><span data-stu-id="7d4e9-248">LevelX relies on the driver to examine all bytes of the specified page – including spare and data bytes – to ensure they are erased (contain all ones).</span></span>

## <a name="driver-block-status-get"></a><span data-ttu-id="7d4e9-249">Sürücü engelleme durumu Al</span><span class="sxs-lookup"><span data-stu-id="7d4e9-249">Driver Block Status Get</span></span>

<span data-ttu-id="7d4e9-250">LevelX nve sürücü "blok durumu alma" hizmeti, nve Flash 'ın belirtilen bloğunun hatalı blok bayrağını almaktan sorumludur.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-250">The LevelX NAND driver "block status get" service is responsible for retrieving the bad block flag of the specified block of the NAND flash.</span></span> <span data-ttu-id="7d4e9-251">Başarılı olursa, LevelX nve sürücüsü **LX_SUCCESS** döndürür.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-251">If it is successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="7d4e9-252">Bu başarılı olmazsa, LevelX nve sürücüsü **LX_ERROR** döndürür.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-252">If it is not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="7d4e9-253">LevelX nve sürücü "blok durumu Al" hizmetinin prototipi aşağıda verilmiştir: aşağıda gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-253">The prototype of the LevelX NAND driver "block status get" service is: shown below.</span></span>

```c
INT nand_driver_block_status_get(
    ULONG block,  
    UCHAR *bad_block_byte);
```

<span data-ttu-id="7d4e9-254">Burada *blok* , hangi bloğun ve *bad_block_byte* hatalı blok bayrağıyla ilgili hedefi belirtir.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-254">Where *block* specifies which block and *bad_block_byte* specifies the destination for the bad block flag.</span></span>

## <a name="driver-block-status-set"></a><span data-ttu-id="7d4e9-255">Sürücü bloğu durum kümesi</span><span class="sxs-lookup"><span data-stu-id="7d4e9-255">Driver Block Status Set</span></span>

<span data-ttu-id="7d4e9-256">LevelX nve sürücü "blok durum kümesi" hizmeti, nve Flash 'ın belirtilen bloğunun hatalı blok bayrağını ayarlamaktan sorumludur.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-256">The LevelX NAND driver "block status set" service is responsible for setting the bad block flag of the specified block of the NAND flash.</span></span> <span data-ttu-id="7d4e9-257">Başarılı olursa, LevelX nve sürücüsü **LX_SUCCESS** döndürür.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-257">If it is successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="7d4e9-258">Bu başarılı olmazsa, LevelX nve sürücüsü **LX_ERROR** döndürür.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-258">If it is not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="7d4e9-259">LevelX nve sürücü "blok durum kümesi" hizmetinin prototipi şunlardır:</span><span class="sxs-lookup"><span data-stu-id="7d4e9-259">The prototype of the LevelX NAND driver "block status set" service is:</span></span>

```c
INT nand_driver_block_status_set(
    ULONG block,
    UCHAR bad_block_byte);
```

<span data-ttu-id="7d4e9-260">Burada *blok* , hangi bloğun ve *bad_block_byte* hatalı blok bayrağının değerini belirtir.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-260">Where *block* specifies which block and *bad_block_byte* specifies the value of the bad block flag.</span></span>

## <a name="driver-block-extra-bytes-get"></a><span data-ttu-id="7d4e9-261">Sürücü bloğu ek baytları al</span><span class="sxs-lookup"><span data-stu-id="7d4e9-261">Driver Block Extra Bytes Get</span></span>

<span data-ttu-id="7d4e9-262">LevelX nve sürücüsü "fazladan bayt alma" işlemi, nve Flash 'un belirli bir bloğunun belirli bir sayfasıyla ilişkili ek baytları almaktan sorumludur.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-262">The LevelX NAND driver "block extra bytes get" service is responsible for retrieving extra bytes associated with a specific page of a specific block of the NAND flash.</span></span> <span data-ttu-id="7d4e9-263">Başarılı olursa, LevelX nve sürücüsü **LX_SUCCESS** döndürür.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-263">If it is successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="7d4e9-264">Bu başarılı olmazsa, LevelX nve sürücüsü **LX_ERROR** döndürür.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-264">If it is not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="7d4e9-265">LevelX nve sürücü "ekstra bayt al" hizmeti 'nin prototipi:</span><span class="sxs-lookup"><span data-stu-id="7d4e9-265">The prototype of the LevelX NAND driver "block extra bytes get" service is:</span></span>

```c
INT nand_driver_block_extra_bytes_get(
    ULONG block,  
    ULONG page, 
    UCHAR *destination, 
    UINT size);
```

<span data-ttu-id="7d4e9-266">Burada *blok* hangi engellemeyi belirtir, *sayfa* belirli bir sayfayı belirtir ve *hedef* , ek baytlar için hedefi belirtir.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-266">Where *block* specifies which block, *page* specifies the specific page and *destination* specifies the destination for the extra bytes.</span></span> <span data-ttu-id="7d4e9-267">Parametre *boyutu* kaç tane fazladan bayt alınacağını belirtir.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-267">The parameter *size* specifies how many extra bytes to get.</span></span>

## <a name="driver-block-extra-bytes-set"></a><span data-ttu-id="7d4e9-268">Sürücü bloğu ek bayt kümesi</span><span class="sxs-lookup"><span data-stu-id="7d4e9-268">Driver Block Extra Bytes Set</span></span>

<span data-ttu-id="7d4e9-269">LevelX nve sürücü "ekstra bayt kümesini engelle" hizmeti, nve Flash 'un belirli bir bloğunun belirli bir sayfasında fazladan baytlar ayarlamaktan sorumludur.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-269">The LevelX NAND driver "block extra bytes set" service is responsible for setting extra bytes in a specific page of a specific block of the NAND flash.</span></span> <span data-ttu-id="7d4e9-270">Başarılı olursa, LevelX nve sürücüsü **LX_SUCCESS** döndürür.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-270">If it is successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="7d4e9-271">Bu başarılı olmazsa, LevelX nve sürücüsü **LX_ERROR** döndürür.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-271">If it is not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="7d4e9-272">LevelX nve Driver "ekstra bayt kümesini engelle" hizmetinin prototipi şunlardır:</span><span class="sxs-lookup"><span data-stu-id="7d4e9-272">The prototype of the LevelX NAND driver "block extra bytes set" service is:</span></span>

```c
INT nand_driver_block_extra_bytes_set(
    ULONG block,  
    ULONG page, 
    UCHAR *source, 
    UINT size);
```

<span data-ttu-id="7d4e9-273">Burada *blok* hangi engellemeyi belirtir, *sayfa* belirli bir sayfayı belirtir ve *kaynak* , fazladan baytların kaynağını belirtir.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-273">Where *block* specifies which block, *page* specifies the specific page and *source* specifies the source of the extra bytes.</span></span> <span data-ttu-id="7d4e9-274">Parametre *boyutu* , kaç tane fazladan bayt ayarlanacağını belirtir.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-274">The parameter *size* specifies how many extra bytes to set.</span></span>

## <a name="driver-system-error"></a><span data-ttu-id="7d4e9-275">Sürücü sistemi hatası</span><span class="sxs-lookup"><span data-stu-id="7d4e9-275">Driver System Error</span></span>

<span data-ttu-id="7d4e9-276">Levelx nve sürücü "sistem hatası işleyicisi" hizmeti, LevelX tarafından algılanan sistem hatalarının işlenmesini ayarlamaktan sorumludur.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-276">The LevelX NAND driver "system error handler" service is responsible for setting handling system errors detected by LevelX.</span></span> <span data-ttu-id="7d4e9-277">Bu yordamın işleme uygulamaya bağımlıdır.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-277">The processing in this routine is application dependent.</span></span> <span data-ttu-id="7d4e9-278">Başarılı olursa, LevelX nve sürücüsü **LX_SUCCESS** döndürür.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-278">If it is successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="7d4e9-279">Bu başarılı olmazsa, LevelX nve sürücüsü **LX_ERROR** döndürür.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-279">If it is not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="7d4e9-280">LevelX nve sürücü "sistem hatası" hizmetinin prototipi:</span><span class="sxs-lookup"><span data-stu-id="7d4e9-280">The prototype of the LevelX NAND driver "system error" service is:</span></span>

```c
INT nand_driver_system_error(
    UINT error_code,  
    ULONG block, 
    ULONG page);
```

<span data-ttu-id="7d4e9-281">Burada *blok* hangi bloğun ve *sayfanın* *error_code* tarafından temsil edilen hatayı belirten sayfayı belirtir.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-281">Where *block* specifies which block, and *page* specifies the specific page the error represented by *error_code* occurred.</span></span>

## <a name="nand-simulated-driver"></a><span data-ttu-id="7d4e9-282">NVE sanal sürücü</span><span class="sxs-lookup"><span data-stu-id="7d4e9-282">NAND Simulated Driver</span></span>

<span data-ttu-id="7d4e9-283">LevelX, bir nve Flash bölümü işleminin benzetimini yapmak için yalnızca RAM kullanan bir benzetimli nve Flash sürücüsü sağlar.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-283">LevelX provides a simulated NAND flash driver that simply uses RAM to simulate the operation of a NAND flash part.</span></span> <span data-ttu-id="7d4e9-284">Varsayılan olarak, nve sanal sürücü, blok başına 16 sayfa ve sayfa başına 2048 bayt içeren 8 nve Flash blokları sağlar.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-284">By default, the NAND simulated driver provides 8 NAND flash blocks with 16 pages per block and 2048 bytes per page.</span></span>

<span data-ttu-id="7d4e9-285">Benzetimli nve Flash sürücü başlatma işlevi, \***lx_nand_flash_simulator_initialize** _ ve _ *_lx_nand_flash_simulator. c_* \* içinde tanımlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-285">The simulated NAND flash driver initialization function is ***lx_nand_flash_simulator_initialize** _ and is defined in _*_lx_nand_flash_simulator.c_\*\*.</span></span> <span data-ttu-id="7d4e9-286">Bu sürücü Ayrıca belirli nve Flash sürücülerini yazmak için iyi bir şablon sağlar.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-286">This driver also provides a good template for writing specific NAND flash drivers.</span></span>

## <a name="nand-filex-integration"></a><span data-ttu-id="7d4e9-287">NVE FileX tümleştirmesi</span><span class="sxs-lookup"><span data-stu-id="7d4e9-287">NAND FileX Integration</span></span>

<span data-ttu-id="7d4e9-288">Daha önce belirtildiği gibi, LevelX işlem için FileX 'i kullanmaz.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-288">As mentioned earlier, LevelX does not rely on FileX for operation.</span></span> <span data-ttu-id="7d4e9-289">Tüm LevelX API 'Leri, ham verileri, LevelX tarafından sunulan mantıksal sektörlerde depolamak/almak için doğrudan uygulama yazılımı tarafından çağrılabilir.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-289">All the LevelX APIs may be called directly by the application software to store/retrieve raw data to the logical sectors provided by LevelX.</span></span> <span data-ttu-id="7d4e9-290">Ancak, LevelX de Fılex 'i destekler.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-290">However, LevelX also supports FileX.</span></span>

<span data-ttu-id="7d4e9-291">***Fx_nand_flash_simulated_driver. c*** dosyası, nve flash simülasyonu ile kullanılmak üzere bir örnek FileX sürücüsü içerir.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-291">The file ***fx_nand_flash_simulated_driver.c*** contains an example FileX driver for use with the NAND flash simulation.</span></span> <span data-ttu-id="7d4e9-292">Bu sürücünün ilgi çekici bir yönü, genellikle FileX tarafından, 2048 baytlık sayfalar kullanılarak LevelX benzeticisinde tek mantıksal kesim okuma/yazma istekleri olarak kullanılan 512 baytlık mantıksal kesimleri birleştirmesidir.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-292">An interesting aspect of this driver is that it combines 512-byte logical sectors typically used by FileX into single logical sector read/write requests to the LevelX simulator using 2048-byte pages.</span></span> <span data-ttu-id="7d4e9-293">Bu, nve flash belleğin daha verimli bir şekilde kullanılmasına neden olur.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-293">This results in more efficient use of the NAND flash memory.</span></span> <span data-ttu-id="7d4e9-294">LevelX için nve Flash FileX sürücüsü, özel FileX sürücüleri yazmak için iyi bir başlangıç noktası sağlar.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-294">The NAND flash FileX driver for LevelX provides a good starting point for writing custom FileX drivers.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="7d4e9-295">FileX nve Flash biçimi, nve Flash tarafından sağlanan kesimlerin bir tam blok boyutu olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-295">The FileX NAND flash format should be one full block size of sectors less than the NAND flash provides.</span></span> <span data-ttu-id="7d4e9-296">Bu, aşınma düzeyi işleme sırasında en iyi performansı sağlamaya yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-296">This will help ensure best performance during the wear level processing.</span></span> <span data-ttu-id="7d4e9-297">LevelX aşmalar seviyelendirme algoritmasındaki yazma performansını artırmaya yönelik ek teknikler şunlardır.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-297">Additional techniques to improve write performance in the LevelX wear leveling algorithm include the following.</span></span>

1. <span data-ttu-id="7d4e9-298">Tüm yazmamaların tam olarak bir veya daha fazla küme olduğundan emin olun ve tam küme sınırları üzerinde başlatın.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-298">Ensure that all writes are exactly one or more clusters in size and start on exact cluster boundaries.</span></span>
1. <span data-ttu-id="7d4e9-299">API 'lerin FileX ***fx_file_allocate*** sınıfı aracılığıyla büyük dosya yazma işlemleri gerçekleştirmeden önce kümeleri önceden ayırın.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-299">Pre-allocate clusters before performing large file write operations via the FileX ***fx_file_allocate*** class of APIs.</span></span>
1. <span data-ttu-id="7d4e9-300">FileX sürücüsünün yayın sektörü bilgilerini alacak şekilde etkinleştirildiğinden emin olun ve sürücü sürüm sektörlerine yapılan istekler ***lx_nor_flash_sector_release*** çağırarak sürücüde işlenir.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-300">Ensure the FileX driver is enabled to receive release sector information and requests made to the driver to release sectors are handled in the driver by calling ***lx_nor_flash_sector_release***.</span></span>
1. <span data-ttu-id="7d4e9-301">Olabildiğince çok nve blok açmak için ***lx_nand_flash_defragment*** düzenli olarak kullanımı ve bu sayede yazma performansını artırma.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-301">Periodic use of ***lx_nand_flash_defragment*** to free up as many NAND blocks as possible and thus improve write performance.</span></span>
1. <span data-ttu-id="7d4e9-302">Daha hızlı performans sağlamak için ***lx_nand_flash_extended_cache_enable*** API 'sini, ÇEŞITLI nve kaynak blok kaynakları IÇIN bir RAM önbelleği sağlamak üzere kullanın.</span><span class="sxs-lookup"><span data-stu-id="7d4e9-302">Utilize the ***lx_nand_flash_extended_cache_enable*** API to provide a RAM cache of various NAND block resources for faster performance.</span></span>
