---
title: Bölüm 3-Azure RTOS NetX güvenliği için Işlevsel açıklama
description: Bu bölüm, NetX güvenli TLS 'nin işlevsel bir açıklamasını içerir.
author: philmea
ms.author: philmea
ms.date: 06/04/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: c28ad0255f99986a4ddfe5faefad81e70840e5e0
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/22/2021
ms.locfileid: "104825685"
---
# <a name="chapter-3---functional-description-of-azure-rtos-netx-secure"></a><span data-ttu-id="5a587-103">Bölüm 3-Azure RTOS NetX güvenliği için Işlevsel açıklama</span><span class="sxs-lookup"><span data-stu-id="5a587-103">Chapter 3 - Functional description of Azure RTOS NetX Secure</span></span>

## <a name="execution-overview"></a><span data-ttu-id="5a587-104">Yürütmeye genel bakış</span><span class="sxs-lookup"><span data-stu-id="5a587-104">Execution Overview</span></span>

<span data-ttu-id="5a587-105">Bu bölümde, Azure RTOS NetX güvenli TLS 'nin işlevsel bir açıklaması bulunmaktadır.</span><span class="sxs-lookup"><span data-stu-id="5a587-105">This chapter contains a functional description of Azure RTOS NetX Secure TLS.</span></span> <span data-ttu-id="5a587-106">NetX güvenli TLS uygulamasında iki birincil program yürütme türü vardır: başlatma ve uygulama arabirimi çağrıları.</span><span class="sxs-lookup"><span data-stu-id="5a587-106">There are two primary types of program execution in a NetX Secure TLS application: initialization and application interface calls.</span></span> 

<span data-ttu-id="5a587-107">*NetX güvenli, ThreadX ve NetX/NetXDuo 'un varlığını varsayar. ThreadX ' ten, iş parçacığı yürütme, askıya alma, dönemsel zamanlayıcılar ve karşılıklı dışlama olanakları gerekir. NetX/NetXDuo 'ten TCP/IP ağ tesislerini ve sürücülerini gerektirir.*</span><span class="sxs-lookup"><span data-stu-id="5a587-107">*NetX Secure assumes the existence of ThreadX and NetX/NetXDuo. From ThreadX, it requires thread execution, suspension, periodic timers, and mutual exclusion facilities. From NetX/NetXDuo it requires the TCP/IP networking facilities and drivers.*</span></span>

## <a name="transport-layer-security-tls-and-secure-sockets-layer-ssl"></a><span data-ttu-id="5a587-108">Aktarım Katmanı Güvenliği (TLS) ve Güvenli Yuva Katmanı (SSL)</span><span class="sxs-lookup"><span data-stu-id="5a587-108">Transport Layer Security (TLS) and Secure Sockets Layer (SSL)</span></span>

<span data-ttu-id="5a587-109">NetX güvenli ağ protokolü bileşeni, RFC 2246 (sürüm 1,0), 4346 (sürüm 1,1), 5246 (sürüm 1,2) ve 8446 (sürüm 1,3) bölümünde açıklandığı gibi Aktarım Katmanı Güvenliği (TLS) protokolünün bir uygulamasıdır.</span><span class="sxs-lookup"><span data-stu-id="5a587-109">The secure network protocol component of NetX secure is an implementation of the Transport Layer Security (TLS) protocol as described in RFCs 2246 (version 1.0), 4346 (version 1.1), 5246 (version 1.2) and 8446 (version 1.3).</span></span> <span data-ttu-id="5a587-110">Ayrıca temel X. 509.440 (RFC 5280) için destek yordamları da mevcuttur.</span><span class="sxs-lookup"><span data-stu-id="5a587-110">Also included are support routines for basic X.509 (RFC 5280).</span></span>

<span data-ttu-id="5a587-111">NetX güvenli TLS, 1,2 ve 1,3 TLS sürümlerini destekler.</span><span class="sxs-lookup"><span data-stu-id="5a587-111">NetX Secure TLS supports TLS versions 1.2 and 1.3.</span></span> <span data-ttu-id="5a587-112">Uygulamalar, şimdi kullanımdan kaldırılan TLS 1,0 ve TLS 1,1 için sağlanır, ancak açık bir şekilde başlatılmalı ve yeni ürünlerde kullanılması önerilmez.</span><span class="sxs-lookup"><span data-stu-id="5a587-112">Implementations are provided for the now-deprecated TLS 1.0 and TLS 1.1, but they must be explicitly initialized and are not recommended for use in new products.</span></span>

<span data-ttu-id="5a587-113">*Güvenli Yuva Katmanı* (SSL), RFC 2246 ' de standart hale gelmeden önce TLS adının özgün adı ve "SSL" genellikle TLS protokolleri için genel bir ad olarak kullanılır.</span><span class="sxs-lookup"><span data-stu-id="5a587-113">*Secure Sockets Layer* (SSL) was the original name of TLS before it became a standard in RFC 2246 and "SSL" is often used as a generic name for the TLS protocols.</span></span> <span data-ttu-id="5a587-114">SSL 'nin son sürümü 3,0 idi ve TLS 1,0 bazen SSL sürüm 3,1 olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="5a587-114">The last version of SSL was 3.0, and TLS 1.0 is sometimes referred to as SSL version 3.1.</span></span> <span data-ttu-id="5a587-115">Resmi "SSL" protokolünün tüm sürümleri artık kullanılmıyor ve güvenli olmayan olarak kabul edilir ve şu anda NetX güvenli bir SSL uygulamasını sağlamıyor.</span><span class="sxs-lookup"><span data-stu-id="5a587-115">All versions of the official "SSL" protocol are considered obsolete and insecure and currently NetX Secure does not provide an SSL implementation.</span></span>

<span data-ttu-id="5a587-116">TLS, TLS istemcisi ile sunucu arasındaki TLS *el sıkışması* sırasında oluşturulan *oturum anahtarları* oluşturmak için bir protokol BELIRTIR ve bu anahtarlar TLS oturumu sırasında uygulama tarafından gönderilen verileri şifrelemek için kullanılır *.*</span><span class="sxs-lookup"><span data-stu-id="5a587-116">TLS specifies a protocol to generate *session keys* which are created during the TLS *handshake* between a TLS client and server and those keys are used to encrypt data sent by the application during the TLS *session.*</span></span>

<span data-ttu-id="5a587-117">TLS verileri, bir TCP paketine yönelik kavramla eşdeğer olan *kayıtlara* ayrılmıştır.</span><span class="sxs-lookup"><span data-stu-id="5a587-117">TLS data is divided into *records* which are equivalent in concept to a TCP packet.</span></span> <span data-ttu-id="5a587-118">Her TLS kaydı bir üst bilgiye sahiptir ve TLS şifreli kayıtlarının de bir altbilgisi vardır (sağlama toplamı karması).</span><span class="sxs-lookup"><span data-stu-id="5a587-118">Every TLS record has a header, and TLS encrypted records also have a footer (checksum hash).</span></span> <span data-ttu-id="5a587-119">TLS el sıkışma kayıtları, daha büyük TLS kaydı içinde kapsüllenmiş ek bir üstbilgiye sahiptir.</span><span class="sxs-lookup"><span data-stu-id="5a587-119">TLS handshake records have an additional header encapsulated within the larger TLS record.</span></span> <span data-ttu-id="5a587-120">TLS kaydı, aktarım katmanı ağ protokolü tarafından bir TCP paketinin bir IP paketiyle kapsüllendiği şekilde kapsüllenir.</span><span class="sxs-lookup"><span data-stu-id="5a587-120">The TLS record is encapsulated by the  transport layer network protocol in the same manner that a TCP packet is encapsulated by an IP packet.</span></span>

### <a name="tls-13"></a><span data-ttu-id="5a587-121">TLS 1,3</span><span class="sxs-lookup"><span data-stu-id="5a587-121">TLS 1.3</span></span>

<span data-ttu-id="5a587-122">Ağustos 2018 ' de, TLS 1,3 belirtimi sonlandırılmıştı.</span><span class="sxs-lookup"><span data-stu-id="5a587-122">In August 2018, the TLS 1.3 specification was finalized.</span></span> <span data-ttu-id="5a587-123">Protokolün yeni sürümü, TLS 'nin temel güvenlik ve performansının bazı temel yönlerini değiştiren oldukça önemli bir güncelleştirmedir.</span><span class="sxs-lookup"><span data-stu-id="5a587-123">The new version of the protocol is a fairly significant update that changes some fundamental aspects of the underlying security and performance of TLS.</span></span> <span data-ttu-id="5a587-124">Ancak, bu değişiklikler genellikle TLS el sıkışma durum makinesine ve oturum anahtarı oluşturmaya uygulandıklarından tipik TLS kullanıcısına büyük ölçüde görünmez.</span><span class="sxs-lookup"><span data-stu-id="5a587-124">However, these changes are largely invisible to the typical TLS user since they apply primarily to the TLS handshake state machine and session key generation.</span></span> <span data-ttu-id="5a587-125">Birçok isteğe bağlı özellik ve uzantı de eklenmiştir.</span><span class="sxs-lookup"><span data-stu-id="5a587-125">A number of optional features and extensions were added as well.</span></span> <span data-ttu-id="5a587-126">Aşağıda, değişikliklerin bir özeti ve TLS işlevlerini nasıl etkilediği gösterilmiştir.</span><span class="sxs-lookup"><span data-stu-id="5a587-126">The following is a summary of the changes and how they impact TLS functionality.</span></span>

- <span data-ttu-id="5a587-127">El Sıkışma durumu makinesi, tüm ileti değişimini sunucu tarafından kaldırarak iyileştirildi.</span><span class="sxs-lookup"><span data-stu-id="5a587-127">The handshake state machine was optimized by removing an entire exchange of messages by the server.</span></span>
- <span data-ttu-id="5a587-128">Anahtar oluşturma, HKDF (HMAC tabanlı anahtar türetme Işlevi) adlı standartlaştırılmış bir yordamı kullanacak şekilde güncelleştirildi ve oturum anahtarlarını tüm el sıkışma iletilerine (birkaç Select parametresi yerine) bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="5a587-128">Key generation was updated to use a standardized routine called HKDF (HMAC-based Key Derivation Function) and ties the session keys to all of the handshake messages (instead of a few select parameters).</span></span>
- <span data-ttu-id="5a587-129">Tüm TLS 1,2 ve önceki ciphersuites kullanım dışıdır ve TLS 1,3 ile uyumsuzdur.</span><span class="sxs-lookup"><span data-stu-id="5a587-129">All TLS 1.2 and earlier ciphersuites are deprecated and are incompatible with TLS 1.3.</span></span> <span data-ttu-id="5a587-130">Benzer şekilde, tüm TLS 1,3 ciphersuites, önceki sürümlerle kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="5a587-130">Similarly, all TLS 1.3 ciphersuites are unusable with previous versions.</span></span>
- <span data-ttu-id="5a587-131">Tüm TLS 1,3 ciphersuites, kısa ömürlü anahtarlar kullanarak kusursuz Iletme gizliliği (PFS) sağlar<sup>6</sup></span><span class="sxs-lookup"><span data-stu-id="5a587-131">All TLS 1.3 ciphersuites provide Perfect Forward Secrecy (PFS) using ephemeral keys<sup>6</sup></span></span> 
- <span data-ttu-id="5a587-132">TLS 1,3, AEAD<sup>7</sup> şifrelemeleri kullanarak her bir kayıttaki "ileti kimlik doğrulama kodunu" (Mac) kaldırır</span><span class="sxs-lookup"><span data-stu-id="5a587-132">TLS 1.3 removes the "message authentication code" (MAC) in each record in favor of using AEAD<sup>7</sup> ciphers</span></span>
- <span data-ttu-id="5a587-133">Uygulama verilerinin el sıkışma sırasında gönderilmesini sağlayan 0-RTT (sıfır gidiş dönüş süresi) dahil olmak üzere bazı ek isteğe bağlı özellikler eklenmiştir.</span><span class="sxs-lookup"><span data-stu-id="5a587-133">Some additional optional features were added, including 0-RTT (Zero Round Trip Time) which allows for application data to be sent during the handshake.</span></span> <span data-ttu-id="5a587-134">0-RTT yalnızca isteğe bağlıdır ve Azure RTOS TLS 'de Şu anda desteklenmemektedir.</span><span class="sxs-lookup"><span data-stu-id="5a587-134">0-RTT is purely optional and is not currently supported in Azure RTOS TLS.</span></span>

<span data-ttu-id="5a587-135">TLS 1,3, Kullanıcı uygulamalarını önemli ölçüde etkilemez.</span><span class="sxs-lookup"><span data-stu-id="5a587-135">TLS 1.3 does not significantly affect user applications.</span></span> <span data-ttu-id="5a587-136">API, sürümler arasında tam olarak aynı kalır ve ciphersuites, tek bir ciphersuite tablosu kullanılabilir olacak şekilde işaretlenir.</span><span class="sxs-lookup"><span data-stu-id="5a587-136">The API remains exactly the same between versions, and ciphersuites are marked so a single ciphersuite table may be used.</span></span>

<span data-ttu-id="5a587-137">TLS 1,3 kullanmak için makro NX_SECURE_TLS_ENABLE_TLS_1_3 genel olarak tanımlanmış olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="5a587-137">In order to use TLS 1.3, the macro NX_SECURE_TLS_ENABLE_TLS_1_3 must be globally defined.</span></span> <span data-ttu-id="5a587-138">TLS 1,3, Azure RTOS TLS 'de varsayılan olarak devre dışıdır.</span><span class="sxs-lookup"><span data-stu-id="5a587-138">TLS 1.3 is disabled by default in Azure RTOS TLS.</span></span>

6. <span data-ttu-id="5a587-139">"Kısa ömürlü" anahtarlar, TLS el sıkışması sırasında oluşturulan ve yalnızca bu oturum için gizli dizi değişim için kullanılan asimetrik anahtar çiftleridir.</span><span class="sxs-lookup"><span data-stu-id="5a587-139">“Ephemeral” keys are asymmetric key pairs that are generated during the TLS handshake and used for the secrets exchange for only that session.</span></span> <span data-ttu-id="5a587-140">Bu anahtar çifti kullanıldıktan sonra atılır. Bu, bir saldırganın, bir sertifika özel anahtarı ileride, "kusursuz Iletme gizliliği" ile aynı anda tehlikede olsa, kayıtlı bir TLS oturumunda şifrelenmiş verilere erişmesini önler.</span><span class="sxs-lookup"><span data-stu-id="5a587-140">They key pair is discarded after use – this prevents an attacker from being able to access encrypted data in a recorded TLS session even if a certificate private key is compromised at any time in the future – hence “Perfect Forward Secrecy”.</span></span>

7. <span data-ttu-id="5a587-141">Ilişkili verilerle kimliği doğrulanmış şifreleme – tek bir işlemde şifreleme ve bütünlük denetimini birleştiren AES gibi şifrelemeler için bir mod; bütünlük denetimi için verilerin ayrı bir karması gereksinimini ortadan kaldırır.</span><span class="sxs-lookup"><span data-stu-id="5a587-141">Authenticated Encryption with Associated Data – a mode for ciphers like AES that combines encryption and integrity checking in a single operation, eliminating the need for a separate hash of the data for integrity checking.</span></span>

### <a name="tls-record-header"></a><span data-ttu-id="5a587-142">TLS kayıt üstbilgisi</span><span class="sxs-lookup"><span data-stu-id="5a587-142">TLS Record header</span></span>

<span data-ttu-id="5a587-143">Geçerli bir TLS kaydı, hata bölümünde gösterildiği gibi bir TLS başlığına sahip olmalıdır!</span><span class="sxs-lookup"><span data-stu-id="5a587-143">Any valid TLS record must have a TLS header, as shown in Error!</span></span> <span data-ttu-id="5a587-144">Başvuru kaynağı bulunamadı.</span><span class="sxs-lookup"><span data-stu-id="5a587-144">Reference source not found.</span></span>

![Bir TLS kayıt üstbilgisinin diyagramı.](media/image2.png)

<span data-ttu-id="5a587-146">Şekil 1-TLS kayıt üstbilgisi</span><span class="sxs-lookup"><span data-stu-id="5a587-146">Figure 1 - TLS record header</span></span>

<span data-ttu-id="5a587-147">TLS kayıt üstbilgisinin alanları aşağıdaki gibi tanımlanır:</span><span class="sxs-lookup"><span data-stu-id="5a587-147">The fields of the TLS record header are defined as follows:</span></span>

| <span data-ttu-id="5a587-148">TLS üst bilgi alanı</span><span class="sxs-lookup"><span data-stu-id="5a587-148">TLS Header Field</span></span> | <span data-ttu-id="5a587-149">Amaç</span><span class="sxs-lookup"><span data-stu-id="5a587-149">Purpose</span></span>     |
| ---------------- | ------------- |
| <span data-ttu-id="5a587-150">**8 bit Ileti türü**</span><span class="sxs-lookup"><span data-stu-id="5a587-150">**8-bit Message Type**</span></span> | <span data-ttu-id="5a587-151">Bu alan, gönderilmekte olan TLS kaydının türünü içerir.</span><span class="sxs-lookup"><span data-stu-id="5a587-151">This field contains the type of TLS record being sent.</span></span> <span data-ttu-id="5a587-152">Geçerli türler şunlardır:</span><span class="sxs-lookup"><span data-stu-id="5a587-152">Valid types are as follows:</span></span><br /><span data-ttu-id="5a587-153">-Changecçözülemez spec<sup>8</sup>: 0x14</span><span class="sxs-lookup"><span data-stu-id="5a587-153">- ChangeCipherSpec<sup>8</sup>: 0x14</span></span><br /><span data-ttu-id="5a587-154">-Uyarı: 0x15</span><span class="sxs-lookup"><span data-stu-id="5a587-154">- Alert: 0x15</span></span><br /><span data-ttu-id="5a587-155">-Handshake: 0x16</span><span class="sxs-lookup"><span data-stu-id="5a587-155">- Handshake: 0x16</span></span><br /><span data-ttu-id="5a587-156">-Uygulama verileri: 0x17</span><span class="sxs-lookup"><span data-stu-id="5a587-156">- Application Data: 0x17</span></span> |
| <span data-ttu-id="5a587-157">**16 bit protokol sürümü**</span><span class="sxs-lookup"><span data-stu-id="5a587-157">**16-bit Protocol Version**</span></span> | <span data-ttu-id="5a587-158">Bu alan TLS protokol sürümünü içerir.</span><span class="sxs-lookup"><span data-stu-id="5a587-158">This field contains the TLS protocol version.</span></span> <span data-ttu-id="5a587-159">Geçerli değerler aşağıdaki gibidir:</span><span class="sxs-lookup"><span data-stu-id="5a587-159">Valid values are as follows:</span></span><br /><span data-ttu-id="5a587-160">-SSL 3,0:0x0300</span><span class="sxs-lookup"><span data-stu-id="5a587-160">- SSL 3.0: 0x0300</span></span><br /><span data-ttu-id="5a587-161">-TLS 1,0:0x0301</span><span class="sxs-lookup"><span data-stu-id="5a587-161">- TLS 1.0: 0x0301</span></span><br /><span data-ttu-id="5a587-162">-TLS 1,1:0x0302</span><span class="sxs-lookup"><span data-stu-id="5a587-162">- TLS 1.1: 0x0302</span></span><br /><span data-ttu-id="5a587-163">-TLS 1,2:0x0303</span><span class="sxs-lookup"><span data-stu-id="5a587-163">- TLS 1.2: 0x0303</span></span><br /><span data-ttu-id="5a587-164">- **TLS 1,3 <sup>9</sup>**: **0x0303**</span><span class="sxs-lookup"><span data-stu-id="5a587-164">- **TLS 1.3 <sup>9</sup>**: **0x0303**</span></span> |
| <span data-ttu-id="5a587-165">**16 bit uzunluğu**</span><span class="sxs-lookup"><span data-stu-id="5a587-165">**16-bit Length**</span></span> | <span data-ttu-id="5a587-166">Bu alan, TLS kaydında Kapsüllenen verilerin uzunluğunu içerir.</span><span class="sxs-lookup"><span data-stu-id="5a587-166">This field contains the length of the data encapsulated in the TLS record.</span></span> |

8. <span data-ttu-id="5a587-167">TLS 1,3 ' de Changeclerspec iletisi artık kullanılmamaktadır, ancak yine de ileti yok sayılır, bu durumda uyumluluk nedenleriyle gönderilebilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-167">In TLS 1.3 the ChangeCipherSpec message is no longer used, though it still may be sent for compatibility reasons in which case the message is ignored.</span></span>

9. <span data-ttu-id="5a587-168">TLS 1,3, bu düzen devam ettirmeye devam etseydi, ancak protokol bir uzantıdaki gerçek protokol sürümüne sahip olacak şekilde değiştirildiyse, TLS 1,3 kayıtları geriye dönük uyumluluk için protokol sürümü alanlarında 0x0303 kullanır.</span><span class="sxs-lookup"><span data-stu-id="5a587-168">TLS 1.3 would technically have a value of 0x0304 if this scheme was continued, but the protocol was changed to have the actual protocol version in an extension, so all TLS 1.3 records use 0x0303 in protocol version fields for backward-compatibility.</span></span>

### <a name="tls-handshake-record-header"></a><span data-ttu-id="5a587-169">TLS el sıkışma kayıt üstbilgisi</span><span class="sxs-lookup"><span data-stu-id="5a587-169">TLS Handshake Record header</span></span>

<span data-ttu-id="5a587-170">Geçerli bir TLS el sıkışma kaydı, Şekil 2 ' de gösterildiği gibi bir TLS Handshake üst bilgisine sahip olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="5a587-170">Any valid TLS handshake record must have a TLS Handshake header, as shown in Figure 2.</span></span>

![TLS el sıkışma kayıt üstbilgisinin diyagramı.](media/image3.png)

<span data-ttu-id="5a587-172">Şekil 2-TLS el sıkışma kayıt üstbilgisi</span><span class="sxs-lookup"><span data-stu-id="5a587-172">Figure 2 - TLS Handshake record header</span></span>

<span data-ttu-id="5a587-173">TLS el sıkışma kayıt üstbilgisinin alanları aşağıdaki gibi tanımlanır:</span><span class="sxs-lookup"><span data-stu-id="5a587-173">The fields of the TLS Handshake record header are defined as follows:</span></span>

| <span data-ttu-id="5a587-174">TLS üst bilgi alanı</span><span class="sxs-lookup"><span data-stu-id="5a587-174">TLS Header Field</span></span> | <span data-ttu-id="5a587-175">Amaç</span><span class="sxs-lookup"><span data-stu-id="5a587-175">Purpose</span></span> |
| ---------------- |----------------------- |
| <span data-ttu-id="5a587-176">**8 bit Ileti türü**</span><span class="sxs-lookup"><span data-stu-id="5a587-176">**8-bit Message Type**</span></span> | <span data-ttu-id="5a587-177">Bu alan, gönderilmekte olan TLS kaydının türünü içerir.</span><span class="sxs-lookup"><span data-stu-id="5a587-177">This field contains the type of TLS record being sent.</span></span> <span data-ttu-id="5a587-178">Geçerli türler şunlardır:</span><span class="sxs-lookup"><span data-stu-id="5a587-178">Valid types are as follows:</span></span><br /><span data-ttu-id="5a587-179">-Changecçözülemez spec<sup>10</sup>: 0x14</span><span class="sxs-lookup"><span data-stu-id="5a587-179">- ChangeCipherSpec<sup>10</sup>: 0x14</span></span><br /><span data-ttu-id="5a587-180">-Uyarı: 0x15</span><span class="sxs-lookup"><span data-stu-id="5a587-180">- Alert: 0x15</span></span><br /><span data-ttu-id="5a587-181">-Handshake: 0x16</span><span class="sxs-lookup"><span data-stu-id="5a587-181">- Handshake: 0x16</span></span><br /><span data-ttu-id="5a587-182">-Uygulama verileri: 0x17</span><span class="sxs-lookup"><span data-stu-id="5a587-182">- Application Data: 0x17</span></span> |
| <span data-ttu-id="5a587-183">**16 bit protokol sürümü**</span><span class="sxs-lookup"><span data-stu-id="5a587-183">**16-bit Protocol Version**</span></span> | <span data-ttu-id="5a587-184">Bu alan TLS protokol sürümünü içerir.</span><span class="sxs-lookup"><span data-stu-id="5a587-184">This field contains the TLS protocol version.</span></span> <span data-ttu-id="5a587-185">Geçerli değerler aşağıdaki gibidir:</span><span class="sxs-lookup"><span data-stu-id="5a587-185">Valid values are as follows:</span></span><br /><span data-ttu-id="5a587-186">-SSL 3,0:0x0300</span><span class="sxs-lookup"><span data-stu-id="5a587-186">- SSL 3.0: 0x0300</span></span><br /><span data-ttu-id="5a587-187">-TLS 1,0:0x0301</span><span class="sxs-lookup"><span data-stu-id="5a587-187">- TLS 1.0: 0x0301</span></span><br /><span data-ttu-id="5a587-188">-TLS 1,1:0x0302</span><span class="sxs-lookup"><span data-stu-id="5a587-188">- TLS 1.1: 0x0302</span></span><br /><span data-ttu-id="5a587-189">-TLS 1,2:0x0303</span><span class="sxs-lookup"><span data-stu-id="5a587-189">- TLS 1.2: 0x0303</span></span><br /><span data-ttu-id="5a587-190">- **TLS 1,3 <sup>11</sup>**: **0x0303**</span><span class="sxs-lookup"><span data-stu-id="5a587-190">- **TLS 1.3 <sup>11</sup>**: **0x0303**</span></span> |
| <span data-ttu-id="5a587-191">**16 bit uzunluğu**</span><span class="sxs-lookup"><span data-stu-id="5a587-191">**16-bit Length**</span></span>    | <span data-ttu-id="5a587-192">Bu alan, TLS kaydında Kapsüllenen verilerin uzunluğunu içerir.</span><span class="sxs-lookup"><span data-stu-id="5a587-192">This field contains the length of the data encapsulated in the TLS record.</span></span> |
| <span data-ttu-id="5a587-193">**8 bit el sıkışma türü**</span><span class="sxs-lookup"><span data-stu-id="5a587-193">**8-bit Handshake Type**</span></span> | <span data-ttu-id="5a587-194">Bu alan, el sıkışma ileti türünü içerir.</span><span class="sxs-lookup"><span data-stu-id="5a587-194">This field contains the handshake message type.</span></span> <span data-ttu-id="5a587-195">Geçerli değerler aşağıdaki gibidir (\*, 1,3 ile **yazılan** iletiler TLS ' ye eklenmiştir):</span><span class="sxs-lookup"><span data-stu-id="5a587-195">Valid values are as follows (\*messages in **bold** were added in TLS 1.3):</span></span><br /><span data-ttu-id="5a587-196">-Merhaba Istek: 0x00</span><span class="sxs-lookup"><span data-stu-id="5a587-196">- HelloRequest: 0x00</span></span><br /><span data-ttu-id="5a587-197">-ClientHello: 0x01</span><span class="sxs-lookup"><span data-stu-id="5a587-197">- ClientHello: 0x01</span></span><br /><span data-ttu-id="5a587-198">-ServerHello: 0x02</span><span class="sxs-lookup"><span data-stu-id="5a587-198">- ServerHello: 0x02</span></span><br /><span data-ttu-id="5a587-199">- **Helloverifyrequest**: **0x03**</span><span class="sxs-lookup"><span data-stu-id="5a587-199">- **HelloVerifyRequest**: **0x03**</span></span><br /><span data-ttu-id="5a587-200">- **Newsessionbilet**: **0x04**</span><span class="sxs-lookup"><span data-stu-id="5a587-200">- **NewSessionTicket**: **0x04**</span></span><br /><span data-ttu-id="5a587-201">- **Endoyuma verileri**: **0x05**</span><span class="sxs-lookup"><span data-stu-id="5a587-201">- **EndOfEarlyData**: **0x05**</span></span><br /><span data-ttu-id="5a587-202">- **EncryptedExtensions**: **0x08**</span><span class="sxs-lookup"><span data-stu-id="5a587-202">- **EncryptedExtensions**: **0x08**</span></span><br /><span data-ttu-id="5a587-203">-Sertifika: 0x0B</span><span class="sxs-lookup"><span data-stu-id="5a587-203">- Certificate: 0x0B</span></span><br /><span data-ttu-id="5a587-204">-ServerKeyExchange: 0x0C</span><span class="sxs-lookup"><span data-stu-id="5a587-204">- ServerKeyExchange: 0x0C</span></span><br /><span data-ttu-id="5a587-205">-CertificateRequest: 0x0D</span><span class="sxs-lookup"><span data-stu-id="5a587-205">- CertificateRequest: 0x0D</span></span><br /><span data-ttu-id="5a587-206">-ServerHelloDone: 0x0E</span><span class="sxs-lookup"><span data-stu-id="5a587-206">- ServerHelloDone: 0x0E</span></span><br /><span data-ttu-id="5a587-207">-CertificateVerify: 0x0F</span><span class="sxs-lookup"><span data-stu-id="5a587-207">- CertificateVerify: 0x0F</span></span><br /><span data-ttu-id="5a587-208">-ClientKeyExchange: 0x10</span><span class="sxs-lookup"><span data-stu-id="5a587-208">- ClientKeyExchange: 0x10</span></span><br /><span data-ttu-id="5a587-209">-Tamamlandı: 0x14</span><span class="sxs-lookup"><span data-stu-id="5a587-209">- Finished: 0x14</span></span><br /><span data-ttu-id="5a587-210">- **KeyUpdate**: **0x18**</span><span class="sxs-lookup"><span data-stu-id="5a587-210">- **KeyUpdate**: **0x18**</span></span><br /><span data-ttu-id="5a587-211">- **Messagehash**: **0xFE**</span><span class="sxs-lookup"><span data-stu-id="5a587-211">- **MessageHash**: **0xFE**</span></span> |
| <span data-ttu-id="5a587-212">**24 bit uzunluğu**</span><span class="sxs-lookup"><span data-stu-id="5a587-212">**24-bit Length**</span></span>    | <span data-ttu-id="5a587-213">Bu alan, el sıkışma ileti verilerinin uzunluğunu içerir.</span><span class="sxs-lookup"><span data-stu-id="5a587-213">This field contains the length of the handshake message data.</span></span> |

10. <span data-ttu-id="5a587-214">TLS 1,3 ' de Changeclerspec iletisi artık kullanılmamaktadır, ancak yine de ileti yok sayılır, bu durumda uyumluluk nedenleriyle gönderilebilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-214">In TLS 1.3 the ChangeCipherSpec message is no longer used, though it still may be sent for compatibility reasons in which case the message is ignored.</span></span>

11. <span data-ttu-id="5a587-215">TLS 1,3, bu düzen devam ettirmeye devam etseydi, ancak protokol bir uzantıdaki gerçek protokol sürümüne sahip olacak şekilde değiştirildiyse, TLS 1,3 kayıtları geriye dönük uyumluluk için protokol sürümü alanlarında 0x0303 kullanır.</span><span class="sxs-lookup"><span data-stu-id="5a587-215">TLS 1.3 would technically have a value of 0x0304 if this scheme was continued, but the protocol was changed to have the actual protocol version in an extension, so all TLS 1.3 records use 0x0303 in protocol version fields for backward-compatibility.</span></span>

### <a name="the-tls-handshake-and-tls-session"></a><span data-ttu-id="5a587-216">TLS el sıkışma ve TLS oturumu</span><span class="sxs-lookup"><span data-stu-id="5a587-216">The TLS Handshake and TLS Session</span></span>

<span data-ttu-id="5a587-217">Şekil 3 ' te tipik bir TLS anlaşması (sürüm 1.0-1.2) gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="5a587-217">A typical TLS handshake (versions 1.0-1.2) is shown in Figure 3.</span></span> <span data-ttu-id="5a587-218">TLS Istemcisi bir TLS sunucusuna bir *ClientHello* iletisi gönderdiğinde TLS el sıkışması başlar ve bunu bir TLS oturumu başlatmak zorunda olduğunu gösterir.</span><span class="sxs-lookup"><span data-stu-id="5a587-218">A TLS handshake begins when the TLS Client sends a *ClientHello* message to a TLS server, indicating its desire to start a TLS session.</span></span> <span data-ttu-id="5a587-219">İleti, istemci oturum için kullanmak istediğiniz şifreleme hakkında bilgiler içerir ve bu da oturum anahtarlarını daha sonra el ile oluşturmak için kullanılan bilgilerle birlikte.</span><span class="sxs-lookup"><span data-stu-id="5a587-219">The message contains information about the encryption the client would like to use for the session, along with information used to generate the session keys later in the handshake.</span></span> <span data-ttu-id="5a587-220">Oturum anahtarları üretilene kadar, TLS el sıkışmasındaki tüm iletiler şifrelenmez.</span><span class="sxs-lookup"><span data-stu-id="5a587-220">Until the session keys are generated, all messages in the TLS handshake are not encrypted.</span></span> <span data-ttu-id="5a587-221">TLS 1,3 el sıkışmasını değiştirir. Ayrıntılar sonraki bölümde sunulmaktadır.</span><span class="sxs-lookup"><span data-stu-id="5a587-221">TLS 1.3 changes the handshake somewhat – details are presented in the next section.</span></span>

<span data-ttu-id="5a587-222">TLS sunucusu, istemci tarafından sunulan şifreleme seçeneklerinden seçim gösteren bir ServerHello iletisi ile ClientHello 'e yanıt verir.</span><span class="sxs-lookup"><span data-stu-id="5a587-222">The TLS Server responds to the ClientHello with a ServerHello message, indicating a selection from the encryption options provided by the client.</span></span> <span data-ttu-id="5a587-223">ServerHello, sunucunun kimliğini istemciye kimliğini doğrulamak için dijital bir sertifika sağladığı bir sertifika iletisi tarafından izlenir.</span><span class="sxs-lookup"><span data-stu-id="5a587-223">The ServerHello is followed by a Certificate message, in which the server provides a digital certificate to authenticate its identity to the client.</span></span> <span data-ttu-id="5a587-224">Son olarak, sunucu gönderilecek daha fazla ileti olmadığını göstermek için bir ServerHelloDone iletisi gönderir.</span><span class="sxs-lookup"><span data-stu-id="5a587-224">Finally, the server sends a ServerHelloDone message to indicate it has no more messages to send.</span></span> <span data-ttu-id="5a587-225">Sunucu isteğe bağlı olarak Sunucushello 'yu izleyen diğer iletileri gönderebilir ve bazı durumlarda bir sertifika iletisi gönderemeyebilir ve bu nedenle ServerHelloDone iletisine gerek kalmaz.</span><span class="sxs-lookup"><span data-stu-id="5a587-225">The server may optionally send other messages following the ServerHello and in some cases it may not send a Certificate message, hence the need for the ServerHelloDone message.</span></span>

<span data-ttu-id="5a587-226">İstemci tüm sunucu iletilerini aldıktan sonra, oturum anahtarlarını oluşturmak için yeterli bilgiye sahip olur.</span><span class="sxs-lookup"><span data-stu-id="5a587-226">Once the client has received all the server's messages, it has enough information to generate the session keys.</span></span> <span data-ttu-id="5a587-227">Bu, sabit boyutlu olan ve şifreli olmayan *gizli* anahtar olarak adlandırılan ve şifreleme etkinleştirildikten sonra gereken tüm anahtarları oluşturmak için çekirdek olarak kullanılan, paylaşılan bir rastgele veri adı oluşturarak bunu yapar.</span><span class="sxs-lookup"><span data-stu-id="5a587-227">TLS does this by creating a shared bit of random data called the *Pre-Master Secret*, which is a fixed-size and is used as a seed to generate all the keys needed once encryption is enabled.</span></span> <span data-ttu-id="5a587-228">Asıl ön gizlilik, Merhaba iletilerde belirtilen ortak anahtar algoritması (ör. RSA) kullanılarak şifrelenir (ortak anahtar algoritmaları hakkında bilgi için aşağıya bakın) ve sertifikasında sunucu tarafından sağlanmış ortak anahtar.</span><span class="sxs-lookup"><span data-stu-id="5a587-228">The Pre-Master Secret is encrypted using the public key algorithm (e.g. RSA) specified in the Hello messages (see below for information on public key algorithms) and the public key provided by the server in its certificate.</span></span> <span data-ttu-id="5a587-229">Önceden paylaşılan anahtarlar (PSK) adlı isteğe bağlı bir TLS özelliği, bir sertifika kullanmayan cipherpaketlerine izin verebilir, bunun yerine ana bilgisayarlar arasında paylaşılan bir gizli değer (genellikle fiziksel aktarım veya diğer güvenli yöntem aracılığıyla) kullanır.</span><span class="sxs-lookup"><span data-stu-id="5a587-229">An optional TLS feature called Pre-Shared Keys (PSK) enables ciphersuites that do not use a certificate but instead use a secret value shared between the hosts (usually through physical transfer or other secured method).</span></span> <span data-ttu-id="5a587-230">Paylaşılan gizlilik, ana ön gizliliği göndermek için şifrelenmiş bir ileti kullanmak yerine, önceden ana gizli dizi oluşturmak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="5a587-230">The shared secret is used to generate the Pre-Master Secret instead of using an encrypted message to send the Pre-Master Secret.</span></span> <span data-ttu-id="5a587-231">Aşağıdaki önceden paylaşılan anahtarlar hakkında bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="5a587-231">See the section on Pre-Shared Keys below.</span></span>

<span data-ttu-id="5a587-232">Şifrelenmiş ön ana gizli anahtar, ClientKeyExchange iletisindeki sunucusuna gönderilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-232">The encrypted Pre-Master Secret is sent to the server in the ClientKeyExchange message.</span></span> <span data-ttu-id="5a587-233">Sunucu, ClientKeyExchange iletisini aldıktan sonra, özel anahtarını kullanarak ana ön parolanın şifresini çözer ve oturum anahtarlarını TLS istemcisiyle paralel olarak oluşturmaya devam eder.</span><span class="sxs-lookup"><span data-stu-id="5a587-233">The server, upon receiving the ClientKeyExchange message, decrypts the Pre-Master Secret using its private key and proceeds to generate the session keys in parallel with the TLS client.</span></span>

<span data-ttu-id="5a587-234">Oturum anahtarları oluşturulduktan sonra, diğer tüm iletiler, Merhaba iletilerde seçili olan özel anahtar algoritması (ör. AES) kullanılarak şifrelenir.</span><span class="sxs-lookup"><span data-stu-id="5a587-234">Once the session keys are generated, all further messages can be encrypted using the private-key algorithm (e.g. AES) selected in the Hello messages.</span></span> <span data-ttu-id="5a587-235">Diğer tüm iletilerin şifrelendiğini belirtmek için hem istemci hem de sunucu tarafından, Changeccrypspec adlı bir son şifreli ileti gönderilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-235">One final un-encrypted message called ChangeCipherSpec is sent by both the client and server to indicate that all further messages will be encrypted.</span></span>

<span data-ttu-id="5a587-236">Hem istemci hem de sunucu tarafından gönderilen ilk şifreli ileti ayrıca, tamamlandı olarak adlandırılan son TLS el sıkışma iletisidir.</span><span class="sxs-lookup"><span data-stu-id="5a587-236">The first encrypted message sent by both the client and server is also the final TLS handshake message, called Finished.</span></span> <span data-ttu-id="5a587-237">Bu ileti alınan ve gönderilen tüm el sıkışma iletilerinin karmasını içerir.</span><span class="sxs-lookup"><span data-stu-id="5a587-237">This message contains a hash of all the handshake messages received and sent.</span></span> <span data-ttu-id="5a587-238">Bu karma, el sıkışmasının hiçbir iletiden değiştirilmediğini veya bozulmadığını (güvenlik ihlali olasılığı olduğunu gösterir) doğrulamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="5a587-238">This hash is used to verify that none of the messages in the handshake have been tampered with or corrupted (indicating a possible breach of security).</span></span>

<span data-ttu-id="5a587-239">Tamamlanan iletiler alındıktan ve el sıkışma karmaları doğrulandıktan sonra, TLS oturumu başlar ve uygulama veri göndermeye ve almaya başlar.</span><span class="sxs-lookup"><span data-stu-id="5a587-239">Once the Finished messages are received and the handshake hashes are verified, the TLS session begins, and the application begins sending and receiving data.</span></span> <span data-ttu-id="5a587-240">TLS oturumu sırasında her iki taraf tarafından gönderilen tüm veriler ilk olarak, oluşturulan oturum anahtarlarına sahip seçili özel anahtar algoritması kullanılarak, Merhaba iletilerde seçilen karma algoritma kullanılarak (ileti bütünlüğü sağlamak için) ve şifreli olarak şifrelenir.</span><span class="sxs-lookup"><span data-stu-id="5a587-240">All data sent by either side during the TLS session is first hashed using the hash algorithm chosen in the Hello messages (to provide message integrity) and encrypted using the chosen private-key algorithm with the generated session keys.</span></span>

<span data-ttu-id="5a587-241">Son olarak, bir TLS oturumu yalnızca Istemci veya sunucu bunu yapmayı seçerse başarılı bir şekilde sonlandırgirebilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-241">Finally, a TLS session can only be successfully ended if either the Client or Server chooses to do so.</span></span> <span data-ttu-id="5a587-242">Kesilen oturum, bir güvenlik ihlali olarak değerlendirilir (bir saldırgan tüm verilerin alınmasını engellemeye çalışıyor olabilir), bu nedenle her iki taraf da oturumu sonlandırmak istediğinde, bir CloseNotify uyarısı olarak adlandırılan özel bir bildirim gönderilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-242">A truncated session is considered a security breach (since an attacker may be attempting to prevent all the data being sent from being received) so a special notification is sent when either side wants to end the session, called a CloseNotify alert.</span></span> <span data-ttu-id="5a587-243">Başarılı bir oturum kapatması için hem istemci hem de sunucu bir CloseNotify uyarısı göndermelidir ve işlemelidir.</span><span class="sxs-lookup"><span data-stu-id="5a587-243">Both the client and server must send and process a CloseNotify alert for a successful session shutdown.</span></span>

![Tipik bir TLS el sıkışma diyagramı.](media/image4.png)

<span data-ttu-id="5a587-245">Şekil 3-tipik TLS el sıkışması</span><span class="sxs-lookup"><span data-stu-id="5a587-245">Figure 3- Typical TLS handshake</span></span>

### <a name="tls-13-handshake"></a><span data-ttu-id="5a587-246">TLS 1,3 el sıkışma</span><span class="sxs-lookup"><span data-stu-id="5a587-246">TLS 1.3 Handshake</span></span>

<span data-ttu-id="5a587-247">TLS 1,3, TLS protokolünün oldukça büyük bir fazla yer taşıdır.</span><span class="sxs-lookup"><span data-stu-id="5a587-247">TLS 1.3 is a fairly major overhaul of the TLS protocol.</span></span> <span data-ttu-id="5a587-248">Güvenlik ve performansı artırmak için el sıkışma üzerinde yapılan değişikliklerin büyük çoğunluğu yapılmıştır.</span><span class="sxs-lookup"><span data-stu-id="5a587-248">The vast majority of the changes were made to the handshake to increase security and performance.</span></span> <span data-ttu-id="5a587-249">Şekil 4 ' te tipik bir TLS 1,3 anlaşması gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="5a587-249">A typical TLS 1.3 handshake is shown in Figure 4.</span></span> <span data-ttu-id="5a587-250">Birincil fark, sunucu ve istemci arasındaki değişim sayısında görülebilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-250">The primary difference can be seen in the number of exchanges between the server and client.</span></span>

<span data-ttu-id="5a587-251">TLS 1,2 ve önceki sürümlerde, sunucu iki adet fışıkla<sup>12</sup> ileti gönderir: Ilk olarak serverhello ve ardından bir changeccrypspec iletisi göndererek el sıkışmasını sonlandıran şifreli tamamlanmış iletiyi göndermeden önce.</span><span class="sxs-lookup"><span data-stu-id="5a587-251">In TLS 1.2 and earlier, the server would send two flights<sup>12</sup> of messages – first the ServerHello and then a ChangeCipherSpec message before sending the encrypted Finished message that ends the handshake.</span></span> <span data-ttu-id="5a587-252">TLS 1,3 ' de, sunucu her şeyi ilk uçuşa – ServerHello, Extensions, Certificate ve finished olarak gönderir.</span><span class="sxs-lookup"><span data-stu-id="5a587-252">In TLS 1.3, the server sends everything in the first flight – ServerHello, extensions, certificate, and Finished.</span></span> <span data-ttu-id="5a587-253">Changecrelaspec iletisi çıkarıldı ve sunucu oturum anahtarlarını oluşturur ve Sunucuhello sonrasında el sıkışma iletilerini şifrelemeyi başlatır.</span><span class="sxs-lookup"><span data-stu-id="5a587-253">The ChangeCipherSpec message was eliminated and the server generates its session keys and starts encrypting handshake messages immediately following the ServerHello.</span></span>

<span data-ttu-id="5a587-254">Yeni düzenleme, bir saldırganın erişebileceği düz metin veri miktarını sınırlayarak TLS el sıkışmasının daha fazla şifreleme ile korunduğu anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="5a587-254">The new arrangement means that more of the TLS handshake is protected by encryption, limiting the amount of plaintext data an attacker can access.</span></span> <span data-ttu-id="5a587-255">Buna ek olarak, ikinci sunucu uçuş işleminin (yalnızca bir Changecbir özellik olan) kaldırılması, bir TLS istemcisinin artık uygulama verilerini iletmeye başlamasını beklemek zorunda olmadığı anlamına gelir. Bu, istemci kendi tamamlanmış iletisini gönderdiğinde oturum başlatılır.</span><span class="sxs-lookup"><span data-stu-id="5a587-255">Additionally, the removal of the second server flight (which was just a ChangeCipherSpec followed by a Finished) means that a TLS client no longer needs to wait to start transmitting application data – as soon as the client sends its own Finished message the session is started.</span></span>

12. <span data-ttu-id="5a587-256">Uçuş, tek bir grupta aynı anda gönderilen TLS iletileri koleksiyonudur.</span><span class="sxs-lookup"><span data-stu-id="5a587-256">A flight is simply a collection of TLS messages sent simultaneously in a group.</span></span>

![TLS 1,3 el sıkışma diyagramı.](media/image5.png)

<span data-ttu-id="5a587-258">Şekil 4-TLS 1,3 el sıkışma</span><span class="sxs-lookup"><span data-stu-id="5a587-258">Figure 4 - TLS 1.3 Handshake</span></span>

> [!NOTE]
> <span data-ttu-id="5a587-259">*TLS 1,3 Ayrıca, bazı uygulama verilerinin ilk ileti uçuşunda gönderilebileceği anlamına gelen "erken veri" ve 0-RTT (sıfır gidiş dönüş süresi) kavramını ortaya sunmuştur. Bu isteğe bağlı özellik öncelikle web tarayıcısı yanıt verme iyileştirmesi (örn. bir sayfa işlemeye başlamak için erken HTTP üstbilgileri göndermek için) olarak eklenmiştir. Azure RTOS 6,0 itibariyle bu özellik desteklenmez.*</span><span class="sxs-lookup"><span data-stu-id="5a587-259">*TLS 1.3 also introduced the notion of "Early data" and 0-RTT (Zero Round Trip Time), meaning that some application data can be sent in the first flight of messages. This optional feature was added primarily as an optimization for web browser responsiveness (e.g. to send early HTTP headers to start rendering a page). As of Azure RTOS 6.0 this feature is NOT supported.*</span></span>

### <a name="initialization"></a><span data-ttu-id="5a587-260">Başlatma</span><span class="sxs-lookup"><span data-stu-id="5a587-260">Initialization</span></span>

<span data-ttu-id="5a587-261">NETX güvenli TLS kullanılmadan önce NetX veya NetXDuo TCP/IP yığınının başlatılması gerekir.</span><span class="sxs-lookup"><span data-stu-id="5a587-261">The NetX or NetXDuo TCP/IP stack must be initialized prior to using NetX Secure TLS.</span></span> <span data-ttu-id="5a587-262">TCP/IP yığınını düzgün bir şekilde başlatma hakkında bilgi için NetX veya NetXDuo Kullanıcı kılavuzuna bakın.</span><span class="sxs-lookup"><span data-stu-id="5a587-262">Refer to the NetX or NetXDuo User Guide for information on how to properly initialize the TCP/IP stack.</span></span>

<span data-ttu-id="5a587-263">NetX TCP/IP yığını başlatıldıktan sonra, TLS etkinleştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-263">Once the NetX TCP/IP stack has been initialized, TLS can be enabled.</span></span> <span data-ttu-id="5a587-264">Dahili olarak, tüm TLS ağ trafiği ve işleme, Kullanıcı müdahalesi gerektirmeden NetX/NetXDuo Stack tarafından işlenir.</span><span class="sxs-lookup"><span data-stu-id="5a587-264">Internally, all TLS network traffic and processing is handled by the NetX/NetXDuo stack without requiring user intervention.</span></span> <span data-ttu-id="5a587-265">Ancak, TLS, temel ağ yığınından ayrı olarak işlenmesi gereken bazı özel gereksinimlere sahiptir.</span><span class="sxs-lookup"><span data-stu-id="5a587-265">However, TLS has some specific requirements that must be handled separately from the underlying network stack.</span></span> <span data-ttu-id="5a587-266">Bu parametreler _ *_nx_secure_tls_session_create_*\* hizmeti kullanılarak \***NX_SECURE_TLS_SESSION** _ adlı TLS denetim bloğuna atanır.</span><span class="sxs-lookup"><span data-stu-id="5a587-266">These parameters are assigned to the TLS control block called ***NX_SECURE_TLS_SESSION** _ using the _ *_nx_secure_tls_session_create_** service.</span></span>

<span data-ttu-id="5a587-267">TLS, iki mod, sunucu ve Istemciye sahiptir, bunlardan biri bir uygulamada etkinleştirilebilir (ancak NetX yuvası başına yalnızca bir mod) ve her biri aşağıda ayrıntılı şekilde kendi özel gereksinimlerine sahiptir.</span><span class="sxs-lookup"><span data-stu-id="5a587-267">TLS has two modes, Server and Client, either of which may be enabled in an application (but only one mode per NetX socket), and each have their own specific requirements, detailed below.</span></span>

<span data-ttu-id="5a587-268">Her iki modda da NetX güvenli TLS, uzak ana bilgisayar ile bir TCP yuvası (\***NX_TCP_SOCKET** _) OLUŞTURULMASıNı ve TCP iletişimleri için ayarlanmasını gerektirir.</span><span class="sxs-lookup"><span data-stu-id="5a587-268">In either mode, NetX Secure TLS requires a TCP socket (\***NX_TCP_SOCKET** _) to be created and set up for TCP communications with the remote host.</span></span> <span data-ttu-id="5a587-269">TCP yuvası, aşağıda ayrıntılı olarak açıklanan _ *_nx_secure_tls_session_start_*\* HIZMETIYLE bir TLS oturum örneğine atanır.</span><span class="sxs-lookup"><span data-stu-id="5a587-269">The TCP socket is assigned to a TLS session instance with the _ *_nx_secure_tls_session_start_*\* service, detailed below.</span></span>

### <a name="initialization--tls-server"></a><span data-ttu-id="5a587-270">Başlatma – TLS sunucusu</span><span class="sxs-lookup"><span data-stu-id="5a587-270">Initialization – TLS Server</span></span>

<span data-ttu-id="5a587-271">Bir TCP yuvasına ek olarak, NetX güvenli TLS sunucu modu, bağlanan TLS istemcisine TLS sunucusunu tanımlamak için kullanılan bir belge olan *dijital bir sertifika* ve genellikle RSA şifreleme algoritması için karşılık gelen *özel anahtarı* sertifikalar gerektirir.</span><span class="sxs-lookup"><span data-stu-id="5a587-271">In addition to a TCP socket, NetX Secure TLS Server mode requires a *Digital Certificate*, which is a document used to identify the TLS server to the connecting TLS client, and the certificates corresponding *Private Key*, usually for the RSA encryption algorithm.</span></span> <span data-ttu-id="5a587-272">International Telekomünikasyon Birliği X. 509.440 standart, TLS tarafından kullanılan sertifika biçimini belirtir ve X. 509.952 dijital sertifikaları oluşturmak için çok sayıda yardımcı program vardır.</span><span class="sxs-lookup"><span data-stu-id="5a587-272">The International Telecommunications Union X.509 standard specifies the certificate format used by TLS and there are numerous utilities for creating X.509 digital certificates.</span></span>

<span data-ttu-id="5a587-273">NetX güvenli TLS için, X. 509.440 sertifikası ASN. 1 ' in Distinguished Encoding Rules (DER) biçimi kullanılarak ikili kodlanmış olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="5a587-273">For NetX Secure TLS, the X.509 certificate must be binary-encoded using the Distinguished Encoding Rules (DER) format of ASN.1.</span></span> <span data-ttu-id="5a587-274">DER, sertifikalar için Standart TLS-kablolu ikili biçimidir.</span><span class="sxs-lookup"><span data-stu-id="5a587-274">DER is the standard TLS over-the-wire binary format for certificates.</span></span>

<span data-ttu-id="5a587-275">Belirtilen sertifikayla ilişkili özel anahtar DER-Encoded PKCS # 1 biçiminde olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="5a587-275">The private key associated with the provided certificate must be in DER-Encoded PKCS#1 format.</span></span> <span data-ttu-id="5a587-276">Özel anahtar yalnızca cihazda kullanılır ve hiçbir şekilde kablo üzerinden aktarılmaz.</span><span class="sxs-lookup"><span data-stu-id="5a587-276">The private key is only used on the device and will never be transmitted over the wire.</span></span> <span data-ttu-id="5a587-277">TLS iletişimleri için güvenlik sağlayan özel anahtarları güvende tutun!</span><span class="sxs-lookup"><span data-stu-id="5a587-277">Keep private keys safe as they provide the security for TLS communications!</span></span>

<span data-ttu-id="5a587-278">TLS sunucu sertifikasını başlatmak için, uygulamanın, _ *NX_SECURE_X509_CERT*\* yapısını TLS tarafından kullanılmak üzere uygun sertifika verileriyle dolduran, der kodlu X. 509.952 sertifikasını ve Isteğe bağlı der kodlu PKCS # 1 RSA özel anahtar **nx_secure_x509_certificate_intialize** verilerini içeren bir arabellek işaretçisi sağlaması gerekir.</span><span class="sxs-lookup"><span data-stu-id="5a587-278">To initialize the TLS Server certificate, the application must provide a pointer to a buffer containing the DER-encoded X.509 certificate and optional DER-encoded PKCS#1 RSA private key data using the ***nx_secure_x509_certificate_intialize** _ service, which populates the _ *NX_SECURE_X509_CERT** structure with the appropriate certificate data for use by TLS.</span></span>

<span data-ttu-id="5a587-279">Sunucu sertifikası başlatıldıktan sonra, ***nx_secure_tls_local_certificate_add*** HIZMETI kullanılarak TLS denetim bloğuna eklenmelidir.</span><span class="sxs-lookup"><span data-stu-id="5a587-279">Once the server certificate has been initialized, it must be added to the TLS control block using the ***nx_secure_tls_local_certificate_add*** service.</span></span>

<span data-ttu-id="5a587-280">Sunucunun sertifikası TLS denetim bloğuna eklendikten sonra, yuva güvenli bir TLS sunucu bağlantısı kurmak için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-280">Once the server's certificate has been added to the TLS control block, the socket may be used to establish a secure TLS Server connection.</span></span>

### <a name="initialization--tls-client"></a><span data-ttu-id="5a587-281">Başlatma – TLS Istemcisi</span><span class="sxs-lookup"><span data-stu-id="5a587-281">Initialization – TLS Client</span></span>

<span data-ttu-id="5a587-282">NetX güvenli TLS Istemci modu, güvenilen sertifika yetkililerinden (CA 'lar) bulunan X. 509.440 kodlu dijital sertifikaların bir koleksiyonu olan *Güvenilen bir sertifika deposu* gerektirir.</span><span class="sxs-lookup"><span data-stu-id="5a587-282">NetX Secure TLS Client mode requires a *Trusted Certificate Store*, which is a collection of X.509-encoded digital certificates from trusted Certificate Authorities (CA's).</span></span> <span data-ttu-id="5a587-283">Bu sertifikalar TLS protokolünün "güvenilir" olarak kabul edilir ve TLS sunucu varlıkları tarafından belirtilen sertifikaların kimliğini NetX güvenli TLS Istemcisine doğrulamak için temel olarak görev yapar.</span><span class="sxs-lookup"><span data-stu-id="5a587-283">These certificates are assumed by the TLS protocol to be "trusted" and serve as the basis for authenticating certificates provided by TLS server entities to NetX Secure TLS Client.</span></span>

<span data-ttu-id="5a587-284">Güvenilen CA sertifikası, başka bir CA tarafından *otomatik olarak imzalanmış* veya imzalı olabilir, bu durumda sertifikaya BIR *ara CA* (ICA) denir.</span><span class="sxs-lookup"><span data-stu-id="5a587-284">A trusted CA certificate may either be *self-signed* or signed by another CA, in which case that certificate is called an *Intermediate CA* (ICA).</span></span> <span data-ttu-id="5a587-285">Tipik bir TLS uygulamasında sunucu, sunucu sertifikasıyla birlikte ICA sertifikalarını sağlar, ancak başarılı kimlik doğrulaması için tek gereksinim, sunucu sertifikasından güvenilen sertifika deposundaki güvenilir bir CA sertifikasına geri doğru bir şekilde izlenebilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-285">In a typical TLS application, the server provides the ICA certificates along with its server certificate, but the only requirement for successful authentication is that a chain of issuers (certificates used to sign other certificates) can be traced from the server certificate back to a trusted CA certificate in the Trusted Certificate Store.</span></span> <span data-ttu-id="5a587-286">Bu zincir bir  *güven zinciri* veya *sertifika zinciri* olarak bilinir.</span><span class="sxs-lookup"><span data-stu-id="5a587-286">This chain is known as a  *chain of trust* or *certificate chain*.</span></span>

<span data-ttu-id="5a587-287">Güvenilen bir CA veya ICA sertifikası başlatmak için, uygulamanın, _ *NX_SECURE_X509_CERT*\* yapısını TLS tarafından kullanılmak üzere uygun sertifika verileriyle dolduran, \***nx_secure_x509_certificate_intialize** _ hizmetini kullanarak der kodlu X. 509.440 sertifikasını içeren bir arabellek işaretçisi sağlaması gerekir.</span><span class="sxs-lookup"><span data-stu-id="5a587-287">To initialize a trusted CA or ICA certificate, the application must provide a pointer to a buffer containing the DER-encoded X.509 certificate using the ***nx_secure_x509_certificate_intialize** _ service, which populates the _ *NX_SECURE_X509_CERT** structure with the appropriate certificate data for use by TLS.</span></span>

<span data-ttu-id="5a587-288">Başlatılmış olan güvenilen sertifikalar, ***nx_secure_tls_trusted_certificate_add*** HIZMETI kullanılarak TLS denetim bloğuna eklenir.</span><span class="sxs-lookup"><span data-stu-id="5a587-288">Trusted certificates that have been initialized are then added to the TLS control block using the ***nx_secure_tls_trusted_certificate_add*** service.</span></span> <span data-ttu-id="5a587-289">Bir sertifika eklenemedi TLS Istemci oturumunun başarısız olmasına neden olur, çünkü TLS protokolünün uzak TLS sunucu konaklarının kimliğini doğrulamak için bir yol olmayacaktır.</span><span class="sxs-lookup"><span data-stu-id="5a587-289">Failure to add a certificate will cause the TLS Client session to fail as there will be no way for the TLS protocol to authenticate remote TLS server hosts.</span></span>

<span data-ttu-id="5a587-290">TLS Istemcisinde Ayrıca gelen sunucu sertifikasının ayrılması için alan gerekir (önceden paylaşılan bir anahtar modunun kullanılmakta olduğu varsayılırsa).</span><span class="sxs-lookup"><span data-stu-id="5a587-290">The TLS Client also needs space for the incoming server certificate to be allocated (assuming a Pre-Shared Key mode is not being used).</span></span> <span data-ttu-id="5a587-291">NetX güvenli TLS 5,12 itibariyle, uygulamanın uzak sertifika için alan ayırması artık gerekli değildir.</span><span class="sxs-lookup"><span data-stu-id="5a587-291">As of NetX Secure TLS 5.12, it is no longer necessary for the application to allocate space for remote certificate.</span></span> <span data-ttu-id="5a587-292">Ancak, bir sunucu sertifikası için alan ayırma eski seçeneği hala kullanılabilir ve iç sertifika arabelleği en iyi duruma getirme <sup>13</sup> ' den önce Kullanıcı tarafından ayrılan sertifikalar kullanılır. daha fazla bilgi için ***nx_secure_tls_remote_certificate_allocate*** hizmetine bakın.</span><span class="sxs-lookup"><span data-stu-id="5a587-292">However, the legacy option to allocate space for a server certificate is still available and user-allocated certificates will be used before the internal certificate buffer optimization <sup>13</sup> – see the ***nx_secure_tls_remote_certificate_allocate*** service for more information.</span></span>

<span data-ttu-id="5a587-293">Güvenilen sertifika deposu oluşturulduktan ve sunucu sertifikası için alan ayrıldıktan sonra, yuva güvenli bir TLS Istemci bağlantısı kurmak için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-293">Once the Trusted Certificate Store has been created and space for the server certificate has been allocated, the socket may be used to establish a secure TLS Client connection.</span></span>

13. <span data-ttu-id="5a587-294">İyileştirme, daha önce NetX güvenli TLS 'in daha önceki sürümlerinde kullanılan Kullanıcı tarafından sağlanan yapıları kullanmak yerine, Kullanıcı uygulaması tarafından TLS *nx_secure_tls_session_packet_buffer_set* oturumuna tarafından sağlanan "paket arabelleğini" kullanır.</span><span class="sxs-lookup"><span data-stu-id="5a587-294">The optimization utilizes the “packet buffer” supplied by the user application to the tls session using *nx_secure_tls_session_packet_buffer_set* to allocate the X.509 parsing structures instead of using the user-supplied structures used in earlier versions of NetX Secure TLS.</span></span> <span data-ttu-id="5a587-295">Paket arabelleğinin boyutunu aşan bir sertifika zinciri, paket arabelleği boyutu artmış olabilir veya *nx_secure_tls _remote_certificate_allocate* sertifika zinciri için daha fazla alan ayırmak üzere kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-295">There is an unlikely possibility of encountering a certificate chain exceeding the size of the packet buffer in which case either the packet buffer size may be increased or *nx_secure_tls _remote_certificate_allocate* may be used to allocate more space for the certificate chain.</span></span>

### <a name="application-interface-calls"></a><span data-ttu-id="5a587-296">Uygulama arabirimi çağrıları</span><span class="sxs-lookup"><span data-stu-id="5a587-296">Application Interface Calls</span></span>

<span data-ttu-id="5a587-297">NetX güvenli TLS uygulamaları, genellikle ThreadX RTOS altında çalışan uygulama iş parçacıklarının içinden işlev çağrıları yapar.</span><span class="sxs-lookup"><span data-stu-id="5a587-297">NetX Secure TLS applications will typically make function calls from within application threads running under the ThreadX RTOS.</span></span> <span data-ttu-id="5a587-298">Özellikle temel ağ iletişim protokolleri (örn. TCP ve IP) için bazı başlatma, \*\*\*tx_application_define \*\*\* öğesinden çağrılabilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-298">Some initialization, particularly for the underlying network communications protocols (e.g. TCP and IP) may be called from \***tx_application_define\*.**</span></span> <span data-ttu-id="5a587-299">Ağ iletişimlerini başlatma hakkında daha fazla bilgi için bkz. NetX/NetXDuo Kullanıcı Kılavuzu.</span><span class="sxs-lookup"><span data-stu-id="5a587-299">See the NetX/NetXDuo User Guide for more information on initializing network communications.</span></span>

<span data-ttu-id="5a587-300">TLS, işlemci yoğunluklu işlemler olan şifreleme yordamlarının yoğun bir şekilde kullanılmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="5a587-300">TLS makes heavy use of encryption routines which are processor-intensive operations.</span></span> <span data-ttu-id="5a587-301">Genellikle, bu işlemler çağıran iş parçacığı bağlamında gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-301">Generally, these operations will be performed within the context of calling thread.</span></span>

### <a name="tls-session-start"></a><span data-ttu-id="5a587-302">TLS oturumu başlatma</span><span class="sxs-lookup"><span data-stu-id="5a587-302">TLS Session Start</span></span>

<span data-ttu-id="5a587-303">TLS, çalışması için temeldeki bir aktarım katmanı ağı Protokolü gerektirir.</span><span class="sxs-lookup"><span data-stu-id="5a587-303">TLS requires an underlying transport-layer network protocol in order to function.</span></span> <span data-ttu-id="5a587-304">Genellikle kullanılan protokol TCP 'dir.</span><span class="sxs-lookup"><span data-stu-id="5a587-304">The protocol typically used is TCP.</span></span> <span data-ttu-id="5a587-305">NetX güvenli bir TLS oturumu oluşturmak için, NetX/NetXDuo TCP API 'SI kullanılarak bir TCP bağlantısı kurulması gerekir.</span><span class="sxs-lookup"><span data-stu-id="5a587-305">In order to establish a NetX Secure TLS session, a TCP connection must be established using the NetX/NetXDuo TCP API.</span></span> <span data-ttu-id="5a587-306">Bir **NX_TCP_SOCKET** oluşturulmalı ve bir bağlantı oluşturulması gerekir **_nx_tcp_server_socket_listen_*_ ve _*_nx_tcp_server_socket_accept_*_ Hizmetleri (TLS sunucusu için) veya _*_nx_tcp_client_socket_connect_** hizmeti (TLS istemcisi için).</span><span class="sxs-lookup"><span data-stu-id="5a587-306">An **NX_TCP_SOCKET** must be created and a connection established using the **_nx_tcp_server_socket_listen_*_ and _*_nx_tcp_server_socket_accept_*_ services (for TLS Server) or the _*_nx_tcp_client_socket_connect_** service (for TLS Client).</span></span>

<span data-ttu-id="5a587-307">TCP bağlantısı kurulduktan sonra, TCP yuvası ***nx_secure_tls_session_start*** hizmetine geçirilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-307">Once a TCP connection has been established, the TCP socket is then passed to the ***nx_secure_tls_session_start*** service.</span></span>

### <a name="tls-packet-allocation"></a><span data-ttu-id="5a587-308">TLS paket ayırma</span><span class="sxs-lookup"><span data-stu-id="5a587-308">TLS Packet Allocation</span></span>

<span data-ttu-id="5a587-309">NetX güvenli TLS, _*_nx_packet_allocate_*_ hizmetini çağırmak yerine NETX/NetXDuo TCP (***NX_PACKET** _) ile aynı paket yapısını kullanır. bu nedenle, TLS üstbilgisi için alanın doğru ayrılabileceği şekilde _ *_nx_secure_tls_packet_allocate_** hizmetinin çağrılması gerekir.</span><span class="sxs-lookup"><span data-stu-id="5a587-309">NetX Secure TLS uses the same packet structure as NetX/NetXDuo TCP (***NX_PACKET** _) except that instead of calling the _*_nx_packet_allocate_*_ service, the _ *_nx_secure_tls_packet_allocate_** service must be called so that space for the TLS header may be allocated properly.</span></span>

### <a name="tls-session-send"></a><span data-ttu-id="5a587-310">TLS oturumu gönderme</span><span class="sxs-lookup"><span data-stu-id="5a587-310">TLS Session Send</span></span>

<span data-ttu-id="5a587-311">TLS oturumu başladıktan sonra uygulama, \***nx_secure_tls_session_send** _ hizmetini kullanarak veri gönderebilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-311">Once the TLS session has started, the application may send data using the \***nx_secure_tls_session_send** _ service.</span></span> <span data-ttu-id="5a587-312">Gönderme hizmeti, gönderilen verileri içeren bir _*_NX_PACKET_*_ veri yapısı alarak _*_nx_tcp_socket_send_*_ hizmeti için kullanılan özdeş, yalnızca bu veriler GÖNDERILMEDEN önce NX güvenli TLS yığını tarafından şifrelenir ve bu paket _ *_nx_secure_tls_packet_allocate_* \* kullanılarak ayrılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="5a587-312">The send service is identical in use to the _*_nx_tcp_socket_send_*_ service, taking an _*_NX_PACKET_*_ data structure containing the data being sent, only that data will be encrypted by the NX Secure TLS stack before being sent, and the packet must be allocated using _\*_nx_secure_tls_packet_allocate_\*\*.</span></span>

### <a name="tls-session-receive"></a><span data-ttu-id="5a587-313">TLS oturum alma</span><span class="sxs-lookup"><span data-stu-id="5a587-313">TLS Session Receive</span></span>

<span data-ttu-id="5a587-314">TLS oturumu başladıktan sonra uygulama, \***nx_secure_tls_session_receive** _ hizmetini kullanarak veri almaya başlayabilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-314">Once the TLS session has started, the application may begin receiving data using the \***nx_secure_tls_session_receive** _ service.</span></span> <span data-ttu-id="5a587-315">TLS oturumu gönderme gibi, bu hizmet, gelen verilerin, paket yapısına döndürülmeden önce TLS yığını tarafından şifresinin çözülmesi ve doğrulanması dışında _ *_nx_tcp_socket_receive_* \* ile aynıdır.</span><span class="sxs-lookup"><span data-stu-id="5a587-315">Like the TLS Session send, this service is identical in use to _\*_nx_tcp_socket_receive_\*\*, except that the incoming data is decrypted and verified by the TLS stack before being returned in the packet structure.</span></span>

### <a name="tls-session-close"></a><span data-ttu-id="5a587-316">TLS oturumu kapatma</span><span class="sxs-lookup"><span data-stu-id="5a587-316">TLS Session Close</span></span>

<span data-ttu-id="5a587-317">Bir TLS oturumu tamamlandıktan sonra, oturumu kapatmak için hem TLS istemcisi hem de sunucunun diğer tarafa bir CloseNotify uyarısı gönderebilmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="5a587-317">Once a TLS session is complete, both the TLS client and server must send a CloseNotify alert to the other side to shut down the session.</span></span> <span data-ttu-id="5a587-318">Başarılı bir oturumun kapatılmasını sağlamak için her iki taraf da uyarıyı alıp işlemelidir.</span><span class="sxs-lookup"><span data-stu-id="5a587-318">Both sides must receive and process the alert to ensure a successful session shutdown.</span></span>

<span data-ttu-id="5a587-319">Uzak ana bilgisayar bir CloseNotify uyarısı gönderirse, \***nx_secure_tls_session_receive** _ hizmetine yapılan tüm çağrılar uyarıyı işler, karşılık gelen uyarıyı uzak ana bilgisayara geri gönderir ve _ *_NX_SECURE_TLS_SESSION_CLOSED_* \* değerini döndürür.</span><span class="sxs-lookup"><span data-stu-id="5a587-319">If the remote host sends a CloseNotify alert, any calls to the ***nx_secure_tls_session_receive** _ service will process the alert, send the corresponding alert back to the remote host, and return a value of _*_NX_SECURE_TLS_SESSION_CLOSED_\*\*.</span></span> <span data-ttu-id="5a587-320">Oturum kapatıldıktan sonra, bu TLS oturumuyla veri gönderme veya alma girişimleri başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="5a587-320">Once the session is closed, any further attempts to send or receive data with that TLS session will fail.</span></span>

<span data-ttu-id="5a587-321">Uygulama TLS oturumunu kapatmayı istiyorsa, \***nx_secure_tls_session_end** _ hizmeti çağrılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="5a587-321">If the application wishes to close the TLS session, the \***nx_secure_tls_session_end** _ service must be called.</span></span> <span data-ttu-id="5a587-322">Hizmet, CloseNotify uyarısını gönderir ve yanıt CloseNotify 'ı işler.</span><span class="sxs-lookup"><span data-stu-id="5a587-322">The service will send the CloseNotify alert and process the response CloseNotify.</span></span> <span data-ttu-id="5a587-323">Yanıt alınmıyorsa, TLS oturumunun düzgün kapatılmadığını belirten bir hata değeri olan _ *_NX_SECURE_TLS_SESSION_CLOSE_FAIL_*\* döndürülür.</span><span class="sxs-lookup"><span data-stu-id="5a587-323">If the response is not received, an error value of _ *_NX_SECURE_TLS_SESSION_CLOSE_FAIL_*\* will be returned, indicating that the TLS session was not cleanly shutdown, a possible security breach.</span></span>

### <a name="tls-alerts"></a><span data-ttu-id="5a587-324">TLS uyarıları</span><span class="sxs-lookup"><span data-stu-id="5a587-324">TLS Alerts</span></span>

<span data-ttu-id="5a587-325">TLS, en yüksek güvenliği sağlamak üzere tasarlanmıştır, bu nedenle protokoldeki tüm hatalı davranışlar olası bir güvenlik ihlali olarak kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-325">TLS is designed to provide maximum security, so any errant behavior in the protocol is considered a potential security breach.</span></span> <span data-ttu-id="5a587-326">Bu nedenle, ileti işleme veya şifreleme/şifre çözme işlemlerinin her türlü hatası, el sıkışma veya oturumu hemen sonlandıran önemli hatalar olarak değerlendirilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-326">For this reason, any errors in message processing or encryption/decryption are considered fatal errors that terminate the handshake or session immediately.</span></span>

<span data-ttu-id="5a587-327">Yerel bir uygulamadaki hataların işlenmesi oldukça basittir, uzak Konağın durumu düzgün bir şekilde işlemek ve olası güvenlik ihlallerinin oluşmasını engellemek için bir hata oluştuğunu bilmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="5a587-327">While handling errors in a local application is relatively straightforward, the remote host needs to know that an error has occurred in order to properly handle the situation and prevent any further possible security breaches.</span></span> <span data-ttu-id="5a587-328">Bu nedenle, TLS uzak ana bilgisayara herhangi bir hata üzerine bir *Uyarı* iletisi gönderir.</span><span class="sxs-lookup"><span data-stu-id="5a587-328">For this reason, TLS will send an *Alert* message to the remote host upon any error.</span></span>

<span data-ttu-id="5a587-329">Uyarılar, diğer TLS iletileriyle aynı şekilde değerlendirilir ve bir saldırganın, belirtilen uyarı türünden bilgi toplamasını engellemek için oturum sırasında şifrelenir.</span><span class="sxs-lookup"><span data-stu-id="5a587-329">Alerts are treated in the same manner as any other TLS messages and are encrypted during the session to prevent an attacker from gathering information from the type of alert provided.</span></span> <span data-ttu-id="5a587-330">El sıkışma sırasında gönderilen uyarılar, olası bir saldırgan tarafından elde edilen bilgi miktarını sınırlamak için kapsamda sınırlanır.</span><span class="sxs-lookup"><span data-stu-id="5a587-330">During the handshake, the alerts sent are limited in scope to limit the amount of information that could be obtained by a potential attacker.</span></span>

<span data-ttu-id="5a587-331">TLS oturumunu kapatmak için kullanılan CloseNotify uyarısı, önemli olmayan tek uyarıdır.</span><span class="sxs-lookup"><span data-stu-id="5a587-331">The CloseNotify alert, used to close the TLS session, is the only non-fatal alert.</span></span> <span data-ttu-id="5a587-332">Bir uyarı olarak kabul edildiği ve uyarı iletisi olarak gönderildiği sürece bir CloseNotify, bir hata oluştuğunu belirtmeyen diğer uyarıların aksine.</span><span class="sxs-lookup"><span data-stu-id="5a587-332">While it is considered an alert and sent as an alert message, a CloseNotify is unlike other alerts in that it does not indicate an error has occurred.</span></span>

<span data-ttu-id="5a587-333">Uyarı değeri ve "düzey" (düzeyler "uyarı" ve "önemli", TLS uyarıları en çok "önemli"), TLS RFC 'lerde tanımlanmıştır ve oluşan hata türünü gösterir.</span><span class="sxs-lookup"><span data-stu-id="5a587-333">The alert value and "level" (levels are "warning" and "fatal" – most TLS alerts are "fatal") are defined in the TLS RFCs and indicate the type of error that occurred.</span></span> <span data-ttu-id="5a587-334">CloseNotify dışındaki çoğu TLS uyarısı, olası bir güvenlik sorunu göstergesi olarak düşünülebilir ve TLS oturumunun veya el sıkışmasının iptal edilmesine neden olur.</span><span class="sxs-lookup"><span data-stu-id="5a587-334">Most TLS Alerts other than CloseNotify can be considered an indication of a potential security issue and will result in the TLS session or handshake being aborted.</span></span> <span data-ttu-id="5a587-335">Herhangi bir TLS API çağrısı **NX_SECURE_TLS_ALERT_RECEIVED** (0x114) DÖNDÜRÜRSE, apı hizmeti **_Nx_secure_tls_session_alert_value_get_** (NETX güvenli TLS sürüm 5,12 ' de yenidir), güvenlik sorunlarına yönelik yanıtlarla ilgili herhangi bir kararta kullanılacak şekilde, uygulamanın TLS uyarı değerini ve düzeyini almak için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-335">If any TLS API call returns **NX_SECURE_TLS_ALERT_RECEIVED** (0x114), the API service **_nx_secure_tls_session_alert_value_get_** (new in NetX Secure TLS version 5.12) may be used to retrieve the TLS alert value and level for the application to use for any decisions regarding responses to security issues.</span></span> <span data-ttu-id="5a587-336">Çoğu durumda, CloseNotify dışındaki uzak ana bilgisayardan alınan tüm uyarılar önemli bir hata olarak düşünülmelidir, ancak bazı excptions vardır. daha fazla bilgi için bkz. TLS RFC 'Leri.</span><span class="sxs-lookup"><span data-stu-id="5a587-336">In most cases, any alert received from the remote host other than CloseNotify should be considered a fatal error, though there are some excptions – see the TLS RFCs for more information.</span></span>

### <a name="tls-session-renegotiation"></a><span data-ttu-id="5a587-337">TLS oturumu yeniden anlaşması</span><span class="sxs-lookup"><span data-stu-id="5a587-337">TLS Session Renegotiation</span></span>

<span data-ttu-id="5a587-338">TLS, mevcut bir TLS oturumu bağlamında yalnızca TLS oturum parametrelerinin yeniden anlaşması olan "yeniden anlaşma" kavramını destekler.</span><span class="sxs-lookup"><span data-stu-id="5a587-338">TLS supports the notion of "renegotiation" which is simply a renegotiation of the TLS session parameters within the context of an existing TLS session.</span></span> <span data-ttu-id="5a587-339">Bu yöntem, yeni el sıkışma iletilerinin mevcut oturum kullanılarak şifrelenme ve kimliğinin doğrulanmasıdır.</span><span class="sxs-lookup"><span data-stu-id="5a587-339">What this means in practice is that the new handshake messages are encrypted and authenticated using the existing session.</span></span> <span data-ttu-id="5a587-340">Bir TLS ana bilgisayarı, mevcut oturumu tamamlamaya gerek kalmadan yeni oturum parametreleri (ör. yeni TLS oturum anahtarları oluşturma) oluşturmak istediğinde yeniden anlaşma kullanılır.</span><span class="sxs-lookup"><span data-stu-id="5a587-340">Renegotiation is used when a TLS host wants to generate new session parameters (e.g. generate new TLS session keys) without having to complete the existing session.</span></span> <span data-ttu-id="5a587-341">Örneğin, bir uygulamanın güvenlik ilkeleri yalnızca sınırlı bir süre için kullanıldığında yeniden anlaşma istenebilir, ancak bu sürenin ötesinde bir TLS oturumu etkin kalır.</span><span class="sxs-lookup"><span data-stu-id="5a587-341">For example, renegotiation may be desirable when security policies for an application dictate that session keys are only used for a limited time but a TLS session remains active beyond that time.</span></span>

<span data-ttu-id="5a587-342">Oturum yeniden anlaşması ile ilgili bir sorun, bir saldırganın bir sunucuyu yeni parametrelerle yeniden anlaşma başlatmaya ikna edebilmesine ve böylece saldırganın TLS oturumuna izin vermesini sağlayan belirli bir noktadan adam saldırısından yararlanmasına neden olur.</span><span class="sxs-lookup"><span data-stu-id="5a587-342">One issue with session renegotiation is that is makes TLS vulnerable to a specific Man-in-the-Middle attack where an attacker can convince a server to initiate a renegotiation with new parameters, thus allowing the attacker to hijack the TLS session.</span></span> <span data-ttu-id="5a587-343">Bu sorunu azaltmak için, güvenli yeniden anlaşma gösterge uzantısı eklenmiştir (bkz. bölüm **hatası! Başvuru kaynağı bulunamadı.**</span><span class="sxs-lookup"><span data-stu-id="5a587-343">To mitigate this issue, the Secure Renegotiation Indication extension was introduced (see section **Error! Reference source not found.**</span></span> <span data-ttu-id="5a587-344">Bölüm).</span><span class="sxs-lookup"><span data-stu-id="5a587-344">section).</span></span>

<span data-ttu-id="5a587-345">NetX güvenli TLS, oturum yeniden anlaşmasını ve güvenli yeniden anlaşma gösterge uzantısını tamamen destekler.</span><span class="sxs-lookup"><span data-stu-id="5a587-345">NetX Secure TLS completely supports session renegotiation and the Secure Renegotiation Indication extension.</span></span>

<span data-ttu-id="5a587-346">Uzak bir ana bilgisayardan veri alırken, renegotations (ve Extension), uygulama etkileşimi olmadan otomatik olarak işlenir.</span><span class="sxs-lookup"><span data-stu-id="5a587-346">When receiving data from a remote host, renegotations (and the extension) are handled automatically without application interaction.</span></span> <span data-ttu-id="5a587-347">Oturum yeniden anlaşması hakkında bildirim istenirse *nx_secure_tls_session_renegotiate_callback_set* hizmetiyle bir yeniden anlaşma geri araması sağlanabilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-347">If notification about session renegotiations is desired, a renegotiation callback may be supplied with the *nx_secure_tls_session_renegotiate_callback_set* service.</span></span> <span data-ttu-id="5a587-348">Geri çağırma, uzak ana bilgisayar tarafından her yeniden anlaşma istendiğinde, uygulamanın istenirse işlem yapmasına izin vermek için çağrılır.</span><span class="sxs-lookup"><span data-stu-id="5a587-348">The callback will be invoked whenever a renegotiation is requested by the remote host, allowing the application to take action if desired.</span></span>

<span data-ttu-id="5a587-349">Etkin bir TLS oturumundan yeniden anlaşma başlatmak için, istenen TLS oturumunda *nx_secure_tls_session_renegotiate* hizmetini çağırmanız yeterlidir.</span><span class="sxs-lookup"><span data-stu-id="5a587-349">To initiate a renegotiation from an active TLS session, simply invoke the *nx_secure_tls_session_renegotiate* service on the desired TLS session.</span></span>

### <a name="tls-session-resumption"></a><span data-ttu-id="5a587-350">TLS oturum sürdürme</span><span class="sxs-lookup"><span data-stu-id="5a587-350">TLS Session Resumption</span></span>

<span data-ttu-id="5a587-351">TLS oturum sürdürme, bazı benzerlikler olmasına rağmen oturum yeniden anlaşması ile karıştırılmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="5a587-351">TLS session resumption should not be confused with session renegotiation, despite some similarities.</span></span> <span data-ttu-id="5a587-352">Oturum yeniden *anlaşması* , mevcut bir TLS oturumunda yeni bir el sıkışma başlatmayı da içerir. oturum *sürdürme* , tam bir TLS el SıKıŞMASı yapmadan kapalı bir TLS oturumunun yeniden başlatılmasını içeren tamamen isteğe bağlı bir özelliktir.</span><span class="sxs-lookup"><span data-stu-id="5a587-352">Where session *renegotiation* involves starting a new handshake within an existing TLS session, session *resumption* is a purely optional feature that involves restarting a closed TLS session without performing a complete TLS handshake.</span></span> <span data-ttu-id="5a587-353">Bunu başarmak için bir TLS uygulama, oturum parametreleri ve anahtarlarını önbelleğe alabilir ve bunları bir *oturum kimliğiyle* ilişkilendirerek, özgün el sıkışma içinde sağlanan benzersiz bir tanımlayıcıdır.</span><span class="sxs-lookup"><span data-stu-id="5a587-353">To achieve this, a TLS implementation may cache the session parameters and keys, associating them with a *session ID,* a unique identifier supplied in the original handshake.</span></span> <span data-ttu-id="5a587-354">Bir TLS sunucusuna bir oturum KIMLIĞI sağlayarak, istemci, daha önce konaklar arasındaki önceki bir TLS oturumunun var olduğunu ve bir süre sonra tamamlandığını ve istemcinin daha düşük bir el sıkışması ile oturumu yeniden kurması için hala duruma sahip olduğunu gösterir.</span><span class="sxs-lookup"><span data-stu-id="5a587-354">By supplying a session ID to a TLS server, a client indicates that a previous TLS session between the hosts existed and completed some time in the past, and that the client still possesses the state to re-establish the session with a reduced handshake.</span></span> <span data-ttu-id="5a587-355">Oturum anahtarları teorik olarak hala gizli ve yalnızca iki iletişim kuran ana bilgisayar tarafından bilindiğinden, sunucu yeni bir TLS oturumu başlatabilir ve normal El sıkışmanın çoğunu atlayabilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-355">Since the session keys are theoretically still secret and only known by the two communicating host, the server can start a new TLS session and bypass most of the normal handshake.</span></span>

<span data-ttu-id="5a587-356">Oturum sürdürme, anahtar oluşturma ana gizliliğini paylaşmak ve sertifika imzalarını doğrulamak için kullanılan, pahalı olabilecek ortak anahtar işlemlerini önlemek için kullanışlı olabilir, ancak aynı zamanda oturum parametreleri, anahtarlar ve crypotgraphic durumunun tüm olası oturumlar için bellekte tutulmasını (en azından yapılandırılabilir bir zaman penceresi için) gerekir.</span><span class="sxs-lookup"><span data-stu-id="5a587-356">Session resumption can be useful to avoid the potentially expensive public-key operations used to share the key generation master secret and verify certificate signatures, but it also requires that the session parameters, keys, and crypotgraphic state be maintained in memory for all possible sessions (at least for a configurable time window).</span></span>

<span data-ttu-id="5a587-357">NetX güvenli TLS 'nin geçerli sürümü Session sürdürme 'ı desteklemez. oturum KIMLIĞI yalnızca TLS sunucuları tarafından yok sayılır ve TLS istemcileri her zaman sunucuya bir el sıkışma gerçekleştirmesini isteyen NULL bir oturum KIMLIĞI sağlar.</span><span class="sxs-lookup"><span data-stu-id="5a587-357">The current version of NetX Secure TLS does not support session resumption – the session ID is simply ignored by TLS servers and TLS clients always supply a NULL session ID which prompts the server to perform a complete handshake.</span></span> <span data-ttu-id="5a587-358">Oturum sürdürme olmaması, tamamen isteğe bağlı bir özellik olduğundan ve tüm TLS uygulamalarının tam bir el sıkışma olması halinde, oturum KIMLIĞININ NULL veya tanınmayan olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="5a587-358">The lack of session resumption should cause no inter-operability issues as it is a completely optional feature and all TLS implementations must default to a complete handshake should the session ID be NULL or unrecognized.</span></span>

### <a name="protocol-layering"></a><span data-ttu-id="5a587-359">Protokol katmanlama</span><span class="sxs-lookup"><span data-stu-id="5a587-359">Protocol Layering</span></span>

<span data-ttu-id="5a587-360">TLS protokolü, Aktarım Katmanı (örn. TCP) ve uygulama katmanı arasındaki ağ yığınına uyar.</span><span class="sxs-lookup"><span data-stu-id="5a587-360">The TLS protocol fits into the networking stack between the transport layer (e.g. TCP) and the application layer.</span></span> <span data-ttu-id="5a587-361">TLS bazen bir Aktarım Katmanı Protokolü (Bu nedenle *Aktarım katmanı* güvenliği) olarak kabul edilir, ancak temel ağ PROTOKOLLERIYLE (TCP gibi) ilgili bir uygulama gibi davrandığı için bazen uygulama katmanında gruplandırılmıştır.</span><span class="sxs-lookup"><span data-stu-id="5a587-361">TLS is sometimes considered a transport-layer protocol (hence *Transport Layer* Security) but because it acts as an application with regard to the underlying network protocols (such as TCP) it is sometimes grouped into the application layer.</span></span>

<span data-ttu-id="5a587-362">TLS, TCP gibi sıralı ve kayıpsız teslimi destekleyen bir aktarım katmanı protokolü gerektirir.</span><span class="sxs-lookup"><span data-stu-id="5a587-362">TLS requires a transport layer protocol that supports in-order and lossless delivery, such as TCP.</span></span> <span data-ttu-id="5a587-363">Bu gereksinim nedeniyle, UDP veri birimlerinin teslimini garanti edemediğinden TLS UDP üzerinde çalıştırılamaz.</span><span class="sxs-lookup"><span data-stu-id="5a587-363">Due to this requirement, TLS cannot run on top of UDP since UDP does not guarantee delivery of datagrams.</span></span> <span data-ttu-id="5a587-364">TLS 'nin değiştirilmiş bir sürümü olan *DTLS* adlı ayrı bir protokol, UDP gibi bir veri birimi protokolü üzerinden TLS güvenliği gerektiren uygulamalar için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="5a587-364">A separate protocol called *DTLS,* which is a modified version of TLS, is used for applications that need the security of TLS over a datagram protocol like UDP.</span></span> <span data-ttu-id="5a587-365">NetX güvenliği DTLS 'yi destekler, ancak DTLS belgeleri bu belgeden ayrıdır.</span><span class="sxs-lookup"><span data-stu-id="5a587-365">NetX Secure supports DTLS, but documentation for DTLS is separate from this document.</span></span>

![TCP/IP ve TLS protokol katmanlarının diyagramı.](media/image6.png)

<span data-ttu-id="5a587-367">Şekil 5-TCP/IP ve TLS protokol katmanları</span><span class="sxs-lookup"><span data-stu-id="5a587-367">Figure 5- TCP/IP and TLS protocol layers</span></span>

## <a name="network-communications-security"></a><span data-ttu-id="5a587-368">Ağ Iletişimi güvenliği</span><span class="sxs-lookup"><span data-stu-id="5a587-368">Network Communications Security</span></span>

<span data-ttu-id="5a587-369">Kamu ağları ve Internet üzerinden iletişimin güvenliğini sağlamak, çok sayıda kitap, makale ve çözüm konusunun önemli öneme sahip bir konudur.</span><span class="sxs-lookup"><span data-stu-id="5a587-369">Securing communications over public networks and the Internet is a critically important topic and the subject of vast numbers of books, articles, and solutions.</span></span> <span data-ttu-id="5a587-370">Bu konu göz önünde bulundurularak, ancak yalnızca hedeflenen hedefin bu bilgileri erişebileceği veya değiştirebilmesini sağlamak için bir ağ üzerinden bilgi gönderilirken daha kolay bir fikir olabilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-370">The topic is mind-bogglingly complex, but can be reduced to a simple idea: sending information over a network so that only the intended target can access or change that information.</span></span> <span data-ttu-id="5a587-371">Bu üç önemli kavrama bölünür: Gizlilik, bütünlük ve kimlik doğrulama.</span><span class="sxs-lookup"><span data-stu-id="5a587-371">This breaks down into three important concepts: secrecy, integrity, and authentication.</span></span> <span data-ttu-id="5a587-372">TLS protokolü, her üç için çözüm sağlar.</span><span class="sxs-lookup"><span data-stu-id="5a587-372">The TLS protocol provides solutions for all three.</span></span>

### <a name="secrecy"></a><span data-ttu-id="5a587-373">Gizliliğinin</span><span class="sxs-lookup"><span data-stu-id="5a587-373">Secrecy</span></span>

<span data-ttu-id="5a587-374">Ağ üzerinden veri gönderirken genellikle verilerin kötü amaçlı bir varlık tarafından alınmaması önemlidir.</span><span class="sxs-lookup"><span data-stu-id="5a587-374">When sending data over a network, it is often important that the data cannot be obtained by a malicious entity.</span></span> <span data-ttu-id="5a587-375">Veriler bir TCP/IP bağlantısı üzerinden gönderiliyorsa, ağa erişimi olan herkes, kolayca kullanılabilir ağ araçlarını kullanarak bu verileri okuyabilecektir.</span><span class="sxs-lookup"><span data-stu-id="5a587-375">If data is sent over a TCP/IP connection, anyone with access to the network will be able to read that data using easily-available networking tools.</span></span> <span data-ttu-id="5a587-376">Bu verilerin elde edilmesine engel olmak için, hedeflenen hedef tarafından okunamayacak şekilde kodlanmalıdır: Bu Gizlilik *.*</span><span class="sxs-lookup"><span data-stu-id="5a587-376">To prevent that data from being obtained, it must be encoded such that it cannot be read except by the intended target – this is *secrecy.*</span></span> <span data-ttu-id="5a587-377">TLS 'de, RSA ve AES gibi şifreleme algoritmaları gizliliği sağlar.</span><span class="sxs-lookup"><span data-stu-id="5a587-377">In TLS, encryption algorithms such as RSA and AES provide secrecy.</span></span>

### <a name="integrity"></a><span data-ttu-id="5a587-378">Bütünlük</span><span class="sxs-lookup"><span data-stu-id="5a587-378">Integrity</span></span>

<span data-ttu-id="5a587-379">Bazen, gizlilik, ağ üzerinden veri gezini korumak için yeterli değildir.</span><span class="sxs-lookup"><span data-stu-id="5a587-379">Sometimes, secrecy is not enough to protect data travelling over a network.</span></span> <span data-ttu-id="5a587-380">Bazı durumlarda, kötü amaçlı bir varlık bir TCP paketinin içeriğini, paketin neleri içerdiğini bilmeden değiştirmek mümkün olabilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-380">In some cases, it may be possible for a malicious entity to alter the contents of a TCP packet without needing to know what that packet contains.</span></span> <span data-ttu-id="5a587-381">Şifrelenmiş veriler değiştirilebilir, şifre çözme işlemi geçersiz hale gelebilir veya ileti başındaki parametreler, saldırganın ilgilendiği herhangi bir sonuçla değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-381">Encrypted data can be altered, rendering the decryption invalid or changing the parameters of the message leading to whatever result the attacker may be interested in achieving.</span></span> <span data-ttu-id="5a587-382">Ağda, bir saldırganın geçiş sırasında verileri değiştirmesini engelleyemedik, ancak verilerin değiştirilip değiştirilmediğini bilen bir mekanizma sağlayabiliriz.</span><span class="sxs-lookup"><span data-stu-id="5a587-382">On the network, we cannot prevent an attacker from changing data in transit, but we can provide a mechanism to know whether or not the data has been changed.</span></span> <span data-ttu-id="5a587-383">Veriler aktarım sırasında değiştirildiğinde, bilinirler ve veriler reddedilebilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-383">When data is changed in transit, it will be known and the data can be rejected.</span></span> <span data-ttu-id="5a587-384">Bu kavram *bütünlüğü*.</span><span class="sxs-lookup"><span data-stu-id="5a587-384">This concept is *integrity*.</span></span> <span data-ttu-id="5a587-385">TLS 'de, bütünlük, *Karma işlevler* olarak bilinen bir şifreleme yordamları sınıfı tarafından sağlanır.</span><span class="sxs-lookup"><span data-stu-id="5a587-385">In TLS, integrity is provided by a class of cryptographic routines known as *hash functions*.</span></span> <span data-ttu-id="5a587-386">Karma işlevlere bazı örnekler MD5 ve SHA-1 ' dir.</span><span class="sxs-lookup"><span data-stu-id="5a587-386">Some examples of hash functions are MD5 and SHA-1.</span></span>

### <a name="authentication"></a><span data-ttu-id="5a587-387">Kimlik Doğrulaması</span><span class="sxs-lookup"><span data-stu-id="5a587-387">Authentication</span></span>

<span data-ttu-id="5a587-388">Ağ iletişimi güvenliği açısından üçüncü önemli kavram, verilerin yalnızca amaçlanan hedefe bildirilmesi gerektiğine yönelik bir fikirdir.</span><span class="sxs-lookup"><span data-stu-id="5a587-388">The third important concept in network communications security is the idea that data should only be communicated to the intended target.</span></span> <span data-ttu-id="5a587-389">Saldırgan, başka bir konağa yönelik verileri almak için meşru bir varlık olarak hazırlanmanıza çalışabilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-389">An attacker may attempt to pose as a legitimate entity to receive data intended for another host.</span></span> <span data-ttu-id="5a587-390">Veriler, gizliliği ve bütünlük mekanizmalarına sahip olsa bile, saldırgan bu gözden geçir aracılığıyla istenen sonuca (güvenli iletişim güvenliğinin aşılmasına karşı) yine de ulaşabiliyor olabilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-390">Even if the data is being sent with secrecy and integrity mechanisms in place, the attacker may still be able to achieve the desired result (a compromise of secure communications) through this deception.</span></span> <span data-ttu-id="5a587-391">Bunu engellemek için, herhangi bir hassas veri gönderilmeden önce uzak ana bilgisayarın kimliğini kanıtlamak için bir mekanizma gerekir.</span><span class="sxs-lookup"><span data-stu-id="5a587-391">To prevent this, a mechanism is needed to prove the identity of a remote host before any sensitive data is sent.</span></span> <span data-ttu-id="5a587-392">Bir uzak konağın kimliğini kanıtlama işlemi *kimlik doğrulaması olur.*</span><span class="sxs-lookup"><span data-stu-id="5a587-392">The process of proving the identity of a remote host is *authentication.*</span></span> <span data-ttu-id="5a587-393">TLS 'de kimlik doğrulaması, dijital sertifikalar, karma işlevler ve bir ortak anahtar şifreleme özelliğinden yararlanan *dijital imzalar* adlı bir mekanizma (aşağıda açıklanmıştır) kullanılarak sağlanır.</span><span class="sxs-lookup"><span data-stu-id="5a587-393">In TLS, authentication is provided using digital certificates, hash functions, and a mechanism called *digital signatures* which utilizes a property of public-key encryption (described below).</span></span> <span data-ttu-id="5a587-394">Bir *önceden paylaşılan anahtar* (PSK) ile sınırlı ancak yararlı bir kimlik doğrulama biçimi de sağlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="5a587-394">A limited but useful form of authentication can also be provided with a *pre-shared key* (PSK).</span></span>

## <a name="tls-encryption"></a><span data-ttu-id="5a587-395">TLS şifreleme</span><span class="sxs-lookup"><span data-stu-id="5a587-395">TLS Encryption</span></span>

<span data-ttu-id="5a587-396">TLS protokolü, şifreleme kullanan Internet üzerinden güvenli ağ iletişimleri sağlamaya yönelik bir çerçevedir.</span><span class="sxs-lookup"><span data-stu-id="5a587-396">The TLS protocol is a framework for providing secure network communications over the Internet utilizing encryption.</span></span> <span data-ttu-id="5a587-397">Şifreleme genellikle, verileri özgün verileri (veya ilgili veriler hakkındaki bilgileri) elde etmek için bir *anahtar* olmadan bu şekilde bir şekilde kodlama işlemi olarak tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="5a587-397">Encryption is generally defined as the process of encoding data in such a way that obtaining the original data (or information about that data) is exceedingly difficult without a *key*.</span></span> <span data-ttu-id="5a587-398">Bilgisayar sistemleri şifrelemesi, sınırlı alanlar gibi karmaşık matematik ve iki tür olarak sınıflandırılabilirler: *özel anahtar* (veya *simetrik şifreleme*) ve *ortak anahtar* (veya *asimetrik şifreleme*).</span><span class="sxs-lookup"><span data-stu-id="5a587-398">In computer systems encryption is based on complex mathematics such as finite fields and can be classified into two types: *private key* (or *symmetric encryption*) and *public key* (or *asymmetric encryption*).</span></span> <span data-ttu-id="5a587-399">Özel anahtar şifreleme örnekleri AES (Gelişmiş Şifreleme Standardı) ve RC4 (Rivest şifre 4).</span><span class="sxs-lookup"><span data-stu-id="5a587-399">Examples of private key encryption are AES (Advanced Encryption Standard) and RC4 (Rivest Cipher 4).</span></span> <span data-ttu-id="5a587-400">Ortak anahtar şifreleme örnekleri RSA (Rivest, Shamir, Adleson) ve Diffie-Hellman şifrelemeler.</span><span class="sxs-lookup"><span data-stu-id="5a587-400">Examples of public-key encryption are the RSA (Rivest, Shamir, Adleson) and Diffie-Hellman ciphers.</span></span>

<span data-ttu-id="5a587-401">TLS protokolü, performans, güvenlik ve esneklik dengelemesi sağlamak için hem özel anahtar hem de ortak anahtar şifreleme yordamlarını kullanır.</span><span class="sxs-lookup"><span data-stu-id="5a587-401">The TLS protocol makes use of both private key and public key encryption routines to provide a balance of performance, security, and flexibility.</span></span>

### <a name="private-key-encryption"></a><span data-ttu-id="5a587-402">Private-Key şifreleme</span><span class="sxs-lookup"><span data-stu-id="5a587-402">Private-Key Encryption</span></span>

<span data-ttu-id="5a587-403">Özel anahtar şifreleme, binlerce yıl boyunca kullanımda.</span><span class="sxs-lookup"><span data-stu-id="5a587-403">Private-key encryption has been in use for thousands of years.</span></span> <span data-ttu-id="5a587-404">Temel değiştirme şifrelemeleri (bir harf veya sözcük başka bir ilgisiz harf veya Word tarafından değiştirilmiştir) en erken bilinen şifreleme örnekleridir, ancak bilgi yaşı özel anahtar şifrelemesi 'nin bir yandan büyük ölçüde iyileşmesi önerilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-404">Basic substitution ciphers (where a letter or word is replaced by another unrelated letter or word) are the earliest known examples of encryption, but with the advent of the information age private key encryption has significantly improved.</span></span>

<span data-ttu-id="5a587-405">Özel anahtar şifresi, bazı verileri bir arada kodlamak için kullanılan bir değer olan bir "anahtar" (genel durumda bir sözcük, tümcecik veya sayı olabilir) kullanır. böylece, yalnızca bu anahtara erişimi olan bir varlığın verileri anlamlı bir şekilde çözebilmesini sağlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="5a587-405">A private key cipher uses a "key" which is simply a value (which could be a word, phrase, or number in the general case) that is used to somehow encode some data so that only an entity that had access to that key could decode the data in a meaningful way.</span></span> <span data-ttu-id="5a587-406">Anahtar, verilerin şifrelenmesi ve şifresinin çözülmesi için kullanılır, bu nedenle diğer ad *simetrik şifreleme*.</span><span class="sxs-lookup"><span data-stu-id="5a587-406">The key is used for both encryption and decryption of the data, hence the other name *symmetric encryption*.</span></span>

<span data-ttu-id="5a587-407">Özel anahtar şifrelemeleri genellikle hızlı ve oldukça basittir. Bu, matematik ve ilgili karmaşık bir karmaşıksa bile uygulanır.</span><span class="sxs-lookup"><span data-stu-id="5a587-407">Private key ciphers are generally fast and fairly simple to implement, even if the mathematics involved are exceedingly complex.</span></span> <span data-ttu-id="5a587-408">Bu nedenle TLS, güvenli iletişimler toplu olarak özel anahtar şifrelemeleri kullanır.</span><span class="sxs-lookup"><span data-stu-id="5a587-408">For this reason, TLS uses private key ciphers for the bulk of secure communications.</span></span>

<span data-ttu-id="5a587-409">Bununla birlikte, genel bilgisayar ağı iletişimine uygulamayı denerken özel anahtar şifrelemesi bir sorunla karşılaştı: anahtarın, iletişim kurmaya çalışan her iki makine arasında paylaşılması gerekir.</span><span class="sxs-lookup"><span data-stu-id="5a587-409">However, private key encryption has a problem when we try to apply it to general computer network communications: the key must be shared between both machines trying to communicate.</span></span> <span data-ttu-id="5a587-410">Genel durumda, ağ trafiğinin Internet üzerinden yönlendirilirken yaptığı çeşitli tür varlıkların herhangi bir sayıda varlık tarafından alınabileceğini varsayabileceği için, Internet 'teki iki makine arasında güvenli bir şekilde iletişim kurmak pratik ve genellikle imkansızdır.</span><span class="sxs-lookup"><span data-stu-id="5a587-410">In the general case, it is impractical and often impossible to communicate a private key securely between two machines on the Internet, as it can be assumed that the network traffic can be obtained by any number of entities in the various hops that data takes when being routed through the Internet.</span></span> <span data-ttu-id="5a587-411">Anahtar kötü amaçlı bir varlık tarafından elde edilirse, bu anahtar kullanılarak şifrelenen tüm verilerin güvenliği aşılmış olur.</span><span class="sxs-lookup"><span data-stu-id="5a587-411">If the key is obtained by a malicious entity, all data encrypted using that key is compromised.</span></span> <span data-ttu-id="5a587-412">Internet üzerindeki makinelerin çoğu iletişim için yalnızca bir ağ bağlantısına sahip olduğu ve iletişim için başka bir güvenli kanal olmadığından, ağ üzerinden anahtar gönderilmesi, verileri şifrelenmemiş olarak göndermek için bir güvenlik sağlar.</span><span class="sxs-lookup"><span data-stu-id="5a587-412">As most machines on the Internet have only a network connection and not another secure channel for communications, sending keys over the network is tantamount to sending the data unencrypted – it provides no security.</span></span>

<span data-ttu-id="5a587-413">Bu nedenle, özel anahtar şifrelemesi, genel amaçlı bir ağ iletişimi güvenlik protokolü uygulamak için yeterli değildir.</span><span class="sxs-lookup"><span data-stu-id="5a587-413">For this reason, private key encryption is not sufficient to implement a general-purpose network communications security protocol.</span></span> <span data-ttu-id="5a587-414">Bu, ortak anahtar şifrelemenin yardımcı olabilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-414">This is where Public Key encryption can help.</span></span>

<span data-ttu-id="5a587-415">NetX güvenli TLS, AES özel anahtar şifrelemesini destekler.</span><span class="sxs-lookup"><span data-stu-id="5a587-415">NetX Secure TLS supports AES private-key encryption.</span></span>

### <a name="public-key-encryption"></a><span data-ttu-id="5a587-416">Public-Key şifreleme</span><span class="sxs-lookup"><span data-stu-id="5a587-416">Public-Key Encryption</span></span>

<span data-ttu-id="5a587-417">Özel anahtar şifrelemenin aksine, ortak anahtar şifrelemesi, 1970 ' te geliştirilen oldukça yeni bir kavramdır.</span><span class="sxs-lookup"><span data-stu-id="5a587-417">Unlike private key encryption, public key encryption is a fairly new concept, having been developed in the 1970's.</span></span> <span data-ttu-id="5a587-418">"Tuzak kapısı işlevleri" olarak bilinen bir kavramı kullanarak, daha sonra şifrelenen verilerin güvenliğine güvenmeden bir ağ üzerinde bir anahtar paylaşmanın bir yolu vardı.</span><span class="sxs-lookup"><span data-stu-id="5a587-418">Using a concept known as "trap-door functions" in mathematics, it was discovered that there was a way to share a key over a network without compromising the security of then encrypted data.</span></span>

<span data-ttu-id="5a587-419">Ortak anahtar şifrelemenin çalışma şekli, anahtarın (yukarıda açıklanan özel anahtar şifreleme algılaması) iki parçaya, *özel bir anahtara* *ve ortak anahtara*(ortak anahtar şifrelemeden) göre bölündüğü yerdir.</span><span class="sxs-lookup"><span data-stu-id="5a587-419">The way public key encryption works is that the key (in the private-key encryption sense described above) is split into two parts, a *private key* and a *public key*, from where public key encryption gets its name.</span></span> <span data-ttu-id="5a587-420">Kavram şifre çözme için kullanıldığında, bu anahtarlardan biri şifreleme için kullanılır (genellikle ortak anahtardır).</span><span class="sxs-lookup"><span data-stu-id="5a587-420">The concept is that one of these keys (typically the public key) is used for encryption, while the other is used for decryption.</span></span> <span data-ttu-id="5a587-421">Bu anahtar asymmetry, ortak anahtar şifrelemesi için diğer adın nedenidir: *asimetrik şifreleme*.</span><span class="sxs-lookup"><span data-stu-id="5a587-421">This asymmetry of keys is the reason for the other name for public key encryption: *asymmetric encryption*.</span></span>

<span data-ttu-id="5a587-422">Ortak anahtar şifrelemesi, büyük bir karmaşıkdır, ancak genel anahtar şifreleme için *yalnızca* şifreleme için kullanılabilir ve bu anahtarın, şifrelenmiş verilerin elde etmesine izin vermez.</span><span class="sxs-lookup"><span data-stu-id="5a587-422">The mathematics behind public key encryption are fairly complex, but the idea is that the public key can *only* be used for encryption, and obtaining that key does not allow encrypted data to be obtained.</span></span> <span data-ttu-id="5a587-423">Özel anahtar, sırasıyla ortak anahtar kullanılarak şifrelenmiş verilerin şifresinin çözülmesi için tek yoldur.</span><span class="sxs-lookup"><span data-stu-id="5a587-423">The private key, in turn, is the only way to decrypt data encrypted using the public key.</span></span> <span data-ttu-id="5a587-424">Bu nedenle, özel anahtar gizliliğini koruyarak, bu özel anahtarın sahibi ile güvenli bir şekilde iletişim kurmak isteyen herkes yalnızca ilgili ortak anahtarla verilerini, yalnızca söz konusu özel anahtarı elinde bulunan birinin güvenli verileri elde edebilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-424">Thus, by keeping the private key secret, anyone wishing to communicate securely with the owner of that private key need only encrypt their data with the corresponding public key with the knowledge that only someone in possession of that private key can obtain the secure data.</span></span>

<span data-ttu-id="5a587-425">NetX güvenli TLS, RSA ortak anahtar şifrelemesini destekler.</span><span class="sxs-lookup"><span data-stu-id="5a587-425">NetX Secure TLS supports RSA public-key encryption.</span></span>

> [!IMPORTANT] 
> <span data-ttu-id="5a587-426">*RSA, yazılım RSA uygulamasının kullanılması durumunda işlemciyi yoğun bir işlemdir. Daha büyük anahtar boyutları, anahtar boyutunda 2X artışla daha yavaş bir kare faktörü için gereken işlem gücünü artırır.*</span><span class="sxs-lookup"><span data-stu-id="5a587-426">*RSA is a very processor-intensive operation if the software RSA implementation is used. Larger key sizes increase the processing power required by a square factor – 4X slower for a 2X increase in key size.*</span></span>

### <a name="public-key-authentication"></a><span data-ttu-id="5a587-427">Public-Key kimlik doğrulaması</span><span class="sxs-lookup"><span data-stu-id="5a587-427">Public-Key Authentication</span></span>

<span data-ttu-id="5a587-428">Ortak anahtar şifreleme kavramının ilgi çekici bir etkisi, işlemi tersten yaparak, kimlik doğrulamanın yanı sıra, *özel* anahtar kullanarak şifreleme ve *ortak* anahtar kullanarak şifre çözme sağlamak için de kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-428">An interesting side-effect of the public-key encryption concept is that it can be used to provide authentication as well as encryption by doing the operation in reverse: encrypting using the *private* key and decrypting using the *public* key.</span></span> <span data-ttu-id="5a587-429">Bunu yapmanın gerçek mekanizması, kullanılan ortak anahtar algoritmasına bağlıdır, ancak kavram aynıdır.</span><span class="sxs-lookup"><span data-stu-id="5a587-429">The actual mechanism for doing this depends on the public key algorithm being used, but the concept is the same.</span></span>

<span data-ttu-id="5a587-430">Ortak anahtar kimlik doğrulamasını kullanarak kimlik doğrulaması yapmak için, özel bir anahtarın sahibi, bu özel anahtarı kullanarak bazı veri parçasını (genellikle kimlik doğrulaması yapılacak verilerin bir şifreleme karması) şifreler.</span><span class="sxs-lookup"><span data-stu-id="5a587-430">To authenticate using public key authentication, the owner of a private key encrypts some piece of data (typically a cryptographic hash of the data to be authenticated) using that private key.</span></span> <span data-ttu-id="5a587-431">Daha sonra, verilerin şifresini çözmek için ilişkili ortak anahtarı kullanır. şifre çözme başarılı olursa ve kullanıcının bu ortak anahtarın geçerliliğini güvenilir kabul edersek, Kullanıcı, verilerin özel anahtar sahibinden geldiğinden emin olabilir ve bu durumda Kullanıcı, verilerin özel anahtarın sahibinden geldiğinden emin olabilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-431">Then, someone wishing to authenticate that the data came from the owner of the private key uses the associated public key to decrypt the data – if the decryption is successful, and assuming the user trusted the validity of that public key, then the user can be certain that the data came from the owner of the private key.</span></span>

<span data-ttu-id="5a587-432">TLS 'de ortak anahtar kimlik doğrulaması, güvenilen sertifika deposundan ortak anahtarları kullanarak bir TLS sunucusu (ve isteğe bağlı olarak TLS istemcisi) tarafından belirtilen dijital sertifikanın geçerliliğini doğrulamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="5a587-432">In TLS, public key authentication is used to verify the validity of a digital certificate provided by a TLS server (and optionally the TLS client) using public keys from the trusted certificate store.</span></span> <span data-ttu-id="5a587-433">Sertifika, depodaki bir ortak anahtara göre denetlenir ve sertifikadaki veriler sunucunun kimliğini denetlemek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="5a587-433">The certificate is checked against a public key in the store and the data in the certificate is used to check the identity of the server.</span></span>

<span data-ttu-id="5a587-434">NetX güvenli TLS, RSA kimlik doğrulamasını destekler.</span><span class="sxs-lookup"><span data-stu-id="5a587-434">NetX Secure TLS supports RSA authentication.</span></span>

### <a name="cryptographic-hashing"></a><span data-ttu-id="5a587-435">Şifreleme karması</span><span class="sxs-lookup"><span data-stu-id="5a587-435">Cryptographic Hashing</span></span>

<span data-ttu-id="5a587-436">Şifreleme, TLS 'de kullanılan tek şifreleme işlemi değildir.</span><span class="sxs-lookup"><span data-stu-id="5a587-436">Encryption is not the only cryptographic operation used in TLS.</span></span> <span data-ttu-id="5a587-437">Bir TLS oturumu sırasında ileti bütünlüğü sağlamak için ileti içeriğinin değiştirilmediğinden emin olmak için bir sağlama toplamı gerekir.</span><span class="sxs-lookup"><span data-stu-id="5a587-437">In order to provide message integrity during a TLS session, a checksum is needed to ensure that the message contents have not been tampered with.</span></span> <span data-ttu-id="5a587-438">Ancak, basit bir sağlama toplamı (TCP 'de kullanıldığı gibi), güvenli olmayan bir saldırgan tarafından kolayca bir şekilde sallandığından, kabul edilebilir bir bütünlük düzeyini güvence altına almak için yetersizdir.</span><span class="sxs-lookup"><span data-stu-id="5a587-438">However, a simple checksum (as is used in TCP) is insufficient to guarantee an acceptable level of integrity as it can be easily subverted by a knowledgeable attacker.</span></span> <span data-ttu-id="5a587-439">TLS tarafından ileti bütünlüğü sağlamak için kullanılan mekanizma *şifreleme karması* olarak bilinir.</span><span class="sxs-lookup"><span data-stu-id="5a587-439">The mechanism used by TLS to provide message integrity is known as a *cryptographic hash*.</span></span>

<span data-ttu-id="5a587-440">Şifreleme bir 1:1 kodlamadır. Yani, özgün verilerin tamamı şifrelenmiş verilerden elde edilebilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-440">Encryption is a 1:1 encoding – that is, the entirety of the original data can be obtained from the encrypted data.</span></span> <span data-ttu-id="5a587-441">Ancak, karma, bir sağlama toplamı gibi rastgele bir veri miktarını sabit boyutlu bir değere eşler.</span><span class="sxs-lookup"><span data-stu-id="5a587-441">However, a hash maps an arbitrary amount of data into a fixed size value, just like a checksum.</span></span> <span data-ttu-id="5a587-442">Basit bir sağlama sağlamasının aksine, karma özellikle, farklı giriş verilerinin aynı çıkışa neden olduğu *çarpışmaları* azaltmak için tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="5a587-442">Unlike a simple checksum, a hash is specifically designed to reduce *collisions*, where different input data result in the same output.</span></span> <span data-ttu-id="5a587-443">Basit bir sağlama toplamı içinde, bir bit 1 ' den 0 ' a ve 0 ' dan 1 ' e kadar bir bit 'e çevrilayarlanırsa, sağlama toplamı aynı olur.</span><span class="sxs-lookup"><span data-stu-id="5a587-443">In a simple checksum, if a bit is flipped from 1 to 0 and another bit from 0 to 1, the checksum is the same.</span></span> <span data-ttu-id="5a587-444">Bir şifreleme karması sayesinde, çıkış önemli ölçüde farklılık gösterir, böylece bir saldırgan karma verileri değiştirebilir ve değiştirilen verilerde karma işlemin yine de aynı değer elde edilmesine (ve bu sayede bu verilerin bütünlüğünü doğrulamaya) olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="5a587-444">With a cryptographic hash, the output would differ significantly, making it difficult for an attacker to change the hashed data and have the hash operation on the changed data still result in the same value (and thus falsely verifying the integrity of that data).</span></span>

<span data-ttu-id="5a587-445">TLS, her iki uygulama iletisi ve TLS denetim iletisi iletileri için bütünlük sağlamak üzere birçok farklı karma algoritma kullanır.</span><span class="sxs-lookup"><span data-stu-id="5a587-445">TLS uses a number of different hash algorithms to provide integrity for messages, both application messages and TLS control messages.</span></span> <span data-ttu-id="5a587-446">Bunlara MD5, SHA-1 ve SHA-256 dahildir.</span><span class="sxs-lookup"><span data-stu-id="5a587-446">These include MD5, SHA-1 and SHA-256.</span></span>

<span data-ttu-id="5a587-447">NetX güvenli TLS, MD5, SHA-1 ve SHA-256 karma 'ı destekler.</span><span class="sxs-lookup"><span data-stu-id="5a587-447">NetX Secure TLS supports MD5, SHA-1, and SHA-256 hashing.</span></span>

## <a name="tls-extensions"></a><span data-ttu-id="5a587-448">TLS uzantıları</span><span class="sxs-lookup"><span data-stu-id="5a587-448">TLS Extensions</span></span>

<span data-ttu-id="5a587-449">TLS, belirli uygulamalar için ek işlevsellik sağlayan birkaç uzantı sağlar.</span><span class="sxs-lookup"><span data-stu-id="5a587-449">TLS provides a number of extensions that provide additional functionality for certain applications.</span></span> <span data-ttu-id="5a587-450">Bu uzantılar tipik olarak, bir uzak ana bilgisayara bir uzantı kullanmayı veya güvenli TLS oturumu oluştururken kullanılmak üzere ek ayrıntılar sağlamayı belirten ClientHello veya ServerHello iletilerinin bir parçası olarak gönderilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-450">These extensions are typically sent as part of the ClientHello or ServerHello messages, indicating to a remote host the desire to use an extension or providing additional details for use in establishing the secure TLS session.</span></span>

<span data-ttu-id="5a587-451">Genel olarak, uzantılar, işlem işlemlerine kılavuzluk eden el sıkışma başlangıcında TLS için isteğe bağlı parametreler sağlar.</span><span class="sxs-lookup"><span data-stu-id="5a587-451">In general, extensions provide optional parameters to TLS at the beginning of the handshake that guide the proceeding operations.</span></span> <span data-ttu-id="5a587-452">Bazı uzantılar uygulama girişi veya karar oluşturma gerektirir, diğerleri otomatik olarak işlenir.</span><span class="sxs-lookup"><span data-stu-id="5a587-452">Some extensions require application input or decision making, while others are handled automatically.</span></span>

<span data-ttu-id="5a587-453">Aşağıdaki tabloda, şu anda NetX güvenli TLS tarafından desteklenen TLS uzantıları açıklanmaktadır:</span><span class="sxs-lookup"><span data-stu-id="5a587-453">The following table describes the TLS extensions currently supported by NetX Secure TLS:</span></span>

| <span data-ttu-id="5a587-454">**Uzantı adı**</span><span class="sxs-lookup"><span data-stu-id="5a587-454">**Extension Name**</span></span>              | <span data-ttu-id="5a587-455">**Açıklama**</span><span class="sxs-lookup"><span data-stu-id="5a587-455">**Description**</span></span>              |
| ------------------------------- |----------------------------- |
| <span data-ttu-id="5a587-456">Güvenli yeniden anlaşma gösterimi</span><span class="sxs-lookup"><span data-stu-id="5a587-456">Secure Renegotiation Indication</span></span> | <span data-ttu-id="5a587-457">Bu uzantı, bir yeniden anlaşma el sıkışması sırasında oluşabilecek bir ortadaki adam saldırısı güvenlik açığını azaltır.</span><span class="sxs-lookup"><span data-stu-id="5a587-457">This extension mitigates a Man-in-the-Middle attack vulnerability that could occur during a renegotiation handshake.</span></span>|
| <span data-ttu-id="5a587-458">Sunucu Adı Belirtme</span><span class="sxs-lookup"><span data-stu-id="5a587-458">Server Name Indication</span></span>          | <span data-ttu-id="5a587-459">Bu uzantı, bir TLS Istemcisinin bir TLS sunucusuna belirli bir DNS adı sağlamasına izin vererek sunucunun doğru kimlik bilgilerini seçmesini sağlar (sunucunun birden çok kimlik sertifikası ve ağ entryPoints olduğunu varsayar).</span><span class="sxs-lookup"><span data-stu-id="5a587-459">This extension allows a TLS Client to supply a specific DNS name to a TLS Server, allowing the server to select the correct credentials (assumes the server has multiple identity certificates and network entrypoints).</span></span> |
| <span data-ttu-id="5a587-460">İmza algoritmaları</span><span class="sxs-lookup"><span data-stu-id="5a587-460">Signature Algorithms</span></span>            | <span data-ttu-id="5a587-461">Bu uzantı, TLS Istemcisinin kabul edilebilir imza ve karma algoritmalarının bir TLS sunucusuna bir listesini sağlamasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="5a587-461">This extension enables a TLS Client to provide a list of acceptable signature and hash algorithms to a TLS Server.</span></span> |

<span data-ttu-id="5a587-462">Desteklenen TLS uzantılarına genel bakış</span><span class="sxs-lookup"><span data-stu-id="5a587-462">Overview of supported TLS Extensions</span></span>

### <a name="secure-renegotiation-indication"></a><span data-ttu-id="5a587-463">Güvenli yeniden anlaşma gösterimi</span><span class="sxs-lookup"><span data-stu-id="5a587-463">Secure Renegotiation Indication</span></span>

<span data-ttu-id="5a587-464">TLS, mevcut bir TLS oturumunda el sıkışma gerçekleştirme kavramını destekler, böylece el sıkışma iletilerini şifrelemek için belirlenen oturum vardır.</span><span class="sxs-lookup"><span data-stu-id="5a587-464">TLS supports the notion of performing a handshake within an existing TLS session, thereby using the established session to encrypt the handshake messages.</span></span> <span data-ttu-id="5a587-465">Bu işlem, şifreleme oturumu anahtarlarının TLS oturumunu sonlandırmadan yeniden oluşturulmasına izin verir (bkz. "TLS oturumu yeniden anlaşması").</span><span class="sxs-lookup"><span data-stu-id="5a587-465">This process allows the cryptographic session keys to be re-established without ending the TLS session (see section "TLS Session Renegotiation").</span></span>

<span data-ttu-id="5a587-466">Ne yazık ki, TLS yeniden anlaşma bir süre kullandıktan sonra, yeniden anlaşma özelliğinden yararlanan bir ortadaki adam saldırısında bir güvenlik açığı olduğunu bulmuştur.</span><span class="sxs-lookup"><span data-stu-id="5a587-466">Unfortunately, after TLS had been using renegotiation for some time, it was discovered that there was a vulnerability to a Man-in-the-Middle attack that exploited the renegotiation feature.</span></span> <span data-ttu-id="5a587-467">Güvenlik açığını kapatmak için, güvenli yeniden anlaşma gösterge uzantısı eklenmiştir.</span><span class="sxs-lookup"><span data-stu-id="5a587-467">To close the vulnerability, the Secure Renegotiation Indication extension was introduced.</span></span> <span data-ttu-id="5a587-468">Temelde, güvenli yeniden anlaşma uzantısı, başlangıçtaki ana bilgisayarların yeniden anlaşma el sıkışmasına katıldığını doğrulamak için, oluşturulan bağlantıdan tamamlanmış ileti karmasını kullanır – aslında karma, bir saldırganın karmayı yasaklayacağından (oturum anahtarlarına erişim gerektirir) bir doğrulama belirteci olarak kullanılır.</span><span class="sxs-lookup"><span data-stu-id="5a587-468">Essentially, the Secure Renegotiation extension uses the Finished message hash from the established connection to verify that the original hosts are participating in the renegotiation handshake – essentially the hash is used as a verification token under the assumption that an attacker would not be able to forge the hash (which would require access to the session keys).</span></span>

<span data-ttu-id="5a587-469">NetX güvenli TLS yeniden anlaşmayı otomatik olarak işler ve varsayılan olarak güvenli yeniden anlaşma uzantısını kullanır.</span><span class="sxs-lookup"><span data-stu-id="5a587-469">NetX Secure TLS handles renegotiation automatically and uses the Secure Renegotiation Extension by default.</span></span> <span data-ttu-id="5a587-470">Uygulama etkileşimi gerekmez.</span><span class="sxs-lookup"><span data-stu-id="5a587-470">No application interaction is required.</span></span>

### <a name="server-name-indication"></a><span data-ttu-id="5a587-471">Sunucu Adı Belirtme</span><span class="sxs-lookup"><span data-stu-id="5a587-471">Server Name Indication</span></span>

<span data-ttu-id="5a587-472">TLS anlaşması sırasında, bir TLS Istemcisi, istemcinin kimliğini doğrulayabilmesi için uzak sunucunun kimlik sertifikası sağlamasını bekler.</span><span class="sxs-lookup"><span data-stu-id="5a587-472">During the TLS handshake, a TLS Client expects a remote server to provide an identity certificate so the client can authenticate the server.</span></span> <span data-ttu-id="5a587-473">Ancak, bir sunucunun benzersiz kimliklere sahip farklı "sanal" sunucularla birden çok farklı hizmet sağlayacağı bazı durumlar olabilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-473">However, there may be some cases where a server will provide multiple different services with different "virtual" servers each having unique identities.</span></span> <span data-ttu-id="5a587-474">Birden çok kimliği olan tek bir sunucu söz konusu olduğunda, bir TLS istemcisi sunucunun uygun kimlik bilgilerini seçmek için kullanacağı belirli bir DNS adı sağlayabilir. bu adı sağlamaya yönelik mekanizma Sunucu Adı Belirtme (SNı) uzantısıdır.</span><span class="sxs-lookup"><span data-stu-id="5a587-474">In the case of a single server with multiple identities, a TLS client can supply a specific DNS name that the server will use to select the proper credentials – the mechanism for supplying this name is the Server Name Indication (SNI) extension.</span></span>

<span data-ttu-id="5a587-475">SNı uzantısını kullanan bir uygulama için bazı etkileşimler gereklidir.</span><span class="sxs-lookup"><span data-stu-id="5a587-475">For an application using the SNI extension, some interaction is required.</span></span> <span data-ttu-id="5a587-476">TLS Istemcileri için, uygulamanın uzak sunucuya gönderilmesi için bir DNS adı sağlaması gerekir.</span><span class="sxs-lookup"><span data-stu-id="5a587-476">For TLS Clients, the application must supply a DNS name to be sent to the remote server.</span></span> <span data-ttu-id="5a587-477">TLS sunucuları için, uygulamanın uzantısından DNS adını okuması ve istemciye geri göndermek için uygun bir sertifika seçmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="5a587-477">For TLS Servers, the application must read the DNS name from the extension and select an appropriate certificate to send back to the client.</span></span>

<span data-ttu-id="5a587-478">Aşağıdaki bölümler NetX güvenli TLS 'de SNı uzantısının nasıl kullanılacağına ilişkin daha fazla ayrıntı sağlar.</span><span class="sxs-lookup"><span data-stu-id="5a587-478">The following sections provide more detail on how to use the SNI extension in NetX Secure TLS.</span></span>

### <a name="sni-extension--tls-client"></a><span data-ttu-id="5a587-479">SNı uzantısı – TLS Istemcisi</span><span class="sxs-lookup"><span data-stu-id="5a587-479">SNI Extension – TLS Client</span></span>

<span data-ttu-id="5a587-480">SNı uzantısını kullanmak isteyen bir NetX güvenli TLS Istemcisinin, el sıkışma sırasında sağlanacak bir DNS adını, TLS 'ye sağlaması gerekir.</span><span class="sxs-lookup"><span data-stu-id="5a587-480">A NetX Secure TLS Client wishing to use the SNI extension must provide a DNS name to TLS to be supplied during the handshake.</span></span> <span data-ttu-id="5a587-481">Uzantı, el sıkışma işlemini başlatan ClientHello iletisinde gönderildiği için, bir TLS oturumu başlatılmadan önce bu adın başlatılmış ve sağlanması gerekir.</span><span class="sxs-lookup"><span data-stu-id="5a587-481">This name must be initialized and supplied prior to starting a TLS session since the extension is sent in the ClientHello message which starts the handshake process.</span></span>

<span data-ttu-id="5a587-482">Aşağıdaki kod parçacığı, uzantısının kullanımını gösterir.</span><span class="sxs-lookup"><span data-stu-id="5a587-482">The following code snippet illustrates the use of the extension.</span></span> <span data-ttu-id="5a587-483">İlk olarak, NX_SECURE_X509_DNS_NAME bir nesne istenen sunucu adı ile başlatılır.</span><span class="sxs-lookup"><span data-stu-id="5a587-483">First, a NX_SECURE_X509_DNS_NAME object is initialized with the desired server name.</span></span> <span data-ttu-id="5a587-484">Daha sonra, TLS oturumuna başlamadan önce, adı SNı uzantısı API 'SI kullanılarak TLS olarak sağlanır.</span><span class="sxs-lookup"><span data-stu-id="5a587-484">Then, prior to starting the TLS session, the name is provided to TLS using the SNI extension API.</span></span> <span data-ttu-id="5a587-485">Ad ayarlandıktan sonra, başka bir eylem gerekmez.</span><span class="sxs-lookup"><span data-stu-id="5a587-485">Once the name is set, no further action is required.</span></span> <span data-ttu-id="5a587-486">Bölüm 4 ' te API başvurusuna bakın</span><span class="sxs-lookup"><span data-stu-id="5a587-486">See the API reference in Chapter 4</span></span>  
  
<span data-ttu-id="5a587-487">Ayrı işlevler hakkında daha fazla bilgi için NetX güvenli hizmetlerinin açıklaması.</span><span class="sxs-lookup"><span data-stu-id="5a587-487">Description of NetX Secure Services for more information on the individual functions.</span></span>

```C
/* The dns_name variable will contain our desired server name. */
UINT status;
NX_SECURE_X509_DNS_NAME dns_name;

/* Initialize the server DNS name. */
status = nx_secure_x509_dns_name_initialize(&dns_name, "www.example.com", 
                                            strlen("www.example.com"));


/* Initialize SNI extension in previously-initialized TLS Session. */
status = nx_secure_tls_session_sni_extension_set(&client_tls_session, &dns_name);

/* Now start the TLS session, starting with establishing the TCP connection – if 
   TLS is started before initializing the SNI extension, the extension will not be 
   sent in the ClientHello message! */
status = nx_tcp_client_socket_connect(&client_socket, IP_ADDRESS(1, 2, 3, 4), 443, 
                                      5 * NX_IP_PERIODIC_RATE);

status = nx_secure_tls_session_start(&client_tls_session, &client_socket, 
                                     NX_WAIT_FOREVER);
```
### <a name="sni-extension--tls-server"></a><span data-ttu-id="5a587-488">SNı uzantısı – TLS sunucusu</span><span class="sxs-lookup"><span data-stu-id="5a587-488">SNI Extension – TLS Server</span></span>

<span data-ttu-id="5a587-489">TLS sunucu tarafında, el sıkışma sırasında uzak istemciye sağlanacak uygun kimlik bilgilerini (örn. sertifika) seçmek için, SNı uzantısı uygulama tarafından işlenebilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-489">On the TLS Server side, the SNI extension may be processed by the application in order to select proper credentials (e.g. certificate) to provide to the remote client during the handshake.</span></span> <span data-ttu-id="5a587-490">Bunu yapmak için, uygulamanın bir ClientHello iletisinin alındığını izleyerek çağrılan bir oturum geri çağırması sağlaması gerekir.</span><span class="sxs-lookup"><span data-stu-id="5a587-490">To do this, the application must supply a session callback which is invoked following the receipt of a ClientHello message.</span></span>

<span data-ttu-id="5a587-491">Nx_secure_tls_session_server_callback_set API 'sinin örnek kodu (bkz. sayfa 122), bir sunucu geri çağırması kullanılarak gelen bir SNı uzantısının ayrıştırılmasını gösterir.</span><span class="sxs-lookup"><span data-stu-id="5a587-491">The example code for the nx_secure_tls_session_server_callback_set API  (see page 122) illustrates the parsing of an incoming SNI extension using a server callback.</span></span> <span data-ttu-id="5a587-492">Temelde, TLS sunucusu bir ClientHello alır ve geri çağırma işlemini çağırır.</span><span class="sxs-lookup"><span data-stu-id="5a587-492">Essentially, the TLS Server receives a ClientHello and invokes the callback.</span></span> <span data-ttu-id="5a587-493">Ardından uygulama, SNı uzantısını bulmak için geri aramaya sağlanan uzantı verilerini ayrıştırmak ve sağlanan DNS adını döndürmek için *nx_secure_tls_session_sni_extension_parse* API 'sini kullanır (uzantının yalnızca tek bir DNS adını desteklediğini unutmayın).</span><span class="sxs-lookup"><span data-stu-id="5a587-493">Then the application uses the *nx_secure_tls_session_sni_extension_parse* API to parse the extension data provided to the callback to find the SNI extension and return the supplied DNS name (note that the extension only supports a single DNS name).</span></span> <span data-ttu-id="5a587-494">Ad alındıktan sonra uygulama, uygun sunucu kimlik sertifikasını (ve uygulanabilirse veren zincirini) bulmak ve göndermek için onu kullanır.</span><span class="sxs-lookup"><span data-stu-id="5a587-494">Once the name is obtained, the application uses it to find and send the appropriate server identity certificate (and issuer chain if applicable).</span></span>

### <a name="signature-algorithms-extension"></a><span data-ttu-id="5a587-495">İmza algoritmaları uzantısı</span><span class="sxs-lookup"><span data-stu-id="5a587-495">Signature Algorithms Extension</span></span>

<span data-ttu-id="5a587-496">Bu uzantı TLS 1,2 ' e özgüdür ve bir TLS Istemcisinin dijital imzaları oluşturma ve doğrulama için kabul edilebilir kabul edilebilir imza ve karma algoritma çiftlerinin bir listesini sağlamasına izin verir.</span><span class="sxs-lookup"><span data-stu-id="5a587-496">This extension is specific to TLS 1.2 and allows a TLS Client to provide a list of acceptable signature and hash algorithm pairs that are acceptable for use in generating and verifying digital signatures.</span></span> <span data-ttu-id="5a587-497">Liste, *nx_secure_tls_session_create* için sağlanan şifre tablosunu kullanan TLS Istemcileri Için NETX güvenli TLS tarafından otomatik olarak oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="5a587-497">The list is generated automatically by NetX Secure TLS for TLS Clients using the cipher table supplied to *nx_secure_tls_session_create*.</span></span> <span data-ttu-id="5a587-498">Uygulama etkileşimi gerekmez.</span><span class="sxs-lookup"><span data-stu-id="5a587-498">No application interaction is required.</span></span>

## <a name="authentication-methods"></a><span data-ttu-id="5a587-499">Kimlik Doğrulaması Yöntemleri</span><span class="sxs-lookup"><span data-stu-id="5a587-499">Authentication Methods</span></span>

<span data-ttu-id="5a587-500">TLS, güvenli olmayan bir ağ üzerinden iki cihaz arasında güvenli bir bağlantı kurmak için çerçeve sağlar, ancak sorunun bir parçası bu bağlantının diğer ucundaki cihazın kimliğini öğrenmektir.</span><span class="sxs-lookup"><span data-stu-id="5a587-500">TLS provides the framework for establishing a secure connection between two devices over an insecure network, but part of the problem is knowing the identity of the device on the other end of that connection.</span></span> <span data-ttu-id="5a587-501">Uzak ana bilgisayarların kimliğini doğrulamak için bir mekanizma olmadan, saldırganın güvenilen bir cihaz olarak oluşturabileceği önemsiz bir işlem haline gelir.</span><span class="sxs-lookup"><span data-stu-id="5a587-501">Without a mechanism for authenticating the identity of remote hosts, it becomes a trivial operation for an attacker to pose as a trusted device.</span></span>

<span data-ttu-id="5a587-502">Başlangıçta, IP adreslerini, donanım MAC adreslerini veya DNS 'yi kullanarak, bir ağdaki Konakları tanımlamak için görece yüksek düzeyde güven sağlayabilir, ancak TCP/IP teknolojisinin doğası ve adreslerin sızması ve DNS girdilerinin bozulmuş olması (örneğin, DNS önbelleği kirlenmesi aracılığıyla), TLS 'nin sahte kimliklere karşı ek bir koruma katmanı gerektirdiğinden emin olur.</span><span class="sxs-lookup"><span data-stu-id="5a587-502">Initially, it may seem that using IP addresses, hardware MAC addresses, or DNS would provide a relatively high level of confidence for identifying hosts on a network, but given the nature of TCP/IP technology and the ease with which addresses can be spoofed and DNS entries corrupted (e.g. through DNS cache poisoning), it becomes clear that TLS needs an additional layer of protection against fraudulent identities.</span></span>

<span data-ttu-id="5a587-503">Bu ek kimlik doğrulama katmanını TLS için sağlayabilecek çeşitli mekanizmalar vardır ancak en sık kullanılan *dijital sertifikadır.*</span><span class="sxs-lookup"><span data-stu-id="5a587-503">There are various mechanisms that can provide this extra layer of authentication for TLS, but the most common is the *digital certificate.*</span></span> <span data-ttu-id="5a587-504">Diğer mekanizmalarda önceden paylaşılan anahtarlar (PSK) ve parola şemaları bulunur.</span><span class="sxs-lookup"><span data-stu-id="5a587-504">Other mechanisms include Pre-Shared Keys (PSK) and password schemes.</span></span>

### <a name="digital-cerificates"></a><span data-ttu-id="5a587-505">Dijital sertifika</span><span class="sxs-lookup"><span data-stu-id="5a587-505">Digital Cerificates</span></span>

<span data-ttu-id="5a587-506">Dijital sertifikalar, TLS 'de uzak ana bilgisayarın kimliğini doğrulamak için en sık kullanılan yöntemdir.</span><span class="sxs-lookup"><span data-stu-id="5a587-506">Digital certificates are the most common method for authenticating a remote host in TLS.</span></span> <span data-ttu-id="5a587-507">Esas olarak, dijital sertifika, bir bilgisayar ağındaki bir cihaz için kimlik bilgileri sağlayan belirli bir biçimlendirmeye sahip bir belgedir.</span><span class="sxs-lookup"><span data-stu-id="5a587-507">Essentially, a digital certificate is a document with specific formatting that provides identity information for a device on a computer network.</span></span>

<span data-ttu-id="5a587-508">TLS, normalde Uluslararası Telekomünikasyon birleşimi tarafından geliştirilen standart olan X. 509.440 adlı bir biçim kullanır, ancak TLS ana bilgisayarları kullanılan biçimde kabul ediyorsanız başka sertifika biçimleri de kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-508">TLS normally uses a format called X.509, a standard developed by the International Telecommunication Union, though other formats of certificates may be used if the TLS hosts can agree on the format being used.</span></span> <span data-ttu-id="5a587-509">X. 509.440, sertifikalar için belirli bir biçimi ve dijital bir belge oluşturmak için kullanılabilecek çeşitli kodlamaları tanımlar.</span><span class="sxs-lookup"><span data-stu-id="5a587-509">X.509 defines a specific format for certificates and various encodings that can be used to produce a digital document.</span></span> <span data-ttu-id="5a587-510">TLS ile kullanılan en X. 509.440 sertifikaları, farklı bir telekomünikasyon standardı olan ASN. 1 ' in bir türevi kullanılarak kodlanır.</span><span class="sxs-lookup"><span data-stu-id="5a587-510">Most X.509 certificates used with TLS are encoded using a variant of ASN.1, another telecommunications standard.</span></span> <span data-ttu-id="5a587-511">ASN. 1 içinde çeşitli dijital kodlamalar vardır ancak TLS sertifikaları için en yaygın kodlama Distinguished Encoding Rules (DER) standardıdır.</span><span class="sxs-lookup"><span data-stu-id="5a587-511">Within ASN.1 there are various digital encodings, but the most common encoding for TLS certificates is the Distinguished Encoding Rules (DER) standard.</span></span> <span data-ttu-id="5a587-512">DER, ASN. 1 temel kodlama kuralları 'nın (BER), belirsiz olacak şekilde tasarlanan, ayrıştırmayı kolaylaştırmak için basitleştirilmiş bir alt kümesidir.</span><span class="sxs-lookup"><span data-stu-id="5a587-512">DER is a simplified subset of the ASN.1 Basic Encoding Rules (BER) that is designed to be unambiguous, making parsing easier.</span></span> <span data-ttu-id="5a587-513">Kablo üzerinden, TLS sertifikaları genellikle ikili DER olarak kodlanır ve bu, NetX Secure 'ın X. 509.440 sertifikalarını beklediği biçimdedir.</span><span class="sxs-lookup"><span data-stu-id="5a587-513">Over the wire, TLS certificates are usually encoded in binary DER, and this is the format that NetX Secure expects for X.509 certificates.</span></span>

<span data-ttu-id="5a587-514">DER biçimli ikili sertifikalar gerçek TLS protokolünde kullanılıyor olsa da, bunlar. pek,. CRT ve. p12 gibi dosya uzantılarına sahip bir dizi farklı kodlarda oluşturulup depolanabilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-514">Though DER-formatted binary certificates are used in the actual TLS protocol, they may be generated and stored in a number of different encodings, with file extensions such as .pem, .crt, and .p12.</span></span> <span data-ttu-id="5a587-515">Farklı çeşitler farklı üreticilerin farklı uygulamaları tarafından kullanılır, ancak genel kullanıma sunulan araçlar kullanılarak tüm geliştiriciler DER 'a dönüştürülebilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-515">The different variants are used by different applications from different manufacturers, but generally all can be converted into DER using widely available tools.</span></span>

<span data-ttu-id="5a587-516">Alternatif sertifika kodlamaları en yaygın olarak ped 'dir.</span><span class="sxs-lookup"><span data-stu-id="5a587-516">The most common of the alternative certificate encodings is PEM.</span></span> <span data-ttu-id="5a587-517">PEK biçimi (Privacy-Enhanced mail 'den), kodlama, e-posta veya Web tabanlı protokoller kullanılarak kolayca gönderilebilecek yazdırılabilir metinle sonuçlandığından, genellikle kullanılan DER kodlamasının temel 64 kodlu bir sürümüdür.</span><span class="sxs-lookup"><span data-stu-id="5a587-517">The PEM format (from Privacy-Enhanced Mail) is a base-64 encoded version of the DER encoding that is often used because the encoding results in printable text that can be easily sent using email or web-based protocols.</span></span>

<span data-ttu-id="5a587-518">NetX güvenli uygulamanız için bir sertifika oluşturmak, genel olarak bu el ile kapsam dışındadır, ancak OpenSSL komut satırı aracı ([www.OpenSSL.org](http://www.openssl.org)) yaygın olarak kullanılabilir ve çoğu biçim arasında dönüştürülebilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-518">Generating a certificate for your NetX Secure application is generally outside the scope of this manual, but the OpenSSL command-line tool ([www.openssl.org](http://www.openssl.org)) is widely available and can convert between most formats.</span></span>

<span data-ttu-id="5a587-519">Uygulamanıza bağlı olarak, kendi sertifikalarınızı oluşturabilir, bir üretici veya devlet kurumuna sertifika verebilir veya ticari bir sertifika yetkilisinden sertifika satın alabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="5a587-519">Depending on your application, you may generate your own certificates, be provided certificates by a  manufacturer or government organization, or purchase certificates from a commercial certificate authority.</span></span>

<span data-ttu-id="5a587-520">NetX güvenli uygulamanızda dijital bir sertifika kullanmak için, önce sertifikanızı bir ikili DER biçimine dönüştürmeniz ve isteğe bağlı olarak, ilişkili özel anahtarı (RSA için "Private üs" i) ikili biçime, genellikle PKCS # 1 biçimli, DER kodlu bir RSA anahtarını veya DER kodlu bir ECC anahtarını dönüştürmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="5a587-520">To use a digital certificate in your NetX Secure application, you must first convert your certificate into a binary DER format and, optionally, convert the associated private key (the "private exponent" for RSA, for example) into a binary format, typically a PKCS#1-formatted, DER-encoded RSA key or a DER-encoded ECC key.</span></span> <span data-ttu-id="5a587-521">Dönüştürme işlemi tamamlandıktan sonra, sertifikayı ve özel anahtarı cihaza yüklemeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="5a587-521">Once the conversion is complete, it is up to you to load the certificate and private key onto the device.</span></span> <span data-ttu-id="5a587-522">Olası seçenekler, Flash tabanlı bir dosya sistemi kullanmayı veya verilerden bir C dizisi oluşturmayı (Linux 'tan "XXD" gibi bir araç kullanarak) ve sertifikayı ve anahtarı sabit veri olarak uygulamanıza derlemeyi içerir.</span><span class="sxs-lookup"><span data-stu-id="5a587-522">Possible options include using a flash-based file system or generating a C array from the data (using a tool such as "xxd" from Linux) and compiling the certificate and key into your application as constant data.</span></span>

<span data-ttu-id="5a587-523">Sertifikanız cihaza yüklendikten sonra, sertifikanızı bir TLS oturumuyla ilişkilendirmek için TLS API 'SI kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-523">Once your certificate is loaded onto the device, the TLS API can be used to associate your certificate with a TLS session.</span></span>

<span data-ttu-id="5a587-524">X. 509.440 sertifikalarının NetX güvenli TLS ile nasıl kullanılacağına ilişkin ayrıntılar ve örnekler için, "X. 509.440 sertifikalarını NetX güvenli olarak Içeri aktarma" bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="5a587-524">For details and examples on how to use X.509 certificates with NetX Secure TLS, see the section "Importing X.509 certificates into NetX Secure".</span></span>

<span data-ttu-id="5a587-525">Daha fazla bilgi için API başvurusunda aşağıdaki TLS hizmetlerine başvurun:</span><span class="sxs-lookup"><span data-stu-id="5a587-525">Refer to the following TLS services in the API reference for more information:</span></span>

- <span data-ttu-id="5a587-526">nx_secure_x509_certificate_initialize</span><span class="sxs-lookup"><span data-stu-id="5a587-526">nx_secure_x509_certificate_initialize</span></span>
- <span data-ttu-id="5a587-527">nx_secure_tls_local_certificate_add</span><span class="sxs-lookup"><span data-stu-id="5a587-527">nx_secure_tls_local_certificate_add</span></span>
- <span data-ttu-id="5a587-528">nx_secure_tls_local_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="5a587-528">nx_secure_tls_local_certificate_remove</span></span>
- <span data-ttu-id="5a587-529">nx_secure_tls_remote_certificate_allocate</span><span class="sxs-lookup"><span data-stu-id="5a587-529">nx_secure_tls_remote_certificate_allocate</span></span>
- <span data-ttu-id="5a587-530">nx_secure_tls_trusted_certificate_add</span><span class="sxs-lookup"><span data-stu-id="5a587-530">nx_secure_tls_trusted_certificate_add</span></span>
- <span data-ttu-id="5a587-531">nx_secure_trusted_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="5a587-531">nx_secure_trusted_certificate_remove</span></span>

### <a name="tls-client-certificate-specifics"></a><span data-ttu-id="5a587-532">TLS Istemci sertifikası özellikleri</span><span class="sxs-lookup"><span data-stu-id="5a587-532">TLS Client Certificate Specifics</span></span>

<span data-ttu-id="5a587-533">TLS Istemci uygulamaları genellikle cihaza bir "yerel" sertifika<sup>14</sup> ' ün yüklenmesini gerektirmez.</span><span class="sxs-lookup"><span data-stu-id="5a587-533">TLS Client implementations generally do not require a "local" certificate<sup>14</sup> to be loaded onto the device.</span></span> <span data-ttu-id="5a587-534">Bunun özel durumu, Istemci sertifikası kimlik doğrulamasının etkinleştirilme durumdur, ancak bu çok daha az yaygındır.</span><span class="sxs-lookup"><span data-stu-id="5a587-534">The exception to this is when Client Certificate Authentication is enabled, but this is far less common.</span></span>

<span data-ttu-id="5a587-535">TLS Istemcisi, en az bir "güvenilir" sertifika<sup>15</sup> ' in yüklenmesini (gerekirse daha fazla yüklenebilir) ve bir "uzak" sertifika<sup>16</sup> ' nın ayrılması için boşluk gerektirir.</span><span class="sxs-lookup"><span data-stu-id="5a587-535">A TLS Client requires at least one "trusted" certificate<sup>15</sup> to be loaded (more may be loaded if required), and space for a "remote" certificate<sup>16</sup> to be allocated.</span></span>

<span data-ttu-id="5a587-536">Güvenilen Sertifikalar ekleme ve uzak sertifikalara alan ayırma hakkında daha fazla bilgi için, şu hizmetler için TLS API başvurusuna bakın: nx_secure_tls_remote_certificate_allocate, nx_secure_tls_trusted_certificate_add.</span><span class="sxs-lookup"><span data-stu-id="5a587-536">For more information on adding trusted certificates and allocating space for remote certificates, see the TLS API reference for the following services: nx_secure_tls_remote_certificate_allocate, nx_secure_tls_trusted_certificate_add.</span></span>

14. <span data-ttu-id="5a587-537">"Yerel" sertifika, yerel cihazı tanımlayan bir sertifikadır; diğer bir deyişle, TLS uygulamasının yüklendiği cihaz için kimlik bilgileri sağlar.</span><span class="sxs-lookup"><span data-stu-id="5a587-537">A “local” certificate is a certificate that identifies the local device – that is, it provides identity information for the device upon which the TLS application is loaded.</span></span>

15. <span data-ttu-id="5a587-538">"Güvenilir" sertifika, uzak cihazın doğrudan veya bir ortak anahtar altyapısı (PKI) ile güven ve kimlik doğrulaması için temel sağlayan bir sertifikadır.</span><span class="sxs-lookup"><span data-stu-id="5a587-538">A “trusted” certificate is a certificate that provides a basis for trust and authentication of the remote device, either directly or through a Public Key Infrastructure (PKI).</span></span> <span data-ttu-id="5a587-539">Güven zincirinin köküne genellikle "sertifika yetkilisi" veya CA sertifikası denir.</span><span class="sxs-lookup"><span data-stu-id="5a587-539">The root of the chain of trust is usually called a “Certification Authority” or CA certificate.</span></span>

16. <span data-ttu-id="5a587-540">"Uzak" sertifika, TLS el sıkışması sırasında uzak ana bilgisayar tarafından gönderilen sertifikaya başvurur.</span><span class="sxs-lookup"><span data-stu-id="5a587-540">A “remote” certificate refers to the certificate sent by the remote host during the TLS handshake.</span></span> <span data-ttu-id="5a587-541">Bu uzak ana bilgisayar için kimlik sağlar ve yerel cihazdaki "güvenilir" bir sertifikayla karşılaştırarak doğrulanır.</span><span class="sxs-lookup"><span data-stu-id="5a587-541">It provides identity for that remote host and is authenticated by comparing it to a “trusted” certificate on the local device.</span></span>

### <a name="tls-server-certificate-specifics"></a><span data-ttu-id="5a587-542">TLS sunucu sertifikası özellikleri</span><span class="sxs-lookup"><span data-stu-id="5a587-542">TLS Server Certificate Specifics</span></span>

<span data-ttu-id="5a587-543">TLS sunucu uygulamaları genellikle "güvenilen" sertifikaların ayrılacak cihaza veya uzak sertifikalara yüklenmesini gerektirmez.</span><span class="sxs-lookup"><span data-stu-id="5a587-543">TLS Server implementations generally do not require "trusted" certificates to be loaded onto the device or remote certificates to be allocated.</span></span> <span data-ttu-id="5a587-544">Istemci sertifikası kimlik doğrulaması etkinleştirildiğinde bunun özel durumu (daha az yaygın).</span><span class="sxs-lookup"><span data-stu-id="5a587-544">The exception to this being when Client Certificate Authentication is enabled (this is less common).</span></span>

<span data-ttu-id="5a587-545">Bir TLS sunucusu, sunucunun kimliğini istemci için doğrulamak üzere TLS el sıkışması sırasında uzak istemciye sağlayabilmesi için bir "yerel" sertifikanın yüklenmesini gerektirir.</span><span class="sxs-lookup"><span data-stu-id="5a587-545">A TLS Server requires a "local" certificate to be loaded so the server can provide it to the remote client during the TLS handshake to authenticate the server to the client.</span></span>

<span data-ttu-id="5a587-546">NetX TLS sunucu uygulamalarıyla kullanılmak üzere yerel sertifikaları yükleme hakkında daha fazla bilgi için, aşağıdaki hizmetler için API başvurusuna bakın:</span><span class="sxs-lookup"><span data-stu-id="5a587-546">For more information about loading local certificates for use with NetX TLS server applications, see the API reference for the following services:</span></span> 
- <span data-ttu-id="5a587-547">nx_secure_tls_local_certificate_add,</span><span class="sxs-lookup"><span data-stu-id="5a587-547">nx_secure_tls_local_certificate_add,</span></span> 
- <span data-ttu-id="5a587-548">nx_secure_tls_local_certificate_remove.</span><span class="sxs-lookup"><span data-stu-id="5a587-548">nx_secure_tls_local_certificate_remove.</span></span>

### <a name="pre-shared-keys-psk"></a><span data-ttu-id="5a587-549">Önceden paylaşılan anahtarlar (PSK)</span><span class="sxs-lookup"><span data-stu-id="5a587-549">Pre-Shared Keys (PSK)</span></span>

<span data-ttu-id="5a587-550">TLS 'de kimlik doğrulaması sağlamaya yönelik alternatif bir mekanizma, önceden paylaşılan anahtarların (PSK) kavramsıdır.</span><span class="sxs-lookup"><span data-stu-id="5a587-550">An alternative mechanism for providing identification authentication in TLS is the notion of Pre-Shared Keys (PSK).</span></span> <span data-ttu-id="5a587-551">Bir PSK ciphersuite kullanılması, kaynak kısıtlı gömülü cihazlar için bir Boon, yoğun işlemci yoğunluklu ortak anahtar şifreleme işlemleri gereksinimini ortadan kaldırır.</span><span class="sxs-lookup"><span data-stu-id="5a587-551">Using a PSK ciphersuite removes the need to do the processor-intensive public-key encryption operations, a boon for resource-constrained embedded devices.</span></span> <span data-ttu-id="5a587-552">PSK, TLS el sıkışmasındaki sertifikayı değiştirir ve TLS oturum anahtarı oluşturma için şifrelenmiş ön ana gizli dizi yerine kullanılır.</span><span class="sxs-lookup"><span data-stu-id="5a587-552">The PSK replaces the certificate in the TLS handshake and is used in place of the encrypted Pre-Master Secret for TLS session key generation.</span></span>

<span data-ttu-id="5a587-553">PSK ciphersuites, bir TLS oturumu oluşturulmadan önce her iki cihazda de paylaşılan bir gizliliğin olması gerektiğini anlamıştır.</span><span class="sxs-lookup"><span data-stu-id="5a587-553">The PSK ciphersuites are limited in the sense that that a shared secret must be present on both devices before a TLS session can be established.</span></span> <span data-ttu-id="5a587-554">Bu, cihazların bir TLS PSK bağlantısı dışında bazı güvenli bir şekilde yüklenmiş olması gerektiği anlamına gelir. PSKs bir TLS PSK bağlantısı üzerinden güncelleştirilemeyebilir, ancak cihazın başka bir mekanizma aracılığıyla yüklenen bir PSK ile başlaması gerekir.</span><span class="sxs-lookup"><span data-stu-id="5a587-554">This means that the devices must have been loaded with that secret using some secure means other than a TLS PSK connection - PSKs may be updated over a TLS PSK connection, but the device must necessarily start with a PSK that is loaded through some other mechanism.</span></span> <span data-ttu-id="5a587-555">Örneğin, bir algılayıcı aygıtı ve ağ geçidi cihazı, sevk etmeden önce fabrikada PSKs ile veya PSK 'yi yüklemek için standart bir TLS bağlantısı (bir sertifika ile) kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-555">For example, a sensor device and its gateway device could be loaded with PSKs in the factory before shipping, or a standard TLS connection (with a certificate) could be used to load the PSK.</span></span>

<span data-ttu-id="5a587-556">PSK ciphersuites, RFC 4279 ' de açıklanan çeşitli biçimlerde gelir.</span><span class="sxs-lookup"><span data-stu-id="5a587-556">PSK ciphersuites come in a couple of forms, described in RFC 4279.</span></span> <span data-ttu-id="5a587-557">İlki, Standart TLS el sıkışmaları içinde sertifikada aktarılan ortak anahtarlarla aynı şekilde kullanılan RSA veya Diffie-Hellman anahtarlarını kullanır.</span><span class="sxs-lookup"><span data-stu-id="5a587-557">The first uses RSA or Diffie-Hellman keys which are used in the same manner as the public keys transmitted in the certificate in standard TLS handshakes.</span></span> <span data-ttu-id="5a587-558">Kaynak kısıtlı bir ortamda daha fazla kullanılan ikinci form, oturum anahtarlarını doğrudan oluşturmak için kullanılan bir PSK kullanır (örneğin, AES tarafından kullanılmak üzere), pahalı RSA veya Diffie-Hellman işlemlerinin kullanılmasını önler.</span><span class="sxs-lookup"><span data-stu-id="5a587-558">The second form, which is of more use in a resource-constrained environment, uses a PSK that is used to directly generate the session keys (for use by AES, for example), avoiding the use of the expensive RSA or Diffie-Hellman operations.</span></span>

<span data-ttu-id="5a587-559">NetX güvenli,, uygulamaların tüm ortak anahtar şifreleme kodunu ve bellek kullanımını kaldırmasını sağlayan PSK ciphersuites 'in ikinci biçimini destekler.</span><span class="sxs-lookup"><span data-stu-id="5a587-559">NetX Secure supports the second form of PSK ciphersuites, enabling applications to remove all public-key cryptography code and memory usage.</span></span> <span data-ttu-id="5a587-560">PSK kendisi bir AES anahtarı değil, ancak gerçek anahtarların oluşturulduğu bir parola gibi kabul edilebilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-560">The PSK itself is not an AES key, but can be considered as being more like a password from which the actual keys are generated.</span></span> <span data-ttu-id="5a587-561">PSK değeri ile ilgili olarak daha uzun değerler daha fazla güvenlik (parolalarla aynı şekilde) sağlayabilse de daha fazla kısıtlama vardır.</span><span class="sxs-lookup"><span data-stu-id="5a587-561">There are few restrictions on what the PSK value can be, though longer values will provide more security (same as with passwords).</span></span>

<span data-ttu-id="5a587-562">NetX güvenli uygulamanızla PSK 'yi kullanmak için, önce genel makro **NX_SECURE_ENABLE_PSK_CIPHERSUITES** tanımlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="5a587-562">To use PSK with your NetX Secure application, you must first define the global macro **NX_SECURE_ENABLE_PSK_CIPHERSUITES**.</span></span> <span data-ttu-id="5a587-563">Bu genellikle derleyici ayarlarınız aracılığıyla yapılır, ancak tanım nx_secure_tls. h üst bilgi dosyasına da yerleştirilebilirler.</span><span class="sxs-lookup"><span data-stu-id="5a587-563">This is usually done through your compiler settings, but the definition can also be placed in the nx_secure_tls.h header file.</span></span> <span data-ttu-id="5a587-564">Tanımlanan makro ile, PSK ciphersuite desteği NetX güvenli TLS uygulamanıza Derlenecek.</span><span class="sxs-lookup"><span data-stu-id="5a587-564">With the macro defined, PSK ciphersuite support will be compiled into your NetX Secure TLS application.</span></span>

<span data-ttu-id="5a587-565">PSK desteği etkinken, uygulamanız için PSKs 'leri kurmak üzere TLS API 'sini kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="5a587-565">With PSK support enabled, you can then use the TLS API to set up PSKs for your application.</span></span> <span data-ttu-id="5a587-566">Her PSK için bir PSK değeri (gerçek gizli anahtar "anahtarı" – Bu değeri güvenli tut), belirli bir PSK 'yi tanımlamak için kullanılan bir "Identity" değeri ve bir TLS sunucusu tarafından belirli bir PSK değeri seçmek için kullanılan bir "kimlik ipucu" gerekir.</span><span class="sxs-lookup"><span data-stu-id="5a587-566">Each PSK will require a PSK value (the actual secret "key" – keep this value safe), an "identity" value used to identify the specific PSK, and an "identity hint" that is used by a TLS server to choose a particular PSK value.</span></span>

<span data-ttu-id="5a587-567">PSK, bir ağ bağlantısı üzerinden hiçbir şekilde gönderilmediğinden herhangi bir ikili değer olabilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-567">The PSK itself can be any binary value as it is never sent over a network connection.</span></span> <span data-ttu-id="5a587-568">PSK, 64 bayta kadar olan herhangi bir değer olabilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-568">The PSK can be any value up to 64 bytes in length.</span></span>

<span data-ttu-id="5a587-569">Kimliğin ve ipucunun UTF-8 kullanılarak biçimlendirilen yazdırılabilir karakter dizeleri olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="5a587-569">The identity and hint must be printable character strings formatted using UTF-8.</span></span> <span data-ttu-id="5a587-570">Kimlik ve ipucu değerleri 128 bayta kadar olan uzunlukta olabilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-570">The identity and hint values may be any length up to 128 bytes.</span></span>

<span data-ttu-id="5a587-571">Identity ve PSK, ağdaki bir birbirleriyle iletişim kurması gereken her cihaza yüklenen benzersiz bir çift oluşturur.</span><span class="sxs-lookup"><span data-stu-id="5a587-571">The identity and PSK form a unique pair that is loaded onto every device in the network that need to communicate with one another.</span></span>

<span data-ttu-id="5a587-572">"İpucu", birincil olarak, bir işlev veya hizmete göre PSKs 'leri gruplandırmak için belirli uygulama profillerinin tanımlanması için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="5a587-572">The "hint" is primarily used for defining specific application profiles to group PSKs by function or service.</span></span> <span data-ttu-id="5a587-573">Bu değerler önceden anlaşılmalıdır ve uygulamaya bağımlı olur.</span><span class="sxs-lookup"><span data-stu-id="5a587-573">These values must be agreed upon in advance and are application dependent.</span></span> <span data-ttu-id="5a587-574">Örnek olarak, OpenSSL komut satırı sunucu uygulaması (PSK etkin ile), TLS el sıkışması ile devam edebilmek için bir TLS istemcisi tarafından sağlanması gereken varsayılan "Client_identity" dizesini kullanır.</span><span class="sxs-lookup"><span data-stu-id="5a587-574">As an example, the OpenSSL command-line server application (with PSK enabled) uses the default string "Client_identity", which must be provided by a TLS client in order to continue with the TLS handshake.</span></span>

<span data-ttu-id="5a587-575">PSKs hakkında daha fazla bilgi için, aşağıdaki hizmetler için NetX Secure API başvurusuna bakın: nx_secure_tls_client_psk_set, nx_secure_tls_psk_add.</span><span class="sxs-lookup"><span data-stu-id="5a587-575">For more information on PSKs, see the NetX Secure API reference for the following services: nx_secure_tls_client_psk_set, nx_secure_tls_psk_add.</span></span>

## <a name="importing-x509-certificates-into-netx-secure"></a><span data-ttu-id="5a587-576">X. 509.440 sertifikalarını NetX ile alma güvenli</span><span class="sxs-lookup"><span data-stu-id="5a587-576">Importing X.509 certificates into NetX Secure</span></span>

<span data-ttu-id="5a587-577">Internet üzerindeki çoğu TLS bağlantısı için dijital sertifikalar gerekir.</span><span class="sxs-lookup"><span data-stu-id="5a587-577">Digital certificates are required for most TLS connections on the Internet.</span></span> <span data-ttu-id="5a587-578">Sertifikalar, genellikle *sertifika yetkilileri* veya CA olarak adlandırılan güvenilen Aracılar kullanılarak Internet üzerinden daha önce bilinmeyen Konakları kimlik doğrulaması için bir yöntem sağlar.</span><span class="sxs-lookup"><span data-stu-id="5a587-578">Certificates provide a method for authenticating previously unknown hosts over the Internet through the use of trusted intermediaries, usually called *Certificate Authorities* or CAs.</span></span> <span data-ttu-id="5a587-579">NetX güvenli cihazınızı ticari bir bulut hizmetiyle (örneğin, Amazon Web Services) bağlamak için, bu sertifikaları cihazınıza yükleyerek uygulamanıza aktarmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="5a587-579">To connect your NetX Secure device with a commercial cloud service (such as Amazon Web Services), you will need to import certificates into your application by loading them onto your device.</span></span>

<span data-ttu-id="5a587-580">Sertifikalarla birlikte, bazen sertifikalarınızla ilişkili bir *özel anahtara* da ihtiyacınız olacaktır.</span><span class="sxs-lookup"><span data-stu-id="5a587-580">Along with certificates, you will also sometimes need a *private key* that is associated with your certificate.</span></span> <span data-ttu-id="5a587-581">Bazı uygulamalarda (Istemci sertifikası kimlik doğrulaması kullanılmazsa TLS Istemcisi gibi), sertifika tek başına yeterli olacaktır, ancak sertifikanız cihazınızı tanımlamak için kullanılıyorsa özel bir anahtara ihtiyacınız olur.</span><span class="sxs-lookup"><span data-stu-id="5a587-581">In some applications (such as TLS Client when Client Certificate Authentication is not being used) the certificate alone will be sufficient, but if your certificate is being used to identify your device you will need a private key.</span></span> <span data-ttu-id="5a587-582">Özel anahtarlar genellikle sertifikanızı oluşturduğunuzda oluşturulur ve genellikle bir parolayla şifrelenir ve ayrı bir dosyada depolanır.</span><span class="sxs-lookup"><span data-stu-id="5a587-582">Private keys are typically generated when you create your certificate and are stored in a separate file, often encrypted with a password.</span></span>

### <a name="certificate-types"></a><span data-ttu-id="5a587-583">Sertifika Türleri</span><span class="sxs-lookup"><span data-stu-id="5a587-583">Certificate Types</span></span>

<span data-ttu-id="5a587-584">Dijital sertifikalar genellikle bir ağdaki varlıkları tanımlamak için kullanılır, ancak uygulamalarının ne kadar farklı özelliklerine sahip olacaklarına bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="5a587-584">Digital certificates are generally used to identify entities on a network, but depending on what their application they will have slightly different properties.</span></span>

### <a name="local-certificates"></a><span data-ttu-id="5a587-585">Yerel sertifikalar</span><span class="sxs-lookup"><span data-stu-id="5a587-585">Local Certificates</span></span>

<span data-ttu-id="5a587-586">Bu belgelerin amaçları doğrultusunda, yerel cihazımız için bir kimlik sağlayan bu sertifikalar olarak "yerel Sertifikalar" a başvuracağız (başka bir olası ad "cihaz sertifikası" olabilir).</span><span class="sxs-lookup"><span data-stu-id="5a587-586">For the purposes of this documentation, we will refer to "local certificates" as those certificates which provide an identity for our local device (another possible name could be "device certificate").</span></span> <span data-ttu-id="5a587-587">Bu sertifikalar uzak ana bilgisayar yerel cihazın kimliğini doğrulamak için bir uzak ana bilgisayara sağlanacak.</span><span class="sxs-lookup"><span data-stu-id="5a587-587">These certificates will be provided to a remote host when the remote host desires to authenticate the local device.</span></span>

### <a name="remote-certificates"></a><span data-ttu-id="5a587-588">Uzak sertifikalar</span><span class="sxs-lookup"><span data-stu-id="5a587-588">Remote Certificates</span></span>

<span data-ttu-id="5a587-589">Bu belgelerde, "uzak sertifikalar", uygun olduğunda TLS el sıkışması sırasında uzak bir ana bilgisayar tarafından verilen sertifikaları ifade eder.</span><span class="sxs-lookup"><span data-stu-id="5a587-589">In this documentation, "remote certificates" refers to those certificates provided by a remote host during the TLS handshake when applicable.</span></span> <span data-ttu-id="5a587-590">Bu sertifikaların alanı ayrılmalı veya NetX güvenli hale gelmelidir ve TLS el sıkışması tamamlanamayacak.</span><span class="sxs-lookup"><span data-stu-id="5a587-590">Space for these certificates must be allocated or NetX Secure will not be able to parse them and complete the TLS handshake.</span></span>

### <a name="signing-certificates"></a><span data-ttu-id="5a587-591">İmzalama sertifikaları</span><span class="sxs-lookup"><span data-stu-id="5a587-591">Signing Certificates</span></span>

<span data-ttu-id="5a587-592">Kimlik doğrulama amacıyla diğer sertifikaları veya verileri dijital olarak imzalamak için "imzalama sertifikası" kullanılır.</span><span class="sxs-lookup"><span data-stu-id="5a587-592">A "signing certificate" is used to digitally sign other certificates or data for the purpose of authentication.</span></span> <span data-ttu-id="5a587-593">Bu sertifikalar bir ortak anahtar altyapısında (PKI) ara veya kök sertifikalar olabilir ve genellikle tek tek cihazları veya Konakları tanımlamak için kullanılmaz.</span><span class="sxs-lookup"><span data-stu-id="5a587-593">These certificates may be either intermediate or root certificates within a Public Key Infrastructure (PKI) and are generally not used to identify individual devices or hosts.</span></span>

### <a name="root-ca-certificates"></a><span data-ttu-id="5a587-594">Kök CA sertifikaları</span><span class="sxs-lookup"><span data-stu-id="5a587-594">Root CA Certificates</span></span>

<span data-ttu-id="5a587-595">"Kök CA sertifikaları", bir PKI 'nın temelini oluşturan ve başka bir imzalama sertifikası tarafından imzalanmak yerine kendinden imzalı olan imzalama sertifikalardır.</span><span class="sxs-lookup"><span data-stu-id="5a587-595">"Root CA certificates" are signing certificates that provide the basis of a PKI and are self-signed, rather than being signed by another signing certificate.</span></span> <span data-ttu-id="5a587-596">Bir TLS Istemcisinin uzak sunucuları doğrulaması için en az bir kök CA sertifikası gereklidir.</span><span class="sxs-lookup"><span data-stu-id="5a587-596">At least one Root CA certificate is typically required for a TLS Client to verify remote servers.</span></span>

### <a name="certificate-formats"></a><span data-ttu-id="5a587-597">Sertifika biçimleri</span><span class="sxs-lookup"><span data-stu-id="5a587-597">Certificate formats</span></span>

<span data-ttu-id="5a587-598">Dijital sertifikalar yalnızca ASN. 1 sözdizimi kullanılarak kodlanan yapılandırılmış verileri içeren dosyalardır.</span><span class="sxs-lookup"><span data-stu-id="5a587-598">Digital certificates are simply files containing structured data encoded using the ASN.1 syntax.</span></span> <span data-ttu-id="5a587-599">Ancak, sertifikaların depolanabileceği çeşitli biçimler vardır ve bir sertifikayı NetX güvenli uygulamasına yüklemeden önce doğru biçime sahip olmak önemlidir.</span><span class="sxs-lookup"><span data-stu-id="5a587-599">However, there are various formats in which certificates may be stored and it is important to have the right format before loading a certificate into a NetX Secure application.</span></span>

<span data-ttu-id="5a587-600">Sertifikalar için en yaygın biçimler DER ve Peg ' dir.</span><span class="sxs-lookup"><span data-stu-id="5a587-600">The most common formats for certificates are DER and PEM.</span></span> <span data-ttu-id="5a587-601">DER ( *Distinguished Encoding Rules* IÇIN bir ASN. 1 biçimi), ilk el SıKıŞMA gerçekleştirilirken TLS tarafından kullanılan ikili biçimdir.</span><span class="sxs-lookup"><span data-stu-id="5a587-601">DER (for *Distinguished Encoding Rules*, an ASN.1 format) is the binary format used by TLS when performing the initial handshake.</span></span> <span data-ttu-id="5a587-602">Peg ( *Gizlilik Gelişmiş posta*'ten), Web 'de http üzerinden gönderme veya gönderme için uygun olan der biçiminin base-64 kodlu bir sürümüdür.</span><span class="sxs-lookup"><span data-stu-id="5a587-602">PEM (from *Privacy Enhanced Mail*) is a base-64 encoded version of the DER format which is suitable for emailing or sending over HTTP on the web.</span></span> <span data-ttu-id="5a587-603">Farklı satıcılar, sertifika için ". pek" veya ". CRT" gibi farklı dosya adı uzantılarını ve DER sertifikaları için ". der" kullanır.</span><span class="sxs-lookup"><span data-stu-id="5a587-603">Different vendors use different filename extensions for certificates, such as ".pem" or ".crt" for PEM certificates, and ".der" for DER certificates.</span></span> <span data-ttu-id="5a587-604">Bir sertifikanız varsa ve bu, hangi biçimin kullanıldığını temizleyemiyorsa, dosyayı bir metin düzenleyicisinde açmak, DER dosyaları kodlanmış ikiliden itibaren türü belirlemenizi sağlar ve pek dosyaları, "-----başlangıç SERTIFIKASı-----" üstbilgisiyle başlayan normal ASCII metinlerdir.</span><span class="sxs-lookup"><span data-stu-id="5a587-604">If you have a certificate and it is not clear what format is used, opening the file in a text editor will allow you to determine the type since DER files are encoded  binary, and PEM files are regular ASCII text that start with the header "-----BEGIN CERTIFICATE-----".</span></span>

<span data-ttu-id="5a587-605">NetX güvenli, sertifikanızın ikili DER biçiminde olmasını gerektirir, bu nedenle içeri aktarmadan önce sertifikanızı DER biçimine dönüştürmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="5a587-605">NetX Secure requires that your certificate be in binary DER format, so you will need to convert your certificate into DER format before importing.</span></span> <span data-ttu-id="5a587-606">Bu, OpenSSL gibi kullanıma hazır araçlarla yapılabilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-606">This can be done with readily available tools such as OpenSSL.</span></span>

<span data-ttu-id="5a587-607">Uygulamanız için özel bir anahtara ihtiyacınız varsa, anahtar dosya belirli bir biçimde ped veya DER kullanılarak kodlanır (RSA için PKCS # 1, ECC için RFC 5915).</span><span class="sxs-lookup"><span data-stu-id="5a587-607">If you need a private key for your application, the key file will be encoded using PEM or DER in a specific format (PKCS#1 for RSA, RFC 5915 for ECC).</span></span> <span data-ttu-id="5a587-608">Özel anahtar dosyasının içeri aktarılmadan önce DER olarak dönüştürülmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="5a587-608">The private key file will need to be converted into DER before being imported.</span></span>

<span data-ttu-id="5a587-609">Aşağıdaki OpenSSL komutları, sertifikaları ve RSA anahtar dosyalarını NetX Secure (ECC benzerdir – OpenSSL belgelerine bakın) için gereken DER biçimine dönüştürmeye yönelik bir örnek olarak verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="5a587-609">The following OpenSSL commands are given as an example for converting certificates and RSA key files into the DER format required by NetX Secure (ECC is similar – refer to the OpenSSL documentation).</span></span>

```C
openssl x509 -inform PEM -in <certificate> -outform DER -out cert.der
openssl x509 -inform PEM -in <root CA cert> -outform DER -out CA_cert.der
openssl rsa -inform PEM -in <private key> -outform DER -out private.key
```
### <a name="private-keys-and-certificates"></a><span data-ttu-id="5a587-610">Özel anahtarlar ve sertifikalar</span><span class="sxs-lookup"><span data-stu-id="5a587-610">Private Keys and Certificates</span></span>

<span data-ttu-id="5a587-611">Bir cihazı tanımlayan sertifikalar için, ilişkili özel anahtarın sertifikayla birlikte yüklenmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="5a587-611">For certificates that identify a device, the associated private key must be loaded along with the certificate.</span></span> <span data-ttu-id="5a587-612">Özel anahtar (RSA, Diffie-Hellman veya Elliptic-Curve Cryptography gibi ortak anahtar algoritmalarından biri olabilir), bir TLS sunucusu tarafından, gelen anahtar malzemesinin ("Ana Gizlilik") bir TLS istemcisinden şifresini çözmek için kullanılır ve bu sayede istemcinin kimliğini kimlik doğrulamasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="5a587-612">The private key (which may be for one of the public-key algorithms such as RSA, Diffie-Hellman, or Elliptic-Curve Cryptography) is used by a TLS server to decrypt the incoming key material (the "pre-master secret") from a TLS client, thereby authenticating itself to the client.</span></span> <span data-ttu-id="5a587-613">Bir TLS Istemcisi için, bir kimlik sertifikası (ilişkili özel anahtarı olan bir sertifika) sağlanmışsa ve sunucu bir istemci sertifikası isterse, özel anahtar istemcinin kimliğini doğrulamak için kullanılır. RSA, istemci sertifikada belirtilen özel anahtarı kullanarak bir belirteci şifreler (Diffie-Hellman ve ECC kimlik doğrulaması benzer bir şekilde gerçekleşir, ancak Ayrıntılar bit farklıdır)).</span><span class="sxs-lookup"><span data-stu-id="5a587-613">For a TLS Client, if an identity certificate (a certificate with its associated private key) is provided and a server requests a client certificate, the private key is used to authenticate the client – in the case of RSA the client  encrypts a token using the private key which the server then decrypts using the client's public key, provided in the client certificate (Diffie-Hellman and ECC authentication happens in a similar fashion but the details are a bit different).</span></span>

<span data-ttu-id="5a587-614">NetX güvenli ' te, Service *nx_secure_x509_certificate_initialize* bir X. 509.440 sertifikası başlatmak için kullanılır (daha fazla bilgi için bkz. "cihazınıza sertifika yükleme" bölümüne bakın) ve isteğe bağlı olarak özel bir anahtarı bu sertifikayla ilişkilendirin.</span><span class="sxs-lookup"><span data-stu-id="5a587-614">In NetX secure, the service *nx_secure_x509_certificate_initialize* is used to initialize an X.509 certificate (see section "Loading certificates onto your device" for more information) and optionally associate a private key with that certificate.</span></span>

<span data-ttu-id="5a587-615">Özel anahtar sağlanırsa, sertifika, cihazı tanımlamak için kullanılan "kimlik" sertifikası olarak işaretlenir.</span><span class="sxs-lookup"><span data-stu-id="5a587-615">If a private key is supplied, the certificate is marked as being the "identity" certificate used to identify the device.</span></span> <span data-ttu-id="5a587-616">Anahtar bitişik bir ikili blob ve bir uzunluğu, ilişkili anahtar türü olarak geçirilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-616">The key is passed as a contiguous binary blob and a length, with an associated key type.</span></span> <span data-ttu-id="5a587-617">Anahtar türü anahtarın türüne (ör. RSA, ECC, vb.) ve biçimde (örn. PKCS # 1 DER) bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="5a587-617">The key type depends on the type of key (e.g. RSA, ECC, etc.) and the format (e.g. PKCS#1 DER).</span></span> <span data-ttu-id="5a587-618">Anahtar sağlanmazsa, hiçbir anahtar sağlanmakta olmadığını göstermek için NX_SECURE_X509_KEY_TYPE_NONE (değer 0x0) değeri geçirilebilir (0 uzunluğu ve veri parametresi için bir NX_NULL işaretçisi aynı etkiye ulaşacaktır).</span><span class="sxs-lookup"><span data-stu-id="5a587-618">If no key is supplied, the value NX_SECURE_X509_KEY_TYPE_NONE (value 0x0) can be passed to indicate no key is being supplied (a length of 0 and a NX_NULL pointer for the data parameter will achieve the same effect).</span></span>

<span data-ttu-id="5a587-619">Aşağıdaki tabloda NetX güvenli olarak bilinen anahtar türleri ve *nx_secure_x509_certificate_initialize* geçirilecek ilişkili tür tanımlayıcısı gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="5a587-619">The following table shows the key types known to NetX Secure and the associated type identifier to be passed into *nx_secure_x509_certificate_initialize*.</span></span> <span data-ttu-id="5a587-620">NetX güvenli 'ye daha fazla şifreleme algoritması eklendikçe ek anahtar türleri eklenecektir.</span><span class="sxs-lookup"><span data-stu-id="5a587-620">Additional key types will be added as more encryption algorithms are added to NetX Secure.</span></span>

| <span data-ttu-id="5a587-621">Tanımlayıcı</span><span class="sxs-lookup"><span data-stu-id="5a587-621">Identifier</span></span>                              | <span data-ttu-id="5a587-622">Algoritma</span><span class="sxs-lookup"><span data-stu-id="5a587-622">Algorithm</span></span> | <span data-ttu-id="5a587-623">Biçimlendir</span><span class="sxs-lookup"><span data-stu-id="5a587-623">Format</span></span>   | <span data-ttu-id="5a587-624">Encoding</span><span class="sxs-lookup"><span data-stu-id="5a587-624">Encoding</span></span> | <span data-ttu-id="5a587-625">Değer</span><span class="sxs-lookup"><span data-stu-id="5a587-625">Value</span></span> |
| --------------------------------------- | --------- | -------- | -------- | ----- |
| <span data-ttu-id="5a587-626">NX_SECURE_X509_KEY_TYPE_NONE</span><span class="sxs-lookup"><span data-stu-id="5a587-626">NX_SECURE_X509_KEY_TYPE_NONE</span></span>            | <span data-ttu-id="5a587-627">Yok</span><span class="sxs-lookup"><span data-stu-id="5a587-627">None</span></span>      | <span data-ttu-id="5a587-628">Yok</span><span class="sxs-lookup"><span data-stu-id="5a587-628">N/A</span></span>      | <span data-ttu-id="5a587-629">Yok</span><span class="sxs-lookup"><span data-stu-id="5a587-629">N/A</span></span>      | <span data-ttu-id="5a587-630">'dır</span><span class="sxs-lookup"><span data-stu-id="5a587-630">0x0</span></span>   |
| <span data-ttu-id="5a587-631">NX_SECURE_X509_KEY_TYPE_RSA_PKCS1_DER</span><span class="sxs-lookup"><span data-stu-id="5a587-631">NX_SECURE_X509_KEY_TYPE_RSA_PKCS1_DER</span></span>   | <span data-ttu-id="5a587-632">RSA</span><span class="sxs-lookup"><span data-stu-id="5a587-632">RSA</span></span>       | <span data-ttu-id="5a587-633">PKCS # 1</span><span class="sxs-lookup"><span data-stu-id="5a587-633">PKCS#1</span></span>   | <span data-ttu-id="5a587-634">CÜ</span><span class="sxs-lookup"><span data-stu-id="5a587-634">DER</span></span>      | <span data-ttu-id="5a587-635">0x1</span><span class="sxs-lookup"><span data-stu-id="5a587-635">0x1</span></span>   |
| <span data-ttu-id="5a587-636">NX_SECURE_X509_KEY_TYPE_EC_DER</span><span class="sxs-lookup"><span data-stu-id="5a587-636">NX_SECURE_X509_KEY_TYPE_EC_DER</span></span>          | <span data-ttu-id="5a587-637">ECDSA</span><span class="sxs-lookup"><span data-stu-id="5a587-637">ECDSA</span></span>     | <span data-ttu-id="5a587-638">RFC 5915</span><span class="sxs-lookup"><span data-stu-id="5a587-638">RFC 5915</span></span> | <span data-ttu-id="5a587-639">CÜ</span><span class="sxs-lookup"><span data-stu-id="5a587-639">DER</span></span>      | <span data-ttu-id="5a587-640">0x2</span><span class="sxs-lookup"><span data-stu-id="5a587-640">0x2</span></span>   |

### <a name="user-defined-private-key-types"></a><span data-ttu-id="5a587-641">Kullanıcı tanımlı özel anahtar türleri</span><span class="sxs-lookup"><span data-stu-id="5a587-641">User-defined private key types</span></span>

<span data-ttu-id="5a587-642">*Nx_secure_x509_certificate_initialize* hizmeti için anahtar türü tanımlayıcılarının değerleri, özel anahtar sağlandığında gerçekleştirilecek eylemleri yönetir.</span><span class="sxs-lookup"><span data-stu-id="5a587-642">The values of the key type identifiers for the *nx_secure_x509_certificate_initialize* service govern the actions taken when the private key is supplied.</span></span> <span data-ttu-id="5a587-643">Bilinen türler için değerler 0x0000 0000 – 0x0000 FFFF aralığındadır (32 bit işaretsiz tamsayının alt 16 bitleridir).</span><span class="sxs-lookup"><span data-stu-id="5a587-643">For known types, the values are in the range 0x0000 0000 – 0x0000 FFFF (bottom 16 bits of a 32-bit unsigned integer).</span></span> <span data-ttu-id="5a587-644">Özel anahtar türleri<sup>17</sup> olan platformlar için (bazı donanım tabanlı şifreleme altyapılarında olduğu gibi), anahtar türü olarak 0x0000 1000-0xFFFF ffff (ilk 16 bit sıfır olmayan) aralığında Kullanıcı tanımlı bir anahtar türü geçirilebilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-644">For platforms with custom key types<sup>17</sup> (as is the case for some hardware-based encryption engines), a user-defined key type in the range 0x0000 1000-0xFFFF FFFF (top 16 bits non-zero) may be passed as the key type.</span></span> <span data-ttu-id="5a587-645">Anahtar türünün en üstteki 16 biti ayarlandıysa, özel anahtar verileri TLS ciphersuite tablosunda sağlanan uygun şifreleme yordamına (ör. RSA) doğrudan geçirilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-645">If any of the top 16 bits of the key type are set, then the private key data is passed directly to the appropriate cryptographic routine (e.g. RSA) supplied in the TLS ciphersuite table.</span></span> <span data-ttu-id="5a587-646">Kullanıcı tanımlı anahtar türleri ayrıştırılmaz veya şifreleme yordamına geçirilmeden önce işlenmemiştir.</span><span class="sxs-lookup"><span data-stu-id="5a587-646">User-defined key types are not parsed or otherwise processed before being passed to the cryptographic routine.</span></span> <span data-ttu-id="5a587-647">Ayrıca, Kullanıcı tanımlı anahtar türü de şifreleme yordamına geçirilir, böylece ilgili işlem o düzeyde işlenebilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-647">In addition, the user-defined key type will also be passed to the cryptographic routine so that any appropriate processing can be handled at that level.</span></span>

<span data-ttu-id="5a587-648">Kullanıcı tanımlı anahtar türlerinin, özel (Belki de şifrelenmiş) anahtar verileri kullanan belirli donanım platformları için genellikle kullanıldığını unutmayın.</span><span class="sxs-lookup"><span data-stu-id="5a587-648">Note that user-defined key types are generally used for specific hardware platforms that utilize custom (possibly encrypted) key data.</span></span> <span data-ttu-id="5a587-649">Genellikle bu, anahtar verilerinin, bu donanım satıcısına özgü bir mekanizma kullanılarak oluşturulduğu veya kodlandığı anlamına gelir (veya PKCS # 11 gibi bir standart olması durumunda belirli bir standart).</span><span class="sxs-lookup"><span data-stu-id="5a587-649">Generally this implies that the key data is generated or encoded using a mechanism specific to that hardware vendor (or in the case of a standard like PKCS#11, a specific standard).</span></span> <span data-ttu-id="5a587-650">Daha fazla bilgi için donanım platformu belgelerinize başvurun.</span><span class="sxs-lookup"><span data-stu-id="5a587-650">Consult your hardware platform documentation for more information.</span></span>

17. <span data-ttu-id="5a587-651">Kullanıcı tanımlı anahtar türleri, özel anahtar biçimini işlemek için karşılık gelen özel bir şifreleme yordamını gerektirir.</span><span class="sxs-lookup"><span data-stu-id="5a587-651">User-defined key types require a corresponding custom cryptographic routine to handle the custom key format.</span></span> <span data-ttu-id="5a587-652">Şifreleme yordamının eşleşen bir algoritması (ör. RSA) olması ve ciphersuite tablosunda TLS 'ye geçirilmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="5a587-652">The cryptographic routine must have a matching algorithm (e.g. RSA) and be passed into TLS in the ciphersuite table.</span></span> 

### <a name="loading-certificates-onto-your-device"></a><span data-ttu-id="5a587-653">Cihazınıza sertifika yükleme</span><span class="sxs-lookup"><span data-stu-id="5a587-653">Loading certificates onto your device</span></span>

<span data-ttu-id="5a587-654">Cihazınıza dosya yüklemeye yönelik herhangi bir yöntem, sertifikalarınızı içeri aktarmak için yeterli olacaktır.</span><span class="sxs-lookup"><span data-stu-id="5a587-654">Any method for loading a file onto your device will be sufficient to import your certificates.</span></span>

<span data-ttu-id="5a587-655">Bir sertifikayı yüklemek için en basit yöntem, ikili DER kodlu verileri bir C dizisine dönüştürmeli ve bunu uygulamanızda bir sabit olarak derler.</span><span class="sxs-lookup"><span data-stu-id="5a587-655">The simplest method for loading a certificate is to convert the binary DER-encoded data into a C array and compile it into your application as a constant.</span></span> <span data-ttu-id="5a587-656">Bu, Linux 'ta "XXD" gibi araçlarla kolayca yapılabilir ("-i" seçeneği ile).</span><span class="sxs-lookup"><span data-stu-id="5a587-656">This can be easily done with tools such as "xxd" in Linux (with the "-i" option).</span></span>

<span data-ttu-id="5a587-657">Alternatif olarak, sertifika verilerine yönelik bir işaretçiyi NetX güvenli API 'ye geçirebilmeniz koşuluyla, sertifikanızı bir Flash FileSystem veya diğer depolama seçeneklerine yükleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="5a587-657">Alternatively, you can load your certificate into a flash filesystem or other storage options as long as you can pass a pointer to the certificate data into the NetX Secure API.</span></span>

### <a name="certificate-files-needed-for-netx-secure"></a><span data-ttu-id="5a587-658">NetX güvenli için gereken sertifika dosyaları</span><span class="sxs-lookup"><span data-stu-id="5a587-658">Certificate files needed for NetX Secure</span></span>

<span data-ttu-id="5a587-659">İçeri aktarmanız gereken sertifika dosyaları uygulamanıza bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="5a587-659">The certificate files you will need to import depends on your application.</span></span> <span data-ttu-id="5a587-660">Genel olarak, TLS sunucuları cihazı tanımlamak için bir sertifika gerektirir ve TLS Istemcileri uzak sunucuların kimliğini doğrulamak için bir veya daha fazla *Güvenilen sertifika* gerektirir.</span><span class="sxs-lookup"><span data-stu-id="5a587-660">In general, TLS Servers require a certificate to identify the device, and TLS Clients require one or more *Trusted Certificates* to authenticate remote servers.</span></span> <span data-ttu-id="5a587-661">Aşağıdaki tabloda bazı farklı TLS uygulamaları için gereken sertifikalar gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="5a587-661">The following table illustrates certificates needed for some different TLS applications.</span></span>

| <span data-ttu-id="5a587-662">**TLS işlevselliği/seçenekleri**</span><span class="sxs-lookup"><span data-stu-id="5a587-662">**TLS functionality/options**</span></span>                     | <span data-ttu-id="5a587-663">**Gerekli sertifikalar/anahtarlar (minimum)**</span><span class="sxs-lookup"><span data-stu-id="5a587-663">**Certificates/keys needed (minimum)**</span></span>              |
| ------------------------------------------------- | --------------------------------------------------- |
| <span data-ttu-id="5a587-664">TLS Istemcisi</span><span class="sxs-lookup"><span data-stu-id="5a587-664">TLS Client</span></span>                                        | <span data-ttu-id="5a587-665">Kök CA sertifikası</span><span class="sxs-lookup"><span data-stu-id="5a587-665">Root CA certificate</span></span>                                 |
| <span data-ttu-id="5a587-666">TLS sunucusu</span><span class="sxs-lookup"><span data-stu-id="5a587-666">TLS Server</span></span>                                        | <span data-ttu-id="5a587-667">Yerel sertifika, bu sertifika için özel anahtar</span><span class="sxs-lookup"><span data-stu-id="5a587-667">Local certificate, private key for that certificate</span></span> |
| <span data-ttu-id="5a587-668">Istemci sertifikası kimlik doğrulaması ile TLS sunucusu</span><span class="sxs-lookup"><span data-stu-id="5a587-668">TLS Server with Client Certificate Authentication</span></span> | <span data-ttu-id="5a587-669">Yerel sertifika, özel anahtar, kök CA</span><span class="sxs-lookup"><span data-stu-id="5a587-669">Local certificate, private key, Root CA</span></span>             |
| <span data-ttu-id="5a587-670">Istemci sertifikası kimlik doğrulaması ile TLS Istemcisi</span><span class="sxs-lookup"><span data-stu-id="5a587-670">TLS Client with Client Certificate Authentication</span></span> | <span data-ttu-id="5a587-671">Yerel sertifika, özel anahtar, kök CA</span><span class="sxs-lookup"><span data-stu-id="5a587-671">Local certificate, private key, Root CA</span></span>             |
| <span data-ttu-id="5a587-672">Yalnızca önceden paylaşılan anahtarları olan TLS Istemcisi veya sunucusu</span><span class="sxs-lookup"><span data-stu-id="5a587-672">TLS Client or Server with Pre-Shared Keys only</span></span>    | <span data-ttu-id="5a587-673">Hiçbiri (sertifikalar yerine PSK kullanıldı)</span><span class="sxs-lookup"><span data-stu-id="5a587-673">None (PSK used instead of certificates)</span></span>             |

<span data-ttu-id="5a587-674">Sertifikaları yüklemek için ilgili hizmetler aşağıdaki gibidir:</span><span class="sxs-lookup"><span data-stu-id="5a587-674">The relevant services for loading certificates are as follows:</span></span>

| <span data-ttu-id="5a587-675">**API adı**</span><span class="sxs-lookup"><span data-stu-id="5a587-675">**API Name**</span></span>                                   | <span data-ttu-id="5a587-676">**Amaç**</span><span class="sxs-lookup"><span data-stu-id="5a587-676">**Purpose**</span></span>                                            |
| ---------------------------------------------- |------------------------------------------------------- |
| <span data-ttu-id="5a587-677">nx_secure_x509_certificate_initialize</span><span class="sxs-lookup"><span data-stu-id="5a587-677">nx_secure_x509_certificate_initialize</span></span>      | <span data-ttu-id="5a587-678">, NX_SECURE_X509_CERT yapısını sertifika verilerinize ve özel anahtarınızla doldurmak için tüm sertifikaların çağrılması gerekir.</span><span class="sxs-lookup"><span data-stu-id="5a587-678">Must be called for all certificates to populate the NX_SECURE_X509_CERT structure with your certificate data and private key.</span></span> |
| <span data-ttu-id="5a587-679">nx_secure_tls_local_certificate_add</span><span class="sxs-lookup"><span data-stu-id="5a587-679">nx_secure_tls_local_certificate_add</span></span>       | <span data-ttu-id="5a587-680">Cihazınızı tanımlamak için bir TLS oturumuna yerel sertifika ekleyin.</span><span class="sxs-lookup"><span data-stu-id="5a587-680">Add a local certificate to a TLS session to identify your device.</span></span>                                                                |
| <span data-ttu-id="5a587-681">nx_secure_tls_local_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="5a587-681">nx_secure_tls_local_certificate_remove</span></span>    | <span data-ttu-id="5a587-682">Bir TLS oturumundan yerel bir sertifikayı kaldırın.</span><span class="sxs-lookup"><span data-stu-id="5a587-682">Remove a local certificate from a TLS session.</span></span>                                                                                   |
| <span data-ttu-id="5a587-683">nx_secure_tls_remote_certificate_allocate</span><span class="sxs-lookup"><span data-stu-id="5a587-683">nx_secure_tls_remote_certificate_allocate</span></span> | <span data-ttu-id="5a587-684">Uzak bir sertifika için alan ayırır (başlatılmamış NX_SECURE_X509_CERT ile çağırılır).</span><span class="sxs-lookup"><span data-stu-id="5a587-684">Allocate space for a remote certificate (called with an uninitialized NX_SECURE_X509_CERT).</span></span>                                   |
| <span data-ttu-id="5a587-685">nx_secure_tls_trusted_certificate_add</span><span class="sxs-lookup"><span data-stu-id="5a587-685">nx_secure_tls_trusted_certificate_add</span></span>     | <span data-ttu-id="5a587-686">Uzak konaklara kimlik doğrulaması için güvenilen bir sertifika olarak bir TLS oturumuna sertifika ekleyin.</span><span class="sxs-lookup"><span data-stu-id="5a587-686">Add a certificate to a TLS Session as a Trusted Certificate for authenticating remote hosts.</span></span>                                     |
| <span data-ttu-id="5a587-687">nx_secure_tls_trusted_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="5a587-687">nx_secure_tls_trusted_certificate_remove</span></span>  | <span data-ttu-id="5a587-688">Bir TLS oturumundan güvenilir bir sertifikayı kaldırın.</span><span class="sxs-lookup"><span data-stu-id="5a587-688">Remove a trusted certificate from a TLS Session.</span></span>                                                                                 |

### <a name="working-with-aws-iot-certificates"></a><span data-ttu-id="5a587-689">AWS IoT sertifikalarıyla çalışma</span><span class="sxs-lookup"><span data-stu-id="5a587-689">Working with AWS IoT Certificates</span></span>

<span data-ttu-id="5a587-690">Amazon Web Services IoT arabiriminde, kenar çubuğu menüsünden "güvenlik" i seçin ve "Sertifikalar" ı seçin.</span><span class="sxs-lookup"><span data-stu-id="5a587-690">In the Amazon Web Services IoT interface, select "Security" from the sidebar menu and select "Certificates".</span></span> <span data-ttu-id="5a587-691">Yeni bir sertifika oluşturun ve yeni cihaz sertifikanızı indirmek için yönergeleri izleyin.</span><span class="sxs-lookup"><span data-stu-id="5a587-691">Create a new certificate and follow the instructions to download your new device certificate.</span></span>

<span data-ttu-id="5a587-692">Sertifikalarınızı indirdikten sonra, OpenSSL veya benzer bir yardımcı program kullanarak bunları DER biçimine dönüştürmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="5a587-692">Once you have downloaded your certificates, you will need to convert them into DER format using OpenSSL or a similar utility.</span></span>

<span data-ttu-id="5a587-693">NOTE: AWS ortak anahtar dosyası da sağlar.</span><span class="sxs-lookup"><span data-stu-id="5a587-693">NOTE: AWS will also provide a public key file.</span></span> <span data-ttu-id="5a587-694">Ortak anahtar, yerel cihaz sertifikası içinde bulunur, bu nedenle uygulamanıza aktarılmaları gerekmez.</span><span class="sxs-lookup"><span data-stu-id="5a587-694">The public key is contained within the local device certificate so it does not need to be imported into your application.</span></span>

<span data-ttu-id="5a587-695">Örnek olarak, yerel cihaz sertifikasını ve özel anahtarını NetX güvenli ile kullanmak üzere DER biçimine dönüştürmek için komutlar aşağıda verilmiştir:</span><span class="sxs-lookup"><span data-stu-id="5a587-695">As an example, here are the commands to convert the local device certificate and its private key into DER format for use with NetX Secure:</span></span>

```C
openssl x509 -inform PEM -in <certificate> -outform DER -out cert.der
openssl x509 -inform PEM -in <root CA cert> -outform DER -out CA_cert.der
openssl rsa -inform PEM -in <private key> -outform DER -out private.key
```
<span data-ttu-id="5a587-696">Dönüştürülen dosyalar, yukarıdaki yönergeleri izleyerek uygulamanıza aktarılabilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-696">The converted files can be imported into your application following the above instructions.</span></span>

## <a name="x509-certificate-validation-in-netx-secure"></a><span data-ttu-id="5a587-697">NetX 'te X. 509.440 sertifika doğrulaması güvenli</span><span class="sxs-lookup"><span data-stu-id="5a587-697">X.509 Certificate Validation in NetX Secure</span></span> 

<span data-ttu-id="5a587-698">Ana bilgisayar tanımlama ve doğrulama için X. 509.440 sertifikalarıyla TLS kullanırken, bu sertifikaların gerçekten nasıl doğrulandığını anlamak önemlidir.</span><span class="sxs-lookup"><span data-stu-id="5a587-698">When using TLS with X.509 certificates for host identification and verification, it is important to understand how those certificates are actually validated.</span></span> <span data-ttu-id="5a587-699">TLS belirtimi bir sertifikanın nasıl doğrulanacağı hakkında ayrıntılı yönergeler sağlamıyorsa, bu, X. 509.440 belirtimine (RFC 5280) başvurur.</span><span class="sxs-lookup"><span data-stu-id="5a587-699">While the TLS specification does not provide detailed instructions on how to validate a certificate, it does refer to the X.509 specification (RFC 5280).</span></span> <span data-ttu-id="5a587-700">Genel olarak, TLS 'nin gelen sertifikalarda en az temel doğrulama gerçekleştirmesini (TLS el sıkışması sırasında uzak ana bilgisayar tarafından sağlanan sertifikalar) ve NetX güvenli TLS 'in farklı olmaması beklenmektedir.</span><span class="sxs-lookup"><span data-stu-id="5a587-700">In general, it is expected that TLS will perform at least basic validation on incoming certificates (those certificates supplied by the remote host during the TLS handshake), and NetX Secure TLS is no different.</span></span>

### <a name="basic-x509-validation"></a><span data-ttu-id="5a587-701">Temel X. 509.440 doğrulaması</span><span class="sxs-lookup"><span data-stu-id="5a587-701">Basic X.509 Validation</span></span>

<span data-ttu-id="5a587-702">Tüm gelen sertifikalar için NetX güvenli TLS, temel X. 509.440 yol doğrulamasını gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="5a587-702">For any incoming certificate, NetX Secure TLS will perform basic X.509 path validation.</span></span> <span data-ttu-id="5a587-703">İşlem, güvenilen sertifikaları içeri aktarma hakkında daha fazla bilgi için, her sertifikanın dijital imzasını veren sertifikasına karşı denetlemeyi içerir. Bu, uzak ana bilgisayar tarafından sağlanabiliyor veya güvenilen sertifika deposunda yer alıyor (güvenilen sertifikaları alma hakkında daha fazla bilgi için "X. 509.952 sertifikalarını NetX 'e aktarma" bölümüne bakın).</span><span class="sxs-lookup"><span data-stu-id="5a587-703">The process involves checking each certificate's digital signature against its issuer certificate, which may be provided by the remote host or be located in the trusted certificate store (see the section "Importing X.509 certificates into NetX Secure" for more information on importing trusted certificates).</span></span> <span data-ttu-id="5a587-704">Doğrulama işlemi, güvenilen sertifikaya ulaşılana veya zincir sona erene kadar (otomatik olarak imzalanan bir sertifika veya eksik veren sertifikayla) veren sertifikalarda yinelemeli olarak yinelenir.</span><span class="sxs-lookup"><span data-stu-id="5a587-704">The validation process is recursively repeated on the issuer certificates until a trusted certificate is reached or the chain ends (with a self-signed certificate or a missing issuer certificate).</span></span> <span data-ttu-id="5a587-705">Güvenilen sertifikaya ulaşıldığında, sertifika doğrulanır, aksi takdirde reddedilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-705">If a trusted certificate is reached, the certificate is verified, otherwise it is rejected.</span></span> <span data-ttu-id="5a587-706">Ayrıca, doğrulama işlemindeki her aşamada her bir sertifikanın sona erme tarihi, uygulama zaman damgası işlevi tarafından belirtilen zamana göre denetlenir (daha fazla bilgi için "nx_secure_tls_session_time_function_set" hizmetine bakın).</span><span class="sxs-lookup"><span data-stu-id="5a587-706">Additionally, at each stage in the verification process the expiration date of each certificate is checked against the time provided by the application timestamp function (see the service "nx_secure_tls_session_time_function_set" for more information).</span></span>

<span data-ttu-id="5a587-707">X. 509.440 belirtimi, yol doğrulaması sırasında denetlenebilir bir X. 509.952 uzantısında bulunan tanımlayıcılar olan "ilkeleri" desteklemek için bir algoritma da sunar.</span><span class="sxs-lookup"><span data-stu-id="5a587-707">The X.509 specification also provides an algorithm for supporting "policies", which are identifiers that are present in an X.509 extension that can be checked during path validation.</span></span> <span data-ttu-id="5a587-708">NetX Secure Şu anda X. 509.440 sertifikalarını "anyPolicy" seçeneği tanımlanmış olsa da kabul eder; yani, tüm ilkeler kabul edilebilir ve isteğe bağlı ilke denetimi gerçekleştirilmez.</span><span class="sxs-lookup"><span data-stu-id="5a587-708">NetX Secure currently treats X.509 certificates as though the "anyPolicy" option is defined – that is, all policies are acceptable and the optional policy checking is not performed.</span></span> <span data-ttu-id="5a587-709">NetX Secure X. 509.440 uygulamasının daha sonraki bir sürümde bu özellikle Genişletilebilir olması olabilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-709">The NetX Secure X.509 implementation may be augmented with this feature in a future release.</span></span> <span data-ttu-id="5a587-710">Şimdilik, ilke uzantısı *nx_secure_x509_extension_find* API kullanarak bir sertifikadan elde edilebilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-710">For now, the policy extension may be obtained from a certificate using the *nx_secure_x509_extension_find* API.</span></span>

<span data-ttu-id="5a587-711">Temel yol doğrulaması tamamlandıktan sonra, TLS *nx_secure_tls_session_certificate_callback_set* API kullanılarak uygulama tarafından sağlanan sertifika doğrulama geri aramasını çağırır.</span><span class="sxs-lookup"><span data-stu-id="5a587-711">Once the basic path validation is complete, TLS will invoke the certificate verification callback supplied by the application using the *nx_secure_tls_session_certificate_callback_set* API.</span></span> <span data-ttu-id="5a587-712">Geri arama sağlanmadığında, sertifikanın başarılı yol doğrulamasından sonra güvenilir olduğu kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-712">If no callback is supplied, the certificate is considered to be trusted following successful path validation.</span></span> <span data-ttu-id="5a587-713">Bir geri çağırma sağlanırsa, geri arama, uygulamanın gerektirdiği sertifikanın ek doğrulamasını gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="5a587-713">If a callback is supplied, the callback will perform any additional validation of the certificate required by the application.</span></span> <span data-ttu-id="5a587-714">Geri aramadan gelen dönüş değeri, TLS el sıkışması ile devam edilip edilmeyeceğini veya bir doğrulama hatası nedeniyle el sıkışmasını durdurmayı belirlemekte kullanılır.</span><span class="sxs-lookup"><span data-stu-id="5a587-714">The return value from the callback is used to determine whether to continue with the TLS handshake or to abort the handshake due to a validation failure.</span></span>

<span data-ttu-id="5a587-715">Geri çağırma, ilgili TLS oturumuna yönelik bir işaretçi ve doğrulanacak sertifikaya yönelik NX_SECURE_X509_CERT işaretçisi ile çağrılır.</span><span class="sxs-lookup"><span data-stu-id="5a587-715">The callback is invoked with a pointer to the relevant TLS session and an NX_SECURE_X509_CERT pointer to the certificate to be validated.</span></span> <span data-ttu-id="5a587-716">TLS oturumu ve sertifika arasında, uygulamanın ek doğrulama denetimleri gerçekleştirmesi için gereken tüm verileri TLS 'den yapması gerekir.</span><span class="sxs-lookup"><span data-stu-id="5a587-716">Between the TLS session and the certificate, the application has all of the data it needs from TLS to perform additional verification checks.</span></span>

<span data-ttu-id="5a587-717">NetX Secure, ek doğrulamaya yardımcı olmak için DNS doğrulaması ve sertifika Iptal listesi denetimi dahil bazı yaygın doğrulama işlemleri için X. 509.440 yordamlarını sağlar.</span><span class="sxs-lookup"><span data-stu-id="5a587-717">To help with the additional validation, NetX Secure provides X.509 routines for some common validation operations, including DNS validation and Certificate Revocation List checking.</span></span> <span data-ttu-id="5a587-718">Bu yordamların hepsi, sertifika doğrulama geri aramasında kullanılmak üzere uygundur, ancak X. 509.440 sertifikalarının çevrimdışı denetimini gerçekleştirmek için de kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-718">All of these routines are suitable for use within the certificate verification callback but may also be used to perform off-line checking of X.509 certificates.</span></span>

<span data-ttu-id="5a587-719">Aşağıdaki tabloda X. 509.440 sertifika işleme için kullanılabilir yardımcı işlevler özetlenmektedir.</span><span class="sxs-lookup"><span data-stu-id="5a587-719">The following table summarizes the available helper functions for X.509 certificate processing.</span></span> <span data-ttu-id="5a587-720">İşlemler için daha ayrıntılı açıklamalar, Bölüm 4 ' te aşağıdaki bölümlerde ve API başvurusunda bulunabilir</span><span class="sxs-lookup"><span data-stu-id="5a587-720">More detailed explanations for the operations can be found in the following sections and the API reference in Chapter 4</span></span>  
  
<span data-ttu-id="5a587-721">NetX güvenli hizmetlerinin açıklaması, belirli yordamlar hakkında ek ayrıntılar sağlar.</span><span class="sxs-lookup"><span data-stu-id="5a587-721">Description of NetX Secure Services provides additional details on the specific routines.</span></span>

| <span data-ttu-id="5a587-722">**API adı**</span><span class="sxs-lookup"><span data-stu-id="5a587-722">**API Name**</span></span>                             | <span data-ttu-id="5a587-723">**Açıklama**</span><span class="sxs-lookup"><span data-stu-id="5a587-723">**Description**</span></span>                               |
| ---------------------------------------- | -------------------------------------- |
| <span data-ttu-id="5a587-724">nx_secure_x509_common_name_dns_check</span><span class="sxs-lookup"><span data-stu-id="5a587-724">nx_secure_x509_common_name_dns_check</span></span>               | <span data-ttu-id="5a587-725">X. 509.952 Subject ortak adı ve SubjectAltName ' i beklenen bir DNS adına göre denetleyin</span><span class="sxs-lookup"><span data-stu-id="5a587-725">Check the X.509 subject Common Name and SubjectAltName against an expected DNS name</span></span> |
| <span data-ttu-id="5a587-726">nx_secure_x509_crl_revocation_check</span><span class="sxs-lookup"><span data-stu-id="5a587-726">nx_secure_x509_crl_revocation_check</span></span>                 | <span data-ttu-id="5a587-727">Bir X. 509.440 sertifika Iptal listesindeki (CRL) iptal edilmiş bir sertifika olup olmadığını denetleyin</span><span class="sxs-lookup"><span data-stu-id="5a587-727">Check for a revoked certificate in an X.509 Certificate Revocation List (CRL)</span></span>       |
| <span data-ttu-id="5a587-728">nx_secure_x509_extended_key_usage_extension_parse</span><span class="sxs-lookup"><span data-stu-id="5a587-728">nx_secure_x509_extended_key_usage_extension_parse</span></span> | <span data-ttu-id="5a587-729">Bir sertifikada belirli bir genişletilmiş anahtar kullanımı OID 'sini ayrıştırma ve bulma</span><span class="sxs-lookup"><span data-stu-id="5a587-729">Parse and find a specific extended key usage OID in a certificate</span></span>                   |
| <span data-ttu-id="5a587-730">nx_secure_x509_key_usage_extension_parse</span><span class="sxs-lookup"><span data-stu-id="5a587-730">nx_secure_x509_key_usage_extension_parse</span></span>           | <span data-ttu-id="5a587-731">Bir sertifikadaki anahtar kullanımı bitalanını ayrıştırın ve döndürün</span><span class="sxs-lookup"><span data-stu-id="5a587-731">Parse and return the key usage bitfield in a certificate</span></span>                            |
| <span data-ttu-id="5a587-732">nx_secure_x509_extension_find</span><span class="sxs-lookup"><span data-stu-id="5a587-732">nx_secure_x509_extension_find</span></span>                        | <span data-ttu-id="5a587-733">Belirli bir uzantı için ham DER kodlu ASN. 1 verilerini bulun ve döndürün.</span><span class="sxs-lookup"><span data-stu-id="5a587-733">Find and return the raw DER-encoded ASN.1 data for a specific extension.</span></span>            |

<span data-ttu-id="5a587-734">Sertifika doğrulama geri aramasında kullanılacak X. 509.440 yardımcı işlevleri</span><span class="sxs-lookup"><span data-stu-id="5a587-734">X.509 helper functions for use in the certificate verification callback</span></span>

### <a name="x509-extensions"></a><span data-ttu-id="5a587-735">X. 509.440 uzantıları</span><span class="sxs-lookup"><span data-stu-id="5a587-735">X.509 Extensions</span></span>

<span data-ttu-id="5a587-736">X. 509.440 belirtimi, sertifikaların Doğrulanmakta kullanılabilecek ek bilgiler sağlamak için kullanılabilen bir dizi "uzantıyı" tanımlar.</span><span class="sxs-lookup"><span data-stu-id="5a587-736">The X.509 specification describes a number of "extensions" that can be used to supply additional information that can be utilized in the verification of certificates.</span></span> <span data-ttu-id="5a587-737">Çoğu bölüm için bu uzantılar isteğe bağlıdır ve bir dijital sertifikanın güvenilen bir kök sertifikaya karşı güvenli doğrulanması için gerekli değildir.</span><span class="sxs-lookup"><span data-stu-id="5a587-737">For the most part, these extensions are optional and are not required for secure validation of a digital certificate against a trusted root certificate.</span></span> <span data-ttu-id="5a587-738">Ancak NetX Secure, bazı temel uzantıları destekler.</span><span class="sxs-lookup"><span data-stu-id="5a587-738">However, NetX Secure does support some basic extensions.</span></span> <span data-ttu-id="5a587-739">Ek uzantılar için destek gelecekteki sürümlerde eklenebilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-739">Support for additional extensions may be added in future releases.</span></span>

<span data-ttu-id="5a587-740">Şu anda desteklenen uzantılar aşağıdaki tabloda listelenmiştir:</span><span class="sxs-lookup"><span data-stu-id="5a587-740">The currently supported extensions are listed in the following table:</span></span>

| <span data-ttu-id="5a587-741">Uzantı adı</span><span class="sxs-lookup"><span data-stu-id="5a587-741">Extension Name</span></span>           | <span data-ttu-id="5a587-742">Açıklama</span><span class="sxs-lookup"><span data-stu-id="5a587-742">Description</span></span>                                                                   | <span data-ttu-id="5a587-743">İlgili API</span><span class="sxs-lookup"><span data-stu-id="5a587-743">Relevant API</span></span>                                             |
| ------------------------ | ----------------------------------------------------------------------------- | -------------------------------------------------------- |
| <span data-ttu-id="5a587-744">Anahtar Kullanımı</span><span class="sxs-lookup"><span data-stu-id="5a587-744">Key Usage</span></span>                | <span data-ttu-id="5a587-745">Bir bit alanından içindeki bir sertifikanın ortak anahtarı için kabul edilebilir kullanımlar sağlar</span><span class="sxs-lookup"><span data-stu-id="5a587-745">Provides acceptable uses for a certificate's public key in a bitfield</span></span>         | <span data-ttu-id="5a587-746">nx_secure_x509_key_usage_extension_parse</span><span class="sxs-lookup"><span data-stu-id="5a587-746">nx_secure_x509_key_usage_extension_parse</span></span>           |
| <span data-ttu-id="5a587-747">Genişletilmiş Anahtar Kullanımı</span><span class="sxs-lookup"><span data-stu-id="5a587-747">Extended Key Usage</span></span>       | <span data-ttu-id="5a587-748">, Bir sertifikanın OID kullanarak ortak anahtarı için kabul edilebilir ek kullanımlar sağlar</span><span class="sxs-lookup"><span data-stu-id="5a587-748">Provides additional acceptable uses for a certificate's public key using OIDs</span></span> | <span data-ttu-id="5a587-749">nx_secure_x509_extended_key_usage_extension_parse</span><span class="sxs-lookup"><span data-stu-id="5a587-749">nx_secure_x509_extended_key_usage_extension_parse</span></span> |
| <span data-ttu-id="5a587-750">Konu Diğer Adı</span><span class="sxs-lookup"><span data-stu-id="5a587-750">Subject Alternative Name</span></span> | <span data-ttu-id="5a587-751">Sertifika tarafından da temsil edilen alternatif DNS adları sağlar</span><span class="sxs-lookup"><span data-stu-id="5a587-751">Provides alternative DNS names that are also represented by the certificate</span></span>   | <span data-ttu-id="5a587-752">nx_secure_x509_common_name_dns_check</span><span class="sxs-lookup"><span data-stu-id="5a587-752">nx_secure_x509_common_name_dns_check</span></span>               |

### <a name="unsupported-x509-extensions"></a><span data-ttu-id="5a587-753">Desteklenmeyen X. 509.440 uzantıları</span><span class="sxs-lookup"><span data-stu-id="5a587-753">Unsupported X.509 Extensions</span></span>

<span data-ttu-id="5a587-754">NetX Secure 'ın X. 509.440, desteklenmeyen uzantıları ayıklamak için de bir hizmet sağlar: *nx_secure_x509_extension_find*.</span><span class="sxs-lookup"><span data-stu-id="5a587-754">NetX Secure's X.509 implemenation does provide a service to extract unsupported extensions as well: *nx_secure_x509_extension_find*.</span></span> <span data-ttu-id="5a587-755">Bu API, döndürülen verileri ayrıştırmak için DER kodlu ASN. 1 bilgisine ihtiyaç duyan gelişmiş kullanıcılara yöneliktir.</span><span class="sxs-lookup"><span data-stu-id="5a587-755">This API is intended for advanced users as it requires knowledge of DER-encoded ASN.1 in order to parse the data returned.</span></span> <span data-ttu-id="5a587-756">Bu BT, desteklenen uzantıları ayıklamak için dahili olarak kullanılır, ancak X. 509.440 uzantıları için özelleştirilmiş destek geliştirme konusunda kolaylık sağlaması için sağlanır.</span><span class="sxs-lookup"><span data-stu-id="5a587-756">It it used internally to extract supported extensions but is supplied for convenience in developing customized support for X.509 extensions.</span></span>

<span data-ttu-id="5a587-757">Nx_secure_x509_extension_find kullanmak için, sertifika ve uzantı KIMLIĞIYLE birlikte bir NX_SECURE_X509_EXTENSION geçirilir. Bu, bilinen bir uzantı türü için değişken uzunluklu OID dizesinin tamsayı gösterimidir.</span><span class="sxs-lookup"><span data-stu-id="5a587-757">To use nx_secure_x509_extension_find, a NX_SECURE_X509_EXTENSION is passed in, along with the certificate and an extension ID, which is an integer representation of the variable-length OID string for a known extension type.</span></span> <span data-ttu-id="5a587-758">X. 509.440 uzantıları için desteklenen OID 'lerin tamamı, sayfa 178 ' de nx_secure_x509_extension_find için API başvurusunda verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="5a587-758">A complete list of supported OIDs for X.509 extensions is provided in the API reference for nx_secure_x509_extension_find on page 178.</span></span>

<span data-ttu-id="5a587-759">NX_SECURE_X509_EXTENSION yapısı aşağıdaki gibi tanımlanır:</span><span class="sxs-lookup"><span data-stu-id="5a587-759">The NX_SECURE_X509_EXTENSION structure is defined as follows:</span></span>

```C
typedef struct NX_SECURE_X509_EXTENSION_STRUCT
{
    /* Identifier (maps to OID) for this extension. */
    USHORT nx_secure_x509_extension_id;

    /* Critical flag - boolean value. */
    USHORT nx_secure_x509_extension_critical;

    /* Pointer to DER-encoded extension data. */
    const UCHAR *nx_secure_x509_extension_data;
    ULONG        nx_secure_x509_extension_data_length;
} NX_SECURE_X509_EXTENSION;
```
<span data-ttu-id="5a587-760">Hizmet başarıyla geri döndüğünde, yapı sertifikadaki ilgili verilerle doldurulur.</span><span class="sxs-lookup"><span data-stu-id="5a587-760">When the service returns successfully, the structure will be populated with the relevant data from the certificate.</span></span> <span data-ttu-id="5a587-761">Nx_secure_x509_extension_id alanı genellikle dahili amaçlar için kullanılır, ancak ilgili OID tamsayı temsili ile doldurulur.</span><span class="sxs-lookup"><span data-stu-id="5a587-761">The nx_secure_x509_extension_id field is generally used for internal purposes but will be populated with the relevant OID integer representation.</span></span> <span data-ttu-id="5a587-762">Nx_secure_x509_extension_critical alanı X. 509.440 kritik uzantı bayrak değerini (Boolean) kullanıma sunar.</span><span class="sxs-lookup"><span data-stu-id="5a587-762">The nx_secure_x509_extension_critical field exposes the X.509 critical extension flag value (Boolean).</span></span> <span data-ttu-id="5a587-763">Nx_secure_x509_extension_data ve nx_secure_x509_extension_data_length alanları, uzantı için DER ile kodlanmış ASN. 1 verisi ve bu verilerin sırasıyla uzunluğu ile ilgili bir işaretçi içerir.</span><span class="sxs-lookup"><span data-stu-id="5a587-763">The nx_secure_x509_extension_data and nx_secure_x509_extension_data_length fields contain a pointer to the DER-encoded ASN.1 data for the extension, and the length of that data, respectively.</span></span>

<span data-ttu-id="5a587-764">ASN. 1 veri uzantısının gerçek ayrıştırması bu belgenin kapsamının ötesinde, ancak NetX güvenli TLS kaynağına erişiminiz varsa, desteklenen uzantılar için nx_secure_x509_extension_find çağrıldığı her yerde ayrıştırmayı nasıl yapılacağını görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="5a587-764">Actual parsing of the extension ASN.1 data is beyond the scope of this document, but if you have access to the NetX Secure TLS source you can see how the parsing is done wherever nx_secure_x509_extension_find is called for supported extensions.</span></span>

### <a name="x509-dns-validation"></a><span data-ttu-id="5a587-765">X. 509.440 DNS doğrulaması</span><span class="sxs-lookup"><span data-stu-id="5a587-765">X.509 DNS Validation</span></span>

<span data-ttu-id="5a587-766">TLS 'de ortak bir sertifika doğrulama işlemi, uzak bir ana bilgisayarın Top-Level etki alanı (TLD) adının TLS el sıkışması sırasında bu konak tarafından sağlanmış X. 509.440 sertifikasına göre denetlenmesini içerir.</span><span class="sxs-lookup"><span data-stu-id="5a587-766">A common certificate validation operation in TLS involves checking the Top-Level Domain (TLD) name of a remote host against the X.509 certificate provided by that host during the TLS handshake.</span></span> <span data-ttu-id="5a587-767">Bu işlem, DNS aramasına güvenildiğini varsayarak sertifikanın gerçekten onu sağlayan ana bilgisayar sunucusuyla eşleştiğinden emin olmaya yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="5a587-767">This operation helps to ensure that the certificate does indeed match the host server that provided it, assuming the DNS lookup can be trusted.</span></span> <span data-ttu-id="5a587-768">NetX güvenli TLS 'de, bu işlevsellik, sertifikayı ve konağa erişmek için kullanılan URL 'nin TLD bölümünü içeren bir dizeyi alan hizmet **nx_secure_x509_common_name_dns_check** tarafından sağlanır.</span><span class="sxs-lookup"><span data-stu-id="5a587-768">In NetX Secure TLS, this functionality is provided by the service **nx_secure_x509_common_name_dns_check**, which takes the certificate and a string containing the TLD portion of the URL used to access the host.</span></span> <span data-ttu-id="5a587-769">TLD, sertifikanın ortak ad alanıyla karşılaştırılır ve eşleşiyorsa NX_SUCCESS döndürülür.</span><span class="sxs-lookup"><span data-stu-id="5a587-769">The TLD is compared to the certificate's Common Name field and if it matches, NX_SUCCESS is returned.</span></span> <span data-ttu-id="5a587-770">Ortak ad eşleşmiyorsa, yordam ayrıca X. 509.440 sertifika uzantısının *SubjectAltName* olup olmadığını denetler.</span><span class="sxs-lookup"><span data-stu-id="5a587-770">If the Common Name does not match, the routine will also check for the existence of the X.509 certificate extension *subjectAltName*.</span></span> <span data-ttu-id="5a587-771">Bir subjectAltName varsa, uzantıdaki herhangi bir DNSName girdisi de belirtilen TLD 'ye karşı denetlenir.</span><span class="sxs-lookup"><span data-stu-id="5a587-771">If a subjectAltName is present, any DNSName entries in the extension are also checked against the provided TLD.</span></span> <span data-ttu-id="5a587-772">Bir eşleşme varsa, NX_SUCCESS döndürülür.</span><span class="sxs-lookup"><span data-stu-id="5a587-772">Again, if any match, NX_SUCCESS is returned.</span></span> <span data-ttu-id="5a587-773">Eşleşme bulunmazsa, sertifika doğrulama geri çağrısından dönmek için uygun bir hata döndürülür.</span><span class="sxs-lookup"><span data-stu-id="5a587-773">If no match is found, an error suitable for returning from the certificate validation callback is returned.</span></span>

### <a name="x509-key-usage-and-extended-key-usage-extensions"></a><span data-ttu-id="5a587-774">X. 509.440 anahtar kullanımı ve genişletilmiş anahtar kullanımı uzantıları</span><span class="sxs-lookup"><span data-stu-id="5a587-774">X.509 Key Usage and Extended Key Usage Extensions</span></span>

<span data-ttu-id="5a587-775">X. 509.952 anahtar kullanımı ve genişletilmiş anahtar kullanımı uzantıları, sertifikanın kimliğini doğrularken sertifikanın ortak anahtarının nasıl kullanılabileceği hakkında bilgi sağlar.</span><span class="sxs-lookup"><span data-stu-id="5a587-775">The X.509 Key Usage and Extended Key Usage extensions provide information on how a certificate's public key may be used when authenticating that certificate.</span></span> <span data-ttu-id="5a587-776">Anahtar kullanımı, sertifika imzalanmışsa ve verildiğinde sertifikanın veren tarafından sağlanır.</span><span class="sxs-lookup"><span data-stu-id="5a587-776">The key usage is supplied by the certificate's issuer when the certificate is signed and issued.</span></span> <span data-ttu-id="5a587-777">Anahtar kullanımı, bir TLS ana bilgisayarı tarafından uzak bir TLS ana bilgisayarının kimliğini doğrulamak ve diğer işlemleri gerçekleştirmek için kullanılacak yetkiye sahip olup olmadığını denetlemek için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-777">The key usage may be used by a TLS host to check that the certificate is authorized to be used to authenticate a remote TLS host and perform other operations.</span></span>

<span data-ttu-id="5a587-778">Anahtar kullanımı uzantısı, her bir bitlerin belirli bir anahtar kullanımını temsil ettiği bir basit bitalanından oluşur.</span><span class="sxs-lookup"><span data-stu-id="5a587-778">The Key Usage extension consists of a simple bitfield where each of the bits represents a specific key usage.</span></span> <span data-ttu-id="5a587-779">Bu değerlerin tüm listesi, 183 sayfasında *nx_secure_x509_key_usage_extension_parse* için API başvurusunda verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="5a587-779">A complete list of these values is provided in the API reference for *nx_secure_x509_key_usage_extension_parse* on page 183.</span></span> <span data-ttu-id="5a587-780">Anahtar kullanımı bitlerinin ve anlamları hakkında daha ayrıntılı bir açıklama için bkz. RFC 5280, Bölüm 4.2.1.3.</span><span class="sxs-lookup"><span data-stu-id="5a587-780">For a more complete description of the key usage bits and their meanings, refer to RFC 5280, section 4.2.1.3.</span></span>

<span data-ttu-id="5a587-781">Anahtar kullanımı uzantısı gibi genişletilmiş anahtar kullanımı uzantısı, kabul edilebilir anahtar kullanımı bilgilerini sağlar.</span><span class="sxs-lookup"><span data-stu-id="5a587-781">The Extended Key Usage extension, like the Key Usage extension, provides acceptable key use information.</span></span> <span data-ttu-id="5a587-782">Ancak, rastgele kullanımları desteklemek için, genişletilmiş anahtar kullanımı uzantısı bir bit alanı yerine OID 'leri kullanır.</span><span class="sxs-lookup"><span data-stu-id="5a587-782">However, in order to support arbitrary usages, the Extended Key Usage extension utilizes OIDs instead of a bitfield.</span></span> <span data-ttu-id="5a587-783">NetX güvenli X. 509.440 içinde genişletilmiş anahtar kullanımı uzantısını ayrıştırırken, uygulama tarafından OID 'yi temsil eden bir tamsayı sağlanır. *nx_secure_x509_extended_key_usage_extension_parse* hizmet daha sonra bu OID 'nin mevcut olup olmadığını döndürür.</span><span class="sxs-lookup"><span data-stu-id="5a587-783">When parsing an Extended Key Usage extension in NetX Secure X.509, an integer representing the OID is supplied by the application – the *nx_secure_x509_extended_key_usage_extension_parse* service will then return whether that OID is present.</span></span> <span data-ttu-id="5a587-784">Genişletilmiş anahtar kullanımı için desteklenen OID 'lerin tamamı, sayfa 175 ' de *nx_secure_x509_extended_key_usage_extension_parse* için API başvurusunda verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="5a587-784">A complete list of supported OIDs for Extended Key usage is provided in the API reference for *nx_secure_x509_extended_key_usage_extension_parse* on page 175.</span></span> <span data-ttu-id="5a587-785">OID 'lerin ve anlamları hakkında daha ayrıntılı bir açıklama için, RFC 5280, Bölüm 4.2.1.12 bakın.</span><span class="sxs-lookup"><span data-stu-id="5a587-785">For a more complete description of the OIDs and their meanings, refer to RFC 5280, section 4.2.1.12.</span></span>

### <a name="x509-crl-revocation-status-checking"></a><span data-ttu-id="5a587-786">X. 509.440 CRL Iptal durumu denetimi</span><span class="sxs-lookup"><span data-stu-id="5a587-786">X.509 CRL Revocation Status Checking</span></span>

<span data-ttu-id="5a587-787">X. 509.440, dijital bir sertifika imzalama yetkilisinin imzalandığı sertifikaların geçerliliğini iptal etmesine izin veren, *sertifika Iptal listesi* (CRL) adlı bir mekanizma sağlar.</span><span class="sxs-lookup"><span data-stu-id="5a587-787">X.509 provides a mechanism called the *Certificate Revocation List* (CRL) that allows a digital certificate signing authority to revoke the validity of certificates it has signed.</span></span> <span data-ttu-id="5a587-788">İmza yetkilisinden sertifikaları doğrulaması gereken herhangi bir uygulama, bir CRL alabilir ve bu yetkilinin (veren), belirli bir nedenden dolayı (güvenliği aşılmış özel anahtar gibi) durumunun iptal edilip edilmediğini görmek için CRL 'ye karşı imzalanan tüm sertifikaları karşılaştırabilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-788">Any application that needs to verify certificates from a signing authority can obtain a CRL and compare any certificates signed by that authority (issuer) against the CRL to see if they have had their status revoked for some reason (such as compromised private key).</span></span> <span data-ttu-id="5a587-789">Bu şekilde, uygulama diğer sertifika doğrulama denetimlerini geçiren potansiyel olarak tehlikeli sertifikaları kullanmaktan kaçınabilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-789">In this way, the application can avoid using potentially dangerous certificates that pass other certificate validation checks.</span></span>

<span data-ttu-id="5a587-790">Bir CRL alma, bir uygulama tarafından, önceden tanımlanmış bir sunucudan ya da başka bir yöntemle DER kodlu liste indirerek yapılır.</span><span class="sxs-lookup"><span data-stu-id="5a587-790">Obtaining a CRL is done by an application by downloading the DER-encoded list from a pre-defined server or through some other means.</span></span> <span data-ttu-id="5a587-791">Asıl kurulum, verenin sertifikayı verene göre farklılık gösterir. bu nedenle, NetX güvenliği CRL 'Leri almak için bir mekanizma sağlamaz, ancak bir CRL 'ye karşı sertifikayı denetlemek için bir yordam sağlar, **nx_secure_x509_crl_revocation_check**.</span><span class="sxs-lookup"><span data-stu-id="5a587-791">The actual setup varies from issuer to issuer so NetX Secure does not provide a mechanism for obtaining CRLs, but it does provide a routine to check a certificate against a CRL, **nx_secure_x509_crl_revocation_check**.</span></span>

<span data-ttu-id="5a587-792">API, DER ile kodlanmış bir CRL, bir sertifika deposu (bir TLS oturumunda olduğu gibi) ve denetlenecek sertifikayı alır.</span><span class="sxs-lookup"><span data-stu-id="5a587-792">The API takes a DER-encoded CRL, a certificate store (such as the one in a TLS session) to check against, and the certificate to be checked.</span></span> <span data-ttu-id="5a587-793">Bu yordam ilk olarak CRL 'YI güvenilir depoya (uygulama tarafından belirtilen sertifika deposunun parçası) karşı doğrular.</span><span class="sxs-lookup"><span data-stu-id="5a587-793">The routine first validates the CRL itself against the trusted store (part of the certificate store provided by the application).</span></span> <span data-ttu-id="5a587-794">Bu, hizmet reddi saldırıları için kullanılan sahte CRL 'Lere karşı koruma için önemlidir ve CRL 'nin gerçekten uygun veren tarafından geldiğinden emin olur.</span><span class="sxs-lookup"><span data-stu-id="5a587-794">This is important to protect against fraudulent CRLs being used for Denial-of-Service attacks and establishes that the CRL is actually from the proper issuer.</span></span> <span data-ttu-id="5a587-795">CRL doğrulamasından sonra, veren denetlenir: CRL veren, sertifikanın verenle eşleşmiyorsa, CRL Bu sertifika için geçerli değildir ve bir hata döndürülür.</span><span class="sxs-lookup"><span data-stu-id="5a587-795">Following the CRL validation, the issuer is checked – if the issuer of the CRL does not match the issuer of the certificate, then the CRL is not valid for that certificate and an error is returned.</span></span> <span data-ttu-id="5a587-796">Bu noktada TLS el sıkışma 'nın devam edip edemeyeceğini tespit etmek için uygulamaya gidin.</span><span class="sxs-lookup"><span data-stu-id="5a587-796">It is up to the application to determine whether the TLS handshake can continue at this point.</span></span> <span data-ttu-id="5a587-797">Verenler eşleşiyorsa, doğrulanan sertifikanın seri numarası için CRL aranır.</span><span class="sxs-lookup"><span data-stu-id="5a587-797">If the issuers do match, then the CRL is searched for the serial number of the certificate being validated.</span></span> <span data-ttu-id="5a587-798">Listede seri numarası varsa, sertifikanın iptal edildiğini belirten bir hata döndürülür.</span><span class="sxs-lookup"><span data-stu-id="5a587-798">If the serial number is present in the list, an error indicating that the certificate has been revoked is returned.</span></span> <span data-ttu-id="5a587-799">Eşleşme bulunmazsa NX_SUCCESS döndürülür.</span><span class="sxs-lookup"><span data-stu-id="5a587-799">If no match is found, NX_SUCCESS is returned.</span></span>

## <a name="client-certificate-authentication-in-netx-secure-tls"></a><span data-ttu-id="5a587-800">NetX güvenli TLS 'de istemci sertifikası kimlik doğrulaması</span><span class="sxs-lookup"><span data-stu-id="5a587-800">Client Certificate Authentication in NetX Secure TLS</span></span>

<span data-ttu-id="5a587-801">X. 509.440 sertifika kimlik doğrulaması kullanılırken, TLS protokolü, TLS sunucu örneğinin tanımlama için bir sertifika sağlamasını gerektirir, ancak varsayılan olarak TLS Istemci örneğinin kimlik doğrulama için bir sertifika sağlaması gerekmez, bunun yerine başka bir kimlik doğrulama biçimi (örn. bir Kullanıcı adı/parola birleşimi) kullanın.</span><span class="sxs-lookup"><span data-stu-id="5a587-801">When using X.509 certificate authentication, the TLS protocol requires that the TLS Server instance provide a certificate for identification, but by default the TLS Client instance does not need to provide a certificate for authentication, using another form of authentication instead (e.g. a username/password combination).</span></span> <span data-ttu-id="5a587-802">Bu, Web siteleri için Internet 'te en yaygın TLS kullanımıyla eşleşir.</span><span class="sxs-lookup"><span data-stu-id="5a587-802">This matches the most common use of TLS on the Internet for Web sites.</span></span> <span data-ttu-id="5a587-803">Örneğin, bir çevrimiçi perakende sitesi, sunucunun meşru olduğunu bir Web tarayıcısı kullanarak potansiyel bir müşteriyi kanıtlamaları gerekir, ancak kullanıcı belirli bir hesaba erişmek için bir oturum açma/parola kullanacaktır.</span><span class="sxs-lookup"><span data-stu-id="5a587-803">For example, an online retail site must prove to a potential customer using a web browser that the server is legitimate, but the user will use a login/password to access a specific account.</span></span>

<span data-ttu-id="5a587-804">Ancak, varsayılan durum her zaman tercih edilmez, bu nedenle TLS sunucu örneğinin uzak Istemciden bir sertifika istemesine izin verir.</span><span class="sxs-lookup"><span data-stu-id="5a587-804">However, the default case is not always desirable, so TLS optionally allows for the TLS Server instance to request a certificate from the remote Client.</span></span> <span data-ttu-id="5a587-805">Bu özellik etkinleştirildiğinde, TLS sunucusu el sıkışma sırasında TLS Istemcisine bir CertificateRequest iletisi gönderir.</span><span class="sxs-lookup"><span data-stu-id="5a587-805">When this feature is enabled, the TLS Server will send a CertificateRequest message to the TLS Client during the handshake.</span></span> <span data-ttu-id="5a587-806">Istemci kendi sertifikası ile yanıt vermelidir ve Istemcinin bu sertifikayla ilişkili eşleşen özel anahtara sahip olduğunu belirten bir şifreleme belirteci içeren bir CertificateVerify iletisi.</span><span class="sxs-lookup"><span data-stu-id="5a587-806">The Client must respond with a certificate of its own and a CertificateVerify message which contains a cryptographic token proving that the Client owns the matching private key associated with that certificate.</span></span> <span data-ttu-id="5a587-807">Doğrulama başarısız olursa veya sertifika sunucuda güvenilir bir sertifikaya bağlı değilse, TLS el sıkışması başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="5a587-807">If the verification fails or the certificate is not connected to a trusted certificate on the Server, the TLS handshake fails.</span></span>

<span data-ttu-id="5a587-808">TLS 'de Istemci sertifikası kimlik doğrulaması için iki ayrı durum vardır: aşağıdaki bölümlerde her iki durum da ele alınmaktadır.</span><span class="sxs-lookup"><span data-stu-id="5a587-808">There are two separate cases for Client Certificate Authentication in TLS – the following sections cover both cases.</span></span>

### <a name="client-certificate-authentication-for-tls-clients"></a><span data-ttu-id="5a587-809">TLS Istemcileri için istemci sertifikası kimlik doğrulaması</span><span class="sxs-lookup"><span data-stu-id="5a587-809">Client Certificate Authentication for TLS Clients</span></span>

<span data-ttu-id="5a587-810">TLS Istemcisi, istemci kimlik doğrulaması için bir sertifika isteyen bir sunucuyla bağlantı kurmayı deneyebilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-810">A TLS Client may attempt a connection to a server that requests a certificate for client authentication.</span></span> <span data-ttu-id="5a587-811">Bu durumda, Istemcinin sunucuya bir sertifika sağlaması ve eşleşen özel anahtara sahip olduğunu doğrulaması gerekir ya da sunucu, TLS el sıkışmasını sonlandırır.</span><span class="sxs-lookup"><span data-stu-id="5a587-811">In this case the Client must provide a certificate to the server and verify that it owns the matching private key or the Server will terminate the TLS handshake.</span></span>

<span data-ttu-id="5a587-812">NetX güvenli TLS 'de, bu özelliği desteklemeye yönelik özel bir yapılandırma yoktur, ancak uygulamanın *nx_secure_tls_local_certificate_add* HIZMETINI kullanarak TLS istemci örneği için bir yerel kimlik sertifikası sağlaması gerekecektir.</span><span class="sxs-lookup"><span data-stu-id="5a587-812">In NetX Secure TLS, there is no special configuration to support this feature but the application will have to provide a local identification certificate for the TLS Client instance using the *nx_secure_tls_local_certificate_add* service.</span></span> <span data-ttu-id="5a587-813">Uygulama tarafından bir sertifika sağlanmazsa ancak uzak sunucu Istemci sertifikası kimlik doğrulamasını kullanıyorsa ve bir sertifika isterse, TLS el sıkışması başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="5a587-813">If no certificate is provided by the application but the remote server is using Client Certificate Authentication and requests a certificate, the TLS handshake will fail.</span></span> <span data-ttu-id="5a587-814">*Nx_secure_tls_local_certificate_add* Ile tls oturumuna girilen SERTIFIKA, TLS el sıkışma 'nı tamamlayabilmeniz için uzak sunucu tarafından tanınmalıdır.</span><span class="sxs-lookup"><span data-stu-id="5a587-814">The certificate provided to the TLS Session with *nx_secure_tls_local_certificate_add* must be recognized by the remote server in order to complete the TLS handshake.</span></span>

### <a name="client-certificate-authentication-for-tls-servers"></a><span data-ttu-id="5a587-815">TLS sunucuları için istemci sertifikası kimlik doğrulaması</span><span class="sxs-lookup"><span data-stu-id="5a587-815">Client Certificate Authentication for TLS Servers</span></span>

<span data-ttu-id="5a587-816">Istemci sertifikası kimlik doğrulaması için TLS sunucu durumu, özelliğin isteğe bağlı olması nedeniyle TLS Istemci durumundan biraz daha karmaşıktır.</span><span class="sxs-lookup"><span data-stu-id="5a587-816">The TLS Server case for Client Certificate Authentication is slightly more complex than the TLS Client case due to the feature being optional.</span></span> <span data-ttu-id="5a587-817">Bu durumda, TLS sunucusunun özel olarak uzak TLS Istemcisinden bir sertifika istemesi, ardından uzak Istemcinin eşleşen özel anahtara sahip olduğunu doğrulamak için CertificateVerify iletisini işlemesi gerekir ve ardından sunucu, Istemci tarafından belirtilen sertifikanın, yerel güvenilen sertifika deposundaki bir sertifikaya izlenip izlenmeyeceğini denetmelidir.</span><span class="sxs-lookup"><span data-stu-id="5a587-817">In this case, the TLS Server needs to specifically request a certificate from the remote TLS Client, then process the CertificateVerify message to verify that the remote Client owns the matching private key, and then the Server must check that the certificate provided by the Client can be traced to a certificate in the local trusted certificate store.</span></span>

<span data-ttu-id="5a587-818">NetX güvenli TLS sunucu örneklerinde Istemci sertifikası kimlik doğrulaması tarafından denetlenir</span><span class="sxs-lookup"><span data-stu-id="5a587-818">In NetX Secure TLS Server instances, Client Certificate Authentication is controlled by</span></span> <br>
<span data-ttu-id="5a587-819">*NX <span class="underline"> _</span> güvenli <span class="underline">_</span>TLS <span class="underline"> _</span> oturumu <span class="underline">_</span>istemcisi <span class="underline"> _</span> doğrulama <span class="underline">_</span>etkinleştirme* ve</span><span class="sxs-lookup"><span data-stu-id="5a587-819">the *nx <span class="underline">_</span>secure <span class="underline">_</span>tls <span class="underline">_</span>session <span class="underline">_</span>client <span class="underline">_</span>verify<span class="underline">_</span>enable* and</span></span><br>
<span data-ttu-id="5a587-820">*NX <span class="underline"> _</span> güvenli <span class="underline">_</span>TLS <span class="underline"> _</span> oturum <span class="underline">_</span>istemcisi <span class="underline"> _</span> Doğrula <span class="underline">_</span>hizmetleri devre dışı bırak* .</span><span class="sxs-lookup"><span data-stu-id="5a587-820">*nx <span class="underline">_</span>secure <span class="underline">_</span>tls <span class="underline">_</span>session <span class="underline">_</span>client <span class="underline">_</span>verify<span class="underline">_</span>disable* services.</span></span>

<span data-ttu-id="5a587-821">Istemci sertifikası kimlik doğrulamasını etkinleştirmek için bir uygulamanın şunu çağırması gerekir</span><span class="sxs-lookup"><span data-stu-id="5a587-821">To enable Client Certificate Authentication, an application must call</span></span><br>
<span data-ttu-id="5a587-822">*NX <span class="underline"> _</span> güvenli <span class="underline">_</span>tls <span class="underline"> _</span> oturum <span class="underline">_</span>istemcisi <span class="underline"> _</span> Verify <span class="underline">_</span>* *nx_secure_tls_session_start* çağrılmadan önce TLS sunucusu oturum örneğiyle etkinleştirin.</span><span class="sxs-lookup"><span data-stu-id="5a587-822">*nx <span class="underline">_</span>secure <span class="underline">_</span>tls <span class="underline">_</span>session <span class="underline">_</span>client <span class="underline">_</span>verify <span class="underline">_</span>enable* with the TLS Server session instance before calling *nx_secure_tls_session_start*.</span></span> <span data-ttu-id="5a587-823">Bu hizmeti TLS Istemci bağlantıları için kullanılan bir TLS oturumunda çağırmanın hiçbir etkisi olmayacaktır.</span><span class="sxs-lookup"><span data-stu-id="5a587-823">Note that calling this service on a TLS Session that is used for TLS Client connections will have no effect.</span></span>

<span data-ttu-id="5a587-824">Istemci sertifikası kimlik doğrulaması etkinleştirildiğinde, TLS sunucusu, TLS el sıkışması sırasında uzak TLS Istemcisinden bir sertifika ister.</span><span class="sxs-lookup"><span data-stu-id="5a587-824">When Client Certificate Authentication is enabled, the TLS Server will request a certificate from the remote TLS Client during the TLS handshake.</span></span> <span data-ttu-id="5a587-825">NetX güvenli TLS sunucusunda, Istemci sertifikası *nx <span class="underline"> _</span> <span class="underline">_ secure_tls</span>güvenilen <span class="underline"> _</span> <span class="underline">_ sertifika</span>* ile oluşturulan güvenilen sertifikaların deposuna göre denetlenir ve X. 509.440 veren zincirini aşağıdaki şekilde ekleyin.</span><span class="sxs-lookup"><span data-stu-id="5a587-825">In NetX Secure TLS Server, the Client certificate is checked against the store of trusted certificates created with *nx <span class="underline">_</span>secure_tls <span class="underline">_</span>trusted <span class="underline">_</span>certificate<span class="underline">_</span>add* following the X.509 issuer chain.</span></span> <span data-ttu-id="5a587-826">Uzak Istemci, kimlik sertifikasını Güvenilen depodaki bir sertifikaya bağlayan bir zincir sağlamalıdır veya TLS el sıkışması başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="5a587-826">The remote Client must provide a chain that connects its identity certificate to a certificate in the trusted store or the TLS handshake will fail.</span></span> <span data-ttu-id="5a587-827">Ayrıca, CertificateVerify iletisi işlemi başarısız olursa, TLS el sıkışması da başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="5a587-827">Additionally, if the CertificateVerify message processing fails, the TLS handshake will also fail.</span></span>

<span data-ttu-id="5a587-828">CertificateVerify yöntemi için kullanılan imza yöntemleri TLS sürüm 1,0 ve TLS sürüm 1,1 için düzeltilir ve TLS sunucusu tarafından TLS sürümü 1,2 olarak belirtilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-828">The signature methods used for the CertificateVerify method are fixed for TLS version 1.0 and TLS version 1.1, and are specified by the TLS Server in TLS version 1.2.</span></span> <span data-ttu-id="5a587-829">TLS 1,2 için, desteklenen imza yöntemleri genellikle şifreleme yöntemi tablosunda sağlanan ilgili yöntemleri izler, ancak genellikle SHA-256 ile RSA (şifreleme yöntemleriyle TLS başlatma hakkında daha fazla bilgi için bkz. "NetX güvenli TLS 'de şifreleme" bölümüne bakın).</span><span class="sxs-lookup"><span data-stu-id="5a587-829">For TLS 1.2, the signature methods supported generally follow the relevant methods supplied in the cryptographic method table, but typically RSA with SHA-256 (see the section "Cryptography in NetX Secure TLS" for more information on initializing TLS with cryptographic methods).</span></span>

## <a name="cryptography-in-netx-secure-tls"></a><span data-ttu-id="5a587-830">NetX güvenli TLS 'de şifreleme</span><span class="sxs-lookup"><span data-stu-id="5a587-830">Cryptography in NetX Secure TLS</span></span>

<span data-ttu-id="5a587-831">TLS, ağ iletişimlerini güvenli hale getirmek için şifreleme kullanılabilecek bir protokol tanımlar.</span><span class="sxs-lookup"><span data-stu-id="5a587-831">TLS defines a protocol in which cryptography can be used to secure network communications.</span></span> <span data-ttu-id="5a587-832">Bu nedenle, TLS kullanıcıları için oldukça geniş kapsamlı açık kullanılacak şekilde gerçek şifrelemeyi bırakır.</span><span class="sxs-lookup"><span data-stu-id="5a587-832">As such, it leaves the actual cryptography to be used fairly wide open for TLS users.</span></span> <span data-ttu-id="5a587-833">Belirtim yalnızca tek bir ciphersuite 'in uygulanması için gereklidir; TLS 1,2 olması durumunda bu ciphersuite TLS_RSA_WITH_AES_128_CBC_SHA, ortak anahtar işlemleri için RSA kullanımını ve oturum şifreleme için 128 bit anahtarlarla CBC modunda AES modunu ve ileti kimlik doğrulama karmaları için SHA-1 ' i belirtir.</span><span class="sxs-lookup"><span data-stu-id="5a587-833">The specification only requires a single ciphersuite to be implemented – in the case of TLS 1.2, that ciphersuite is TLS_RSA_WITH_AES_128_CBC_SHA, indicating the use of RSA for public-key operations, AES in CBC mode with 128-bit keys for session encryption, and SHA-1 for message authentication hashes.</span></span>

<span data-ttu-id="5a587-834">TLS 1,2 uyumlu olduğu, NetX güvenliği, zorunlu TLS_RSA_WITH_AES_128_CBC_SHA ciphersuite 'i varsayılan olarak sağlar, ancak donanım özellikleri ve diğer hususlar nedeniyle her bir şifreleme yöntemi için olası uygulama sayısına veriliyorsa, NetX güvenliği, kullanıcının TLS ile hangi şifreleme yöntemlerinin kullanılacağını belirtmesini sağlayan bir genel şifreleme API 'SI sağlar.</span><span class="sxs-lookup"><span data-stu-id="5a587-834">Being TLS 1.2-compliant, NetX Secure enables the mandatory TLS_RSA_WITH_AES_128_CBC_SHA ciphersuite by default, but given the number of possible implementations for each of the cryptographic methods due to hardware capabilities and other considerations, NetX Secure provides a generic cryptographic API that allows a user to specify which cryptographic methods to use with TLS.</span></span>

<span data-ttu-id="5a587-835">NOTE: genel şifreleme API mekanizması, kullanıcıların kendi cipherpaketlerini uygulamasına olanak tanır, ancak bu, TLS cipherpaketlerine ve uzantılarına alışkın olan ileri düzey kullanıcılar için önerilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-835">NOTE: The generic cryptographic API mechanism also allows users to implement their own ciphersuites, but this is recommended for advanced users who are familiar with the TLS ciphersuites and extensions.</span></span> <span data-ttu-id="5a587-836">Kendi cipherpaketlerinizi desteklemeye ilgileniyorsanız lütfen hızlı mantık temsilcinizle iletişime geçin.</span><span class="sxs-lookup"><span data-stu-id="5a587-836">Please contact your Express Logic representative if you are interested in supporting your own ciphersuites.</span></span>

### <a name="cryptographic-methods"></a><span data-ttu-id="5a587-837">Şifreleme yöntemleri</span><span class="sxs-lookup"><span data-stu-id="5a587-837">Cryptographic Methods</span></span>

<span data-ttu-id="5a587-838">NetX güvenli TLS, belirli donanım platformları için donanım sürücüleri olan yazılımda DES, 3DES, AES, MD5, HMAC-MD5, SHA-1, HMAC-SHA1, SHA-256, HMAC-SHA256, RSA ve ECC (seçili eğrileri) uygular.</span><span class="sxs-lookup"><span data-stu-id="5a587-838">NetX Secure TLS implements DES, 3DES, AES, MD5, HMAC-MD5, SHA-1, HMAC-SHA1, SHA-256, HMAC-SHA256, RSA, and ECC (selected curves) in software with hardware drivers for certain hardware platforms.</span></span> <span data-ttu-id="5a587-839">Bir uygulama NetX güvenli ile birlikte sunulan şifreleme yordamlarını kullanabilir veya son kullanıcı ya da üçüncü taraflar tarafından sunulan özel yordamları kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-839">An application may use the cryptographic routines provided with NetX Secure, or use custom routines provided by the end user or third parties.</span></span>

<span data-ttu-id="5a587-840">*NX_CRYPTO_METHOD* , bir uygulama Için, NETX güvenli TLS ile kullanılmak üzere bir şifreleme algoritmasının belirli bir uygulamasını açıklamaya yönelik olarak tasarlanmış bir denetim bloğudur.</span><span class="sxs-lookup"><span data-stu-id="5a587-840">The *NX_CRYPTO_METHOD* is a control block designed for an application to describe a particular implementation of a cryptographic algorithm to be used with NetX Secure TLS.</span></span> <span data-ttu-id="5a587-841">NX_CRYPTO_METHOD bir uygulama *,* kendi şifre uygulamasını güvenle NETX güvenli bir şekilde tümleştirebilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-841">With the *NX_CRYPTO_METHOD,* an application can easily integrate their own crypto implementation into NetX Secure.</span></span> <span data-ttu-id="5a587-842">*NX_CRYPTO_METHOD* yapısı şöyle bildirilmiştir:</span><span class="sxs-lookup"><span data-stu-id="5a587-842">The *NX_CRYPTO_METHOD* structure is declared as:</span></span>

```C
typedef struct NX_CRYPTO_METHOD_STRUCT
{
    /* Symbolic name of the algorithm. */
    USHORT nx_crypto_algorithm;

    /* Size of the key, in bits. */
    USHORT nx_crypto_key_size_in_bits;

    /* Size of the IV block, in bits, used for encryption. */
    USHORT nx_crypto_IV_size_in_bits;

    /* Size of the ICV block, in bits, used for authentication. */
    USHORT nx_crypto_ICV_size_in_bits;

    /* Size of the crypto block, in bytes. */
    ULONG nx_crypto_block_size_in_bytes;

    /* Size of the metadata area. */
    ULONG nx_crypto_metadata_size;

    /* nx_crypto_init function initializes the crypto method with the
        "secret key" or other state  information. The initialization 
        routine should return a handle to the caller.  This handle is 
        used in subsequent crypto operations to identify the session.  
        */

    UINT (*nx_crypto_init) (NX_CRYPTO_METHOD     *method,
                            UCHAR               *key, 
                            NX_CRYPTO_KEY_SIZE   key_size_in_bits,
                            VOID               **handler,
                            VOID                *crypto_metadata,
                            VOID                 crypto_metadata_size);

    /* NetX Secure calls the nx_crypto_cleanup routine when a TLS
       session is to be deleted (or updated).  Resources allocated 
       during the crypto operation should be released in this routine.  
       */
    UINT (*nx_crypto_cleanup) (VOID *handler);

    /* nx_crypto_operation is the actual crypto or hash operation. Note 
       that both input and output buffers are prepared by the caller. 
       For encryption or decryption operations, the crypto operation 
       routine uses the output buffer for encrypted or decrypted data. 
       For authentication operations, the authentication routine shall 
       use the output buffer for the digest. */
    UINT (*nx_crypto_operation)(UINT  op, 
                  VOID              *handler, 
                  NX_CRYPTO_METHOD  *method,
                  UCHAR             *key,
                  NX_CRYPTO_KEY_SIZE key_size_in_bits,
                  UCHAR             *input,
                  ULONG              input_length_in_byte,
                  UCHAR             *iv_ptr,
                  UCHAR             *output,
                  ULONG              output_length_in_byte,
                  VOID              *crypto_metadata,
                  VOID               crypto_metadata_size,
                  NX_PACKET*         packet_ptr,
                  VOID (*nx_crypto_hw_process_callback(NX_PACKET 
                                                       *packet_ptr, 
                                                        UINT status);
} NX_CRYPTO_METHOD;
```

<span data-ttu-id="5a587-843">*NX_CRYPTO_METHOD* yapısındaki her öğenin açıklaması aşağıda verilmiştir:</span><span class="sxs-lookup"><span data-stu-id="5a587-843">Below is the description of each element in the *NX_CRYPTO_METHOD* structure:</span></span>

- <span data-ttu-id="5a587-844">nx_crypto_algorithm: Bu alan, değişken *yönteminde* açıklanan algoritmayı tanımlar NETX güvenli TLS için bazı geçerli değerler aşağıdaki gibidir (belirli değerler için nx_crypto_const. h öğesine bakın):</span><span class="sxs-lookup"><span data-stu-id="5a587-844">nx_crypto_algorithm: This field identifies the algorithm described in the variable *method* Some valid values for NetX Secure TLS are as follows (refer to nx_crypto_const.h for specific values):</span></span>
    
  - <span data-ttu-id="5a587-845">NX_CRYPTO_NONE</span><span class="sxs-lookup"><span data-stu-id="5a587-845">NX_CRYPTO_NONE</span></span>    
  - <span data-ttu-id="5a587-846">NX_CRYPTO_ENCRYPTION_NULL</span><span class="sxs-lookup"><span data-stu-id="5a587-846">NX_CRYPTO_ENCRYPTION_NULL</span></span>    
  - <span data-ttu-id="5a587-847">NX_CRYPTO_ENCRYPTION_AES_CBC</span><span class="sxs-lookup"><span data-stu-id="5a587-847">NX_CRYPTO_ENCRYPTION_AES_CBC</span></span>    
  - <span data-ttu-id="5a587-848">NX_CRYPTO_AUTHENTICATION_NONE</span><span class="sxs-lookup"><span data-stu-id="5a587-848">NX_CRYPTO_AUTHENTICATION_NONE</span></span>    
  - <span data-ttu-id="5a587-849">TLS_HASH_SHA_1</span><span class="sxs-lookup"><span data-stu-id="5a587-849">TLS_HASH_SHA_1</span></span>    
  - <span data-ttu-id="5a587-850">TLS_HASH_SHA_256</span><span class="sxs-lookup"><span data-stu-id="5a587-850">TLS_HASH_SHA_256</span></span>    
  - <span data-ttu-id="5a587-851">TLS_HASH_MD5</span><span class="sxs-lookup"><span data-stu-id="5a587-851">TLS_HASH_MD5</span></span>    
  - <span data-ttu-id="5a587-852">TLS_CIPHER_RSA</span><span class="sxs-lookup"><span data-stu-id="5a587-852">TLS_CIPHER_RSA</span></span>    
  - <span data-ttu-id="5a587-853">TLS_CIPHER_NULL</span><span class="sxs-lookup"><span data-stu-id="5a587-853">TLS_CIPHER_NULL</span></span>

- <span data-ttu-id="5a587-854">nx_crypto_key_size_in_bits: Bu alan, yöntemi tarafından kullanılan gizli anahtarın boyutunu belirtir.</span><span class="sxs-lookup"><span data-stu-id="5a587-854">nx_crypto_key_size_in_bits: this field specifies the size of the secret key used by the method.</span></span>

- <span data-ttu-id="5a587-855">nx_crypto_IV_size_in_bits: Bu alan, başlatma vektörünün (IV) boyutunu belirtir.</span><span class="sxs-lookup"><span data-stu-id="5a587-855">nx_crypto_IV_size_in_bits: this field specifies the size of the Initialization Vector (IV).</span></span> <span data-ttu-id="5a587-856">Çoğu durumda IV bloğunun yalnızca şifreleme/şifre çözme algoritmaları için kullanıldığını unutmayın.</span><span class="sxs-lookup"><span data-stu-id="5a587-856">Note that in most cases the IV block is only used for encryption/decryption algorithms.</span></span> <span data-ttu-id="5a587-857">Kimlik doğrulama ve doğrulama algoritmaları nadiren bu alanı kullanır.</span><span class="sxs-lookup"><span data-stu-id="5a587-857">Authentication and verification algorithms rarely use this field.</span></span>

- <span data-ttu-id="5a587-858">nx_crypto_ICV_size_in_bits: Bu alan, bütünlük denetim değeri (ıCV) bloğunun boyutunu belirtir.</span><span class="sxs-lookup"><span data-stu-id="5a587-858">nx_crypto_ICV_size_in_bits: this field specifies the size of the Integrity Check Value (ICV) block.</span></span> <span data-ttu-id="5a587-859">NOTE: Bu blok IPSec kullanımına yöneliktir ve TLS 'de kullanılmaz.</span><span class="sxs-lookup"><span data-stu-id="5a587-859">NOTE: This block is for IPsec usage and is unused in TLS.</span></span> <span data-ttu-id="5a587-860">Daha fazla bilgi için bkz. NetX Duo IPSec.</span><span class="sxs-lookup"><span data-stu-id="5a587-860">See NetX Duo IPsec for more information.</span></span>

- <span data-ttu-id="5a587-861">nx_crypto_block_size_in_bytes: Bu alan, blok tabanlı şifrelemeler için şifreleme algoritması bloğunun boyutunu bayt cinsinden belirtir.</span><span class="sxs-lookup"><span data-stu-id="5a587-861">nx_crypto_block_size_in_bytes: this field specifies the size of the cryptographic algorithm block for block-based ciphers, in bytes.</span></span> <span data-ttu-id="5a587-862">Çoğu durumda bu, şifreleme yordamları ve nadiren kimlik doğrulama yordamları tarafından kullanılır.</span><span class="sxs-lookup"><span data-stu-id="5a587-862">In most cases this is used by encryption routines and rarely by authentication routines.</span></span>

- <span data-ttu-id="5a587-863">nx_crypto_metadata_area_size: Bu alan, bu yöntemin gerektirdiği meta veri alanının boyutunu belirtir.</span><span class="sxs-lookup"><span data-stu-id="5a587-863">nx_crypto_metadata_area_size: this field specifies the size of the metadata area this method requires.</span></span> <span data-ttu-id="5a587-864">Her uygulama, bazı belleğin durum bilgilerini depolamasını veya ara verileri (örneğin, anahtar dönüştürme malzemesi) depolamasını veya bir karalama alanı olarak kullanılmasını gerektirebilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-864">Each implementation may require certain memory to store its state information, or to store intermediate data (such as key transformation material), or to use as a scratch area.</span></span> <span data-ttu-id="5a587-865">Bu alanda bir uygulama için gereken alan miktarı belirtilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-865">The amount of space required by an implementation is specified in this field.</span></span> <span data-ttu-id="5a587-866">Uygulama, bir TLS oturumu oluştururken bellek alanı sağlar.</span><span class="sxs-lookup"><span data-stu-id="5a587-866">The application provides the memory space when creating a TLS session.</span></span> <span data-ttu-id="5a587-867">Bu meta veri alanını yönetmeden şifreleme işlevi sorumludur.</span><span class="sxs-lookup"><span data-stu-id="5a587-867">The cryptographic function is responsible for managing this metadata area.</span></span>

- <span data-ttu-id="5a587-868">nx_crypto_init: Bu, şifreleme algoritmasının başlatma işlevidir.</span><span class="sxs-lookup"><span data-stu-id="5a587-868">nx_crypto_init: This is the initialization function for the cryptographic algorithm.</span></span> <span data-ttu-id="5a587-869">Başlatma yordamına gerek gerektirmeyen bir uygulama için, bu alan NX_NULL olarak ayarlanabilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-869">For an implementation that does not need an initialization routine, this field may be set to NX_NULL.</span></span> <span data-ttu-id="5a587-870">Başlatma işlevinin tipik kullanımı, algoritmanın iç veri yapısını başlatmasıdır.</span><span class="sxs-lookup"><span data-stu-id="5a587-870">A typical use of an initialization function is to initialize the internal data structure for the algorithm.</span></span> <span data-ttu-id="5a587-871">NetX güvenli TLS, bu işlevi dahili olarak çağırarak şifreleme yordamının başlatılmasını işleymeyecektir.</span><span class="sxs-lookup"><span data-stu-id="5a587-871">NetX Secure TLS will handle initialization of the cryptographic routine by calling this function internally.</span></span>

<span data-ttu-id="5a587-872">Başlatma işlevinin prototipi şunlardır:</span><span class="sxs-lookup"><span data-stu-id="5a587-872">The prototype for the initialization function is:</span></span>

```C
UINT crypto_init_function(NX_CRYPTO_METHOD *method, 
                          UCHAR *key, 
                          UINT  key_size_in_bits, 
                          VOID  **handle, 
                          VOID  *crypto_metadata_area, 
                          ULONG crypto_metadata_area_size);
```

  - <span data-ttu-id="5a587-873">yöntemi, şifreleme yöntemi denetim bloğunun bir işaretçisidir.</span><span class="sxs-lookup"><span data-stu-id="5a587-873">method is a pointer to the crypto method control block.</span></span>

  - <span data-ttu-id="5a587-874">anahtar, veri paketlerini işlemek için gizli anahtar dizesidir.</span><span class="sxs-lookup"><span data-stu-id="5a587-874">key is the secret key string for processing the data packets.</span></span>

  - <span data-ttu-id="5a587-875">key_size_in_bits, gizli anahtarın bit cinsinden boyutunu tanımlar.</span><span class="sxs-lookup"><span data-stu-id="5a587-875">key_size_in_bits defines the size of the secret key, in bits.</span></span>

  - <span data-ttu-id="5a587-876">tanıtıcı, belirli bir şifre oturumunu tanımlayan uygulama tanımlı bir öğedir.</span><span class="sxs-lookup"><span data-stu-id="5a587-876">handle is an implementation-defined item that identifies a particular crypto session.</span></span> <span data-ttu-id="5a587-877">Değer, başlatma yordamı tarafından oluşturulur ve çağırana geri geçirilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-877">The value is generated by the initialization routine, and is passed back to the caller.</span></span> <span data-ttu-id="5a587-878">Sonraki şifreleme işlemi veya temizleme yordamı, oturumu belirlemek için bu tanıtıcıyı kullanır.</span><span class="sxs-lookup"><span data-stu-id="5a587-878">The subsequent crypto operation or clean up routine use this handle to identify the session.</span></span>

  - <span data-ttu-id="5a587-879">crypto_metadata, bu algoritmanın uygulanması için gerekli olan meta veri alanına yönelik bir işaretçidir.</span><span class="sxs-lookup"><span data-stu-id="5a587-879">crypto_metadata is a pointer to the metadata area required by the implementation of this algorithm.</span></span> <span data-ttu-id="5a587-880">Meta veri alanı gerektirmeyen algoritmalar için bu alan NX_NULL olarak ayarlanır ve başlatma yordamı meta veri alanına erişmemelidir.</span><span class="sxs-lookup"><span data-stu-id="5a587-880">For algorithms that do not need a metadata area this field is set to NX_NULL and the initialization routine must not access the metadata area.</span></span>

  - <span data-ttu-id="5a587-881">crypto_metadata_size meta veri alanının boyutunu belirtir.</span><span class="sxs-lookup"><span data-stu-id="5a587-881">crypto_metadata_size specifies the size of the metadata area.</span></span> <span data-ttu-id="5a587-882">Meta veri alanı olmadan oluşturulan SAs için, bu alan sıfır olarak ayarlanır ve başlatma yordamı meta veri alanına erişmemelidir.</span><span class="sxs-lookup"><span data-stu-id="5a587-882">For SAs created without metadata area, this field is set to zero, and the initialization routine must not access the metadata area.</span></span>

  - <span data-ttu-id="5a587-883">Başlatma işlemi başarılı olursa bu yordam *NX_SUCCESS* döndürür.</span><span class="sxs-lookup"><span data-stu-id="5a587-883">This routine shall return *NX_SUCCESS* if the initialization process is successful.</span></span> <span data-ttu-id="5a587-884">Çağıran, diğer tüm dönüş değerlerini hata olarak değerlendirir.</span><span class="sxs-lookup"><span data-stu-id="5a587-884">The caller treats any other return value as failure.</span></span>

- <span data-ttu-id="5a587-885">nx_crypto_cleanup: Bu, bir şifreleme algoritmasının uygulanması için tanımlanan Temizleme yordamlamasıdır.</span><span class="sxs-lookup"><span data-stu-id="5a587-885">nx_crypto_cleanup: This is the cleanup routine defined for the implementation of a crypto algorithm.</span></span> <span data-ttu-id="5a587-886">Bir TLS oturumu silindiğinde veya yeniden başlatıldığında çağrılır.</span><span class="sxs-lookup"><span data-stu-id="5a587-886">It is invoked when a TLS session is deleted or restarted.</span></span>

<span data-ttu-id="5a587-887">Temizleme işlevinin prototipi şunlardır:</span><span class="sxs-lookup"><span data-stu-id="5a587-887">The prototype for the cleanup function is:</span></span>

```C
UINT crypto_cleanup_function(VOID *handle);
```
- <span data-ttu-id="5a587-888">tanıtıcı, çağıran tarafından Temizleme işlevine geçirilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-888">handle is passed to the cleanup function by the caller.</span></span> <span data-ttu-id="5a587-889">Tanıtıcı, şifreleme başlatma yordamı tarafından başlatılır ve şifreleme algoritması durumunu tanımlamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="5a587-889">The handle is initialized by the crypto initialization routine and used to identify cryptographic algorithm state.</span></span>

- <span data-ttu-id="5a587-890">Temizleme işlemi başarılı olursa bu yordam *NX_SUCCESS* döndürür.</span><span class="sxs-lookup"><span data-stu-id="5a587-890">This routine shall return *NX_SUCCESS* if the cleanup process is successful.</span></span> <span data-ttu-id="5a587-891">Çağıran, diğer tüm dönüş değerlerini hata olarak değerlendirir.</span><span class="sxs-lookup"><span data-stu-id="5a587-891">The caller treats any other return value as failure.</span></span>

- <span data-ttu-id="5a587-892">nx_crypto_operation: Bu, gerçek şifreleme, şifre çözme ve kimlik doğrulama hizmetlerini gerçekleştiren bir yordamdır.</span><span class="sxs-lookup"><span data-stu-id="5a587-892">nx_crypto_operation: This is the routine that performs the actual encryption, decryption, and authentication services.</span></span> <span data-ttu-id="5a587-893">İşlem yordamının işlev prototipi şunlardır:</span><span class="sxs-lookup"><span data-stu-id="5a587-893">The function prototype of the operation routine is:</span></span>

```C
UINT crypto_operation_function(UINT   op,
          VOID  *handle,  
          NX_CRYPTO_METHOD* method,
          UCHAR *key,
          UCHAR  key_size_in_bits,
          UCHAR* input,
          ULONG  input_length_in_byte,
          UCHAR* iv_ptr,
          UCHAR* output,
          ULONG  output_length_in_byte,
          VOID *crypto_metadata,
          ULONG crypto_metadata_size,
          NX_PACKET *packet_ptr,
          VOID (*nx_crypto_hw_process_callback)(NX_PACKET 
                          *packet_ptr, UINT status));
```

- <span data-ttu-id="5a587-894">Op, bu yordamın yürütülmesi beklenen işlem türünü gösterir. Geçerli değerler şunlardır:</span><span class="sxs-lookup"><span data-stu-id="5a587-894">op indicates the type of operation this routine is expected to carry out. Valid values are:</span></span>
    
    - <span data-ttu-id="5a587-895">NX_CRYPTO_ENCRYPT</span><span class="sxs-lookup"><span data-stu-id="5a587-895">NX_CRYPTO_ENCRYPT</span></span>
    - <span data-ttu-id="5a587-896">NX_CRYPTO_DECRYPT</span><span class="sxs-lookup"><span data-stu-id="5a587-896">NX_CRYPTO_DECRYPT</span></span>
    - <span data-ttu-id="5a587-897">NX_CRYPTO_AUTHENTICATE</span><span class="sxs-lookup"><span data-stu-id="5a587-897">NX_CRYPTO_AUTHENTICATE</span></span>
    - <span data-ttu-id="5a587-898">NX_CRYPTO_VERIFY</span><span class="sxs-lookup"><span data-stu-id="5a587-898">NX_CRYPTO_VERIFY</span></span>

- <span data-ttu-id="5a587-899">tanıtıcı, çağıran tarafından işlem işlevine geçirilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-899">handle is passed to the operation function by the caller.</span></span> <span data-ttu-id="5a587-900">Şifre başlatma yordamı tarafından oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="5a587-900">It is generated by the crypto initialization routine.</span></span>
- <span data-ttu-id="5a587-901">Yöntem, şifreleme yöntemi denetim bloğuna işaret ediyor</span><span class="sxs-lookup"><span data-stu-id="5a587-901">method points to the crypto method control block</span></span>
- <span data-ttu-id="5a587-902">anahtar, bu işlem için kullanılan gizli anahtara işaret ediyor</span><span class="sxs-lookup"><span data-stu-id="5a587-902">key points to the secret key used for this operation</span></span>
- <span data-ttu-id="5a587-903">key_size_in_bits, bit cinsinden gizli anahtar boyutudur</span><span class="sxs-lookup"><span data-stu-id="5a587-903">key_size_in_bits is the size of the secret key in bits</span></span>
- <span data-ttu-id="5a587-904">Giriş, üzerinde çalışılan iletinin başlangıcına yönelik bir işaretçidir.</span><span class="sxs-lookup"><span data-stu-id="5a587-904">input is a pointer to the beginning of the message to be operated on.</span></span>
- <span data-ttu-id="5a587-905">input_length_in_byte, üzerinde işletiedilecek iletinin boyutunu belirtmek için çağıran tarafından geçirilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-905">input_length_in_byte is passed by the caller to indicate the size of the message to be operated on.</span></span>
- <span data-ttu-id="5a587-906">iv_ptr, çağıran tarafından bir IV bloğunun başlangıcına işaret etmek üzere ayarlanır.</span><span class="sxs-lookup"><span data-stu-id="5a587-906">iv_ptr is setup by the caller to point to the beginning of an IV block.</span></span> <span data-ttu-id="5a587-907">IV bloğunun belleğinin arayan tarafından sağlandığını unutmayın.</span><span class="sxs-lookup"><span data-stu-id="5a587-907">Note that the memory for the IV block is provided by the caller.</span></span> <span data-ttu-id="5a587-908">Şifreleme için, işlem işlevi bu bellek bloğuna IV bilgilerini yazmalıdır; şifre çözme için, işlem işlevi bu bellek bloğundan IV bilgilerini almalıdır.</span><span class="sxs-lookup"><span data-stu-id="5a587-908">For encryption, the operation function should write the IV information into this memory block; for decryption, the operation function should retrieve the IV information from this memory block.</span></span> <span data-ttu-id="5a587-909">Kimlik doğrulama ve doğrulama işlemi algoritmaları genellikle başlatma vektörünü kullanmaz.</span><span class="sxs-lookup"><span data-stu-id="5a587-909">Algorithms for authentication and verification operation typically do not use the initialization vector.</span></span>
- <span data-ttu-id="5a587-910">çıktı, çağrı tarafından çıkış arabelleğini işaret etmek üzere ayarlanır.</span><span class="sxs-lookup"><span data-stu-id="5a587-910">output is setup by the caller to point to an output buffer.</span></span> <span data-ttu-id="5a587-911">Çıktı arabelleği için bellek, çağıran tarafından sağlanır.</span><span class="sxs-lookup"><span data-stu-id="5a587-911">Note that the memory for the output buffer is provided by the caller.</span></span> <span data-ttu-id="5a587-912">Şifreleme için, işlem işlevi şifre metnini çıkış arabelleğine yazmalıdır; şifre çözme için, işlem arabelleğe alınan metni (şifresiz metin) çıkış arabelleğine yazmalıdır; kimlik doğrulaması için, karma değeri çıkış arabelleğine yazılır.</span><span class="sxs-lookup"><span data-stu-id="5a587-912">For encryption, the operation function should write the cipher text to the output buffer; for decryption, the operation should write the deciphered text (clear text) to the output buffer; for authentication, the hash value shall be written to the output buffer.</span></span> <span data-ttu-id="5a587-913">Doğrulama için, çıkış arabelleği karma bilgileri depolamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="5a587-913">For verification, the output buffer is used to store hash information.</span></span>
- <span data-ttu-id="5a587-914">output_length_in_byte, çıkış arabelleğinin boyutunu gösterir</span><span class="sxs-lookup"><span data-stu-id="5a587-914">output_length_in_byte indicates the size of the output buffer</span></span>
- <span data-ttu-id="5a587-915">crypto_metadata, bu şifreleme işlemi tarafından kullanılacak meta veri alanına işaret eder.</span><span class="sxs-lookup"><span data-stu-id="5a587-915">crypto_metadata points to the metadata area to be used by this crypto operation.</span></span> <span data-ttu-id="5a587-916">Şifreleme meta verileri alanı genellikle crypto_init_function tarafından başlatılır.</span><span class="sxs-lookup"><span data-stu-id="5a587-916">The crypto metadata area is typically initialized by crypto_init_function.</span></span>
- <span data-ttu-id="5a587-917">crypto_metadata_size meta veri alanının boyutunu gösterir.</span><span class="sxs-lookup"><span data-stu-id="5a587-917">crypto_metadata_size indicates the size of the metadata area.</span></span>
- <span data-ttu-id="5a587-918">İşlem işlemi başarılı olursa bu yordam *NX_SUCCESS* döndürür.</span><span class="sxs-lookup"><span data-stu-id="5a587-918">This routine shall return *NX_SUCCESS* if the operation process is successful.</span></span> <span data-ttu-id="5a587-919">Çağıran, diğer tüm dönüş değerlerini hata olarak değerlendirir.</span><span class="sxs-lookup"><span data-stu-id="5a587-919">The caller treats any other return value as failure.</span></span>
- <span data-ttu-id="5a587-920">packet_ptr: işlenmekte olan verileri içeren paket.</span><span class="sxs-lookup"><span data-stu-id="5a587-920">packet_ptr: The packet that contains the data being processed.</span></span> <span data-ttu-id="5a587-921">NOTE: Bu parametre TLS tarafından kullanılmıyor ve NX_NULL olarak ayarlanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="5a587-921">NOTE: This parameter is unused by TLS and should be set to NX_NULL.</span></span>
- <span data-ttu-id="5a587-922">nx_crypto_hw_process_callback: şifreleme yöntemi tarafından sağlanmış bir geri çağırma işlevi.</span><span class="sxs-lookup"><span data-stu-id="5a587-922">nx_crypto_hw_process_callback: A callback function provided by the encryption method.</span></span> <span data-ttu-id="5a587-923">Bu, şifreleme işlevi donanım tarafından sağlandıysa ve bir geri çağırma yordamı gerektiriyorsa kullanılır.</span><span class="sxs-lookup"><span data-stu-id="5a587-923">This is used if the crypto function is provided by hardware and requires a callback routine.</span></span>

<span data-ttu-id="5a587-924">NetX güvenli TLS aşağıdaki şifreleme yöntemlerini sağlar:</span><span class="sxs-lookup"><span data-stu-id="5a587-924">NetX Secure TLS provides the following encryption methods:</span></span>

- <span data-ttu-id="5a587-925">*AES*</span><span class="sxs-lookup"><span data-stu-id="5a587-925">*AES*</span></span>  
- <span data-ttu-id="5a587-926">*RSA*</span><span class="sxs-lookup"><span data-stu-id="5a587-926">*RSA*</span></span>  
- <span data-ttu-id="5a587-927">*DEĞER*</span><span class="sxs-lookup"><span data-stu-id="5a587-927">*NULL*</span></span>

<span data-ttu-id="5a587-928">NetX güvenli TLS aşağıdaki kimlik doğrulama yöntemlerini sağlar:</span><span class="sxs-lookup"><span data-stu-id="5a587-928">NetX Secure TLS provides the following authentication methods:</span></span>

- <span data-ttu-id="5a587-929">*HMAC-MD5*</span><span class="sxs-lookup"><span data-stu-id="5a587-929">*HMAC-MD5*</span></span>  
- <span data-ttu-id="5a587-930">*HMAC-SHA1*</span><span class="sxs-lookup"><span data-stu-id="5a587-930">*HMAC-SHA1*</span></span>  
- <span data-ttu-id="5a587-931">*HMAC-SHA256*</span><span class="sxs-lookup"><span data-stu-id="5a587-931">*HMAC-SHA256*</span></span>

<span data-ttu-id="5a587-932">Aşağıdaki örneklerde, *NX_CRYPTO_METHOD* yapısının NETX Duo IPSec tarafından sunulan şifreleme ve kimlik doğrulama yöntemlerini kullanmak üzere nasıl yapılandırılacağı gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="5a587-932">The following examples illustrate how to configure the *NX_CRYPTO_METHOD* structure to use the encryption and authentication methods provided by NetX Duo IPsec.</span></span>

<span data-ttu-id="5a587-933">***AES***</span><span class="sxs-lookup"><span data-stu-id="5a587-933">***AES:***</span></span>

```C
/* AES-CBC 128. */
NX_CRYPTO_METHOD crypto_method_aes_cbc_128 = 
{
    /* AES crypto algorithm                             */
    NX_CRYPTO_ENCRYPTION_AES_CBC,                       

    /* Key size in bits. For AES-128 this value is 128  */
    NX_CRYPTO_AES_128_KEY_LEN_IN_BITS,              
   
    /* IV size in bits.  For AES-128 this value is 128  */
    NX_CRYPTO_AES_IV_LEN_IN_BITS,

    /* ICV size in bits, not used.                      */
    0,                                              

    /* Block size in bytes.  For AES this value is 16   */
    (NX_CRYPTO_AES_BLOCK_SIZE_IN_BITS >> 3),        

    /* Metadata size in bytes, for AES this value is 262*/
    sizeof(NX_CRYPTO_AES),              

    /* AES-CBC initialization routine.                  */
    _nx_secure_crypto_method_aes_init,               

    /* AES-CBC cleanup routine, not used.               */
    NX_NULL,                                        

    /* AES-CBC operation                                */
    _nx_secure_crypto_method_aes_operation           
};

/* RSA. */
NX_CRYPTO_METHOD crypto_method_rsa = 
{
    /* RSA crypto algorithm                             */
    TLS_CIPHER_RSA,                       

    /* Key size. RSA key sizes vary, so set to 0.         */
    0,              
   
    /* IV size in bits.  RSA does not use an IV.         */
    0,

    /* ICV size in bits, not used.                      */
    0,                                              

    /* Block size in bytes.  RSA does not have a block size. */
    0,        

    /* Metadata size in bytes, for RSA use the control block. */
    sizeof(NX_CRYPTO_RSA),              

    /* RSA initialization routine.                  */
    _nx_secure_crypto_method_rsa_init,               

    /* Cleanup routine, not used.                    */
    NX_NULL,                                        

    /* RSA operation                                */
    _nx_secure_crypto_method_rsa_operation           

};
```
<span data-ttu-id="5a587-934">***DEĞER***</span><span class="sxs-lookup"><span data-stu-id="5a587-934">***NULL***</span></span>

```C
/* NULL encryption method. */
NX_CRYPTO_METHOD crypto_method_null = 
{
    NX_CRYPTO_ENCRYPTION_NULL,/* Name of the crypto algorithm  */
    0,                        /* Key size in bits, not used    */
    0,                        /* IV size in bits, not used     */
    0,                        /* ICV size in bits, not used    */
    4,                        /* Block size in bytes           */
    0,                        /* Metadata size in bytes        */
    NX_NULL,                  /* Initialization routine,unused */
    NX_NULL,                  /* Cleanup routine, not used     */
    _nx_secure_crypto_method_null_operation  /* NULL operation  
*/
}; 
```
<span data-ttu-id="5a587-935">***HMAC-SHA1***</span><span class="sxs-lookup"><span data-stu-id="5a587-935">***HMAC-SHA1***</span></span>
```C
NX_CRYPTO_METHOD crypto_method_hmac_sha1 = 
{
    /* HMAC SHA1 algorithm                               */
    TLS_HASH_SHA1,            


    /* Key size in bits. For HMAC-SHA1 this value is 160 */ 
    NX_CRYPTO_HMAC_SHA1_KEY_LEN_IN_BITS,              

    /* IV size in bits, not used                         */
    0,                                            

    /* Transmitted ICV size in bits. Unused.             */
    0, 

    /* Block size in bytes, not used                     */
    0,                                            

    /* Metadata size in bytes                            */
    sizeof(NX_SHA1_HMAC),                                            

    /* Initialization routine, not used                  */
    NX_NULL,                                      

    /* Cleanup routine, not used                         */
    NX_NULL,                                          

    /* HMAC SHA1 operation                               */
    _nx_secure_crypto_method_hmac_sha1_operation   
};
```
<span data-ttu-id="5a587-936">***SEÇIM***</span><span class="sxs-lookup"><span data-stu-id="5a587-936">***NONE***</span></span>

<span data-ttu-id="5a587-937">Şifreleme veya kimlik doğrulama hizmetinin gerekli olmadığı IPSec modülüne işaret etmek için **NX_CRYPTO_NONE** özel bir yöntem kullanılır.</span><span class="sxs-lookup"><span data-stu-id="5a587-937">A special method **NX_CRYPTO_NONE** is used to signal the IPsec module that the encryption or the authentication service is not required.</span></span> <span data-ttu-id="5a587-938">Aşağıdaki şekilde yapılandırılır:</span><span class="sxs-lookup"><span data-stu-id="5a587-938">It is configured as follows:</span></span>

```C
/* NX_CRYPTO_NONE means encryption or authentication
   method is not needed.  */
NX_CRYPTO_METHOD crypto_method_none = 
{
    NX_CRYPTO_NONE,       /* Name of the crypto algorithm */
    0,                    /* Key size in bits, not used   */
    0,                    /* IV size in bits, not used    */
    0,                    /* ICV size in bits, not used   */
    0,                    /* Block size in bytes          */
    0,                    /* Metadata size in bytes       */
    NX_NULL,              /* Initialization routine, not used */
    NX_NULL,              /* Cleanup routine, not used    */
    NX_NULL               /* NULL operation               */
};                                               
```
### <a name="initializing-tls-with-cryptographic-methods"></a><span data-ttu-id="5a587-939">Şifreleme yöntemleriyle TLS başlatma</span><span class="sxs-lookup"><span data-stu-id="5a587-939">Initializing TLS with Cryptographic Methods</span></span>

<span data-ttu-id="5a587-940">Önceki bölümde açıklanan şifreleme yöntemi imzaları ile uyumlu olan şifreleme yordamlarınızı oluşturduktan sonra, bir NX_SECURE_TLS_SESSION denetim bloğu başlattığınızda bu uygulamaları TLS 'ye geçirmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="5a587-940">Once you have created your cryptographic routines conforming to the cryptographic method signatures described in the previous section, you will need to pass them into TLS when you initialize an NX_SECURE_TLS_SESSION control block.</span></span> <span data-ttu-id="5a587-941">Bu işlem TLS hizmeti nx_secure_tls_session_create yapılır:</span><span class="sxs-lookup"><span data-stu-id="5a587-941">This is done in the TLS service nx_secure_tls_session_create:</span></span>

```C
UINT  nx_secure_tls_session_create(
              NX_SECURE_TLS_SESSION*     session_ptr,
              const NX_SECURE_TLS_CRYPTO*    tls_cipher_table,
              VOID*                encryption_metadata_area,
              ULONG                 encryption_metadata_size
);
```
- <span data-ttu-id="5a587-942">session_pointer, NX_SECURE_TLS_SESSION denetim blobunun bir işaretçisidir.</span><span class="sxs-lookup"><span data-stu-id="5a587-942">session_pointer is a pointer to your NX_SECURE_TLS_SESSION control block.</span></span>
- <span data-ttu-id="5a587-943">tls_cipher_table, aşağıda açıklanan NX_SECURE_TLS_CRYPTO denetim bloğunun bir işaretçisidir.</span><span class="sxs-lookup"><span data-stu-id="5a587-943">tls_cipher_table is a pointer to an NX_SECURE_TLS_CRYPTO control block, described below.</span></span>
- <span data-ttu-id="5a587-944">encryption_metadata_area, TLS 'de şifreleme yordamları tarafından kullanılan alana işaret eder.</span><span class="sxs-lookup"><span data-stu-id="5a587-944">encryption_metadata_area points to space used by cryptographic routines in TLS.</span></span>
- <span data-ttu-id="5a587-945">encryption_metadata_size, meta veri alanının bayt cinsinden boyutudur.</span><span class="sxs-lookup"><span data-stu-id="5a587-945">encryption_metadata_size is the size of the metadata area in bytes.</span></span>

### <a name="elliptic-curve-cryptography-ecc-in-netx-secure-tls"></a><span data-ttu-id="5a587-946">NetX güvenli TLS 'de Eliptik Eğri Şifreleme (ECC)</span><span class="sxs-lookup"><span data-stu-id="5a587-946">Elliptic Curve Cryptography (ECC) in NetX Secure TLS</span></span>

<span data-ttu-id="5a587-947">Eliptik Eğri Şifreleme (ECC), RSA yerine kullanılabilecek bir ortak anahtar şifreleme şeması sağlar.</span><span class="sxs-lookup"><span data-stu-id="5a587-947">Elliptic Curve Cryptography (ECC) provides a public-key cryptography scheme that can be used instead of RSA.</span></span> <span data-ttu-id="5a587-948">ECC genellikle daha hızlıdır ve RSA 'dan daha küçük anahtarlar kullanır, böylece gömülü TLS için değerli bir seçenek olabilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-948">ECC is typically faster and uses smaller keys than RSA so it can be a valuable option for embedded TLS.</span></span> <span data-ttu-id="5a587-949">Azure RTOS 6,0 ' den önceki X-Ware sürümlerinde ECC, ECC kaynak kodunun projenize yüklenmesini gerektiren bir eklenti olarak gönderilmiştir.</span><span class="sxs-lookup"><span data-stu-id="5a587-949">In X-Ware versions prior to Azure RTOS 6.0, ECC was shipped as an add-on, requiring installation of the ECC source code into your project.</span></span> <span data-ttu-id="5a587-950">Azure RTOS 6,0, ana hat kod tabanına tümleştirilmiş ECC dosyalarını yüklemek artık gerekli değildir.</span><span class="sxs-lookup"><span data-stu-id="5a587-950">Azure RTOS 6.0 integrated ECC into the mainline codebase so installation of the ECC files is no longer necessary.</span></span> <span data-ttu-id="5a587-951">Ancak, ECC hala önceki sürümlerle aynı başlatmayı gerektirir.</span><span class="sxs-lookup"><span data-stu-id="5a587-951">However, ECC still requires the same initialization as those previous versions.</span></span>

### <a name="supported-ecc-curves"></a><span data-ttu-id="5a587-952">Desteklenen ECC eğrileri</span><span class="sxs-lookup"><span data-stu-id="5a587-952">Supported ECC curves</span></span>

<span data-ttu-id="5a587-953">NetX Secure, eğrilerin parçalarını göre uygular <http://www.secg.org/sec2-v2.pdf> .</span><span class="sxs-lookup"><span data-stu-id="5a587-953">NetX Secure implements parts of the curves as per <http://www.secg.org/sec2-v2.pdf>.</span></span> <span data-ttu-id="5a587-954">Aşağıdaki eğriler desteklenir<sup>18</sup>:</span><span class="sxs-lookup"><span data-stu-id="5a587-954">Thefollowing curves are supported<sup>18</sup>:</span></span>

  - <span data-ttu-id="5a587-955">secp256r1</span><span class="sxs-lookup"><span data-stu-id="5a587-955">secp256r1</span></span> 
  - <span data-ttu-id="5a587-956">secp384r1</span><span class="sxs-lookup"><span data-stu-id="5a587-956">secp384r1</span></span> 
  - <span data-ttu-id="5a587-957">secp521r1</span><span class="sxs-lookup"><span data-stu-id="5a587-957">secp521r1</span></span> 

<span data-ttu-id="5a587-958">Diğer ECC eğrileri kullanılıyorsa, *nx_secure_tls_session_start ()* yordamı, desteklenmeyen eğrilerin kullanıldığını belirten NX_SECURE_TLS_NO_SUPPORTED_CIPHERS hata döndürür.</span><span class="sxs-lookup"><span data-stu-id="5a587-958">If other ECC curves are used, the *nx_secure_tls_session_start()* routine will return the error NX_SECURE_TLS_NO_SUPPORTED_CIPHERS indicating that unsupported curves were used.</span></span>

<span data-ttu-id="5a587-959">TLS sertifika zincirinin de ECC algoritmalarıyla şifrelendiğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="5a587-959">Note that TLS certificate chain may be encrypted by ECC-algorithms as well.</span></span> <span data-ttu-id="5a587-960">TLS Istemcisi tarafından sunulan eğriler desteklense de, sertifika zincirinde kullanılan ECC eğrisi desteklenmez.</span><span class="sxs-lookup"><span data-stu-id="5a587-960">Even though the curves provided by the TLS Client are supported, it is possible that the ECC curve used in the certificate chain is not supported.</span></span> <span data-ttu-id="5a587-961">Bu durumda, *nx_secure_tls_session_start* rutin NX_SECURE_TLS_UNSUPPORTED_PUBLIC_CIPHER döndürür.</span><span class="sxs-lookup"><span data-stu-id="5a587-961">In this case, *nx_secure_tls_session_start* routine returns NX_SECURE_TLS_UNSUPPORTED_PUBLIC_CIPHER.</span></span>

<span data-ttu-id="5a587-962">Nx_crypto_generic_ciphersuites. c ' de ECC için varsayılan ciphersuite tablosu örneği verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="5a587-962">A default ciphersuite table example for ECC is provided in nx_crypto_generic_ciphersuites.c.</span></span> <span data-ttu-id="5a587-963">Ciphersuite tabloları hakkında daha fazla bilgi için bkz. "TLS şifreleme şifre tablosu" bölümü.</span><span class="sxs-lookup"><span data-stu-id="5a587-963">See section "TLS Cryptographic Cipher Table" for more information on ciphersuite tables.</span></span>

18. <span data-ttu-id="5a587-964">Secp192r1 ve secp224r1are eğrileri için uygulamaların eski uygulamalar için de sağlandığını unutmayın.</span><span class="sxs-lookup"><span data-stu-id="5a587-964">Note that implementations for the curves secp192r1 and secp224r1are also provided for legacy applications.</span></span> <span data-ttu-id="5a587-965">Ancak bu eğriler artık zayıf olarak değerlendirilir ve yeni uygulama geliştirme için kullanılmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="5a587-965">However these curves are now considered weak and SHOULD NOT be used for new application development.</span></span>

### <a name="crypto-methods-for-ecc"></a><span data-ttu-id="5a587-966">ECC için şifreleme yöntemleri</span><span class="sxs-lookup"><span data-stu-id="5a587-966">Crypto Methods for ECC</span></span>

<span data-ttu-id="5a587-967">Eliptik Eğri grupları için şifreleme yöntemleri:</span><span class="sxs-lookup"><span data-stu-id="5a587-967">Crypto methods for Elliptic Curve groups:</span></span>

- <span data-ttu-id="5a587-968">NX_CRYPTO_METHOD crypto_method_ec_secp192<sup>15</sup>;</span><span class="sxs-lookup"><span data-stu-id="5a587-968">NX_CRYPTO_METHOD crypto_method_ec_secp192<sup>15</sup>;</span></span>  
- <span data-ttu-id="5a587-969">NX_CRYPTO_METHOD crypto_method_ec_secp224<sup>15</sup>;</span><span class="sxs-lookup"><span data-stu-id="5a587-969">NX_CRYPTO_METHOD crypto_method_ec_secp224<sup>15</sup>;</span></span>  
- <span data-ttu-id="5a587-970">NX_CRYPTO_METHOD crypto_method_ec_secp256;</span><span class="sxs-lookup"><span data-stu-id="5a587-970">NX_CRYPTO_METHOD crypto_method_ec_secp256;</span></span>  
- <span data-ttu-id="5a587-971">NX_CRYPTO_METHOD crypto_method_ec_secp384;</span><span class="sxs-lookup"><span data-stu-id="5a587-971">NX_CRYPTO_METHOD crypto_method_ec_secp384;</span></span>  
- <span data-ttu-id="5a587-972">NX_CRYPTO_METHOD crypto_method_ec_secp521;</span><span class="sxs-lookup"><span data-stu-id="5a587-972">NX_CRYPTO_METHOD crypto_method_ec_secp521;</span></span>

<span data-ttu-id="5a587-973">ECC eğrilerinin şifre yöntemleri nx_crypto_generic_ciphersuites. c ' de tanımlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="5a587-973">The crypto methods for ECC curves are defined in nx_crypto_generic_ciphersuites.c.</span></span>

<span data-ttu-id="5a587-974">ECDHE için şifreleme yöntemi:</span><span class="sxs-lookup"><span data-stu-id="5a587-974">Crypto method for ECDHE:</span></span>

- <span data-ttu-id="5a587-975">NX_CRYPTO_METHOD crypto_method_ecdhe;</span><span class="sxs-lookup"><span data-stu-id="5a587-975">NX_CRYPTO_METHOD crypto_method_ecdhe;</span></span>

<span data-ttu-id="5a587-976">ECDSA için şifreleme yöntemi:</span><span class="sxs-lookup"><span data-stu-id="5a587-976">Crypto method for ECDSA:</span></span>

- <span data-ttu-id="5a587-977">NX_CRYPTO_METHOD crypto_method_ecdsa;</span><span class="sxs-lookup"><span data-stu-id="5a587-977">NX_CRYPTO_METHOD crypto_method_ecdsa;</span></span>

<span data-ttu-id="5a587-978">ECDSA ve ECDHE şifreleme yöntemleri nx_crypto_generic_ciphersuites. c ' de tanımlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="5a587-978">ECDSA and ECDHE crypto methods are defined in nx_crypto_generic_ciphersuites.c.</span></span>

<span data-ttu-id="5a587-979">RSA, SHA, AES gibi diğer şifre yöntemleriyle birlikte birleştirildiğinde, ciphersuite arama tablosu için yapı taşları olarak kullanılabilirler.</span><span class="sxs-lookup"><span data-stu-id="5a587-979">Combined with other crypto methods such as RSA, SHA, AES, they can be used as building blocks for the ciphersuite lookup table.</span></span>

### <a name="enabling-ecc-support-for-tls"></a><span data-ttu-id="5a587-980">TLS için ECC desteğini etkinleştirme</span><span class="sxs-lookup"><span data-stu-id="5a587-980">Enabling ECC Support for TLS</span></span>

<span data-ttu-id="5a587-981">ECC, TLS için varsayılan olarak etkindir.</span><span class="sxs-lookup"><span data-stu-id="5a587-981">ECC is enabled by default for TLS.</span></span> <span data-ttu-id="5a587-982">ECC desteğini devre dışı bırakmak için NX_SECURE_DISABLE_ECC_CIPHERSUITE sembol tanımlanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="5a587-982">To disable ECC support, the symbol NX_SECURE_DISABLE_ECC_CIPHERSUITE must be defined.</span></span>

<span data-ttu-id="5a587-983">Değişikliğin etkili olması için, NetX güvenli kitaplığını ve bu kitaplığı kullanan tüm uygulamaları yeniden oluşturmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="5a587-983">For the change to take effect, you will need to rebuild the NetX Secure Library and all applications that use that library.</span></span>

<span data-ttu-id="5a587-984">Uygulama kodunda, TLS oturumu oluşturulduktan sonra API n *x_secure_tls_ecc_initialize ()* çağrılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="5a587-984">In the application code, the API n *x_secure_tls_ecc_initialize()* must be called after the TLS session is created.</span></span> <span data-ttu-id="5a587-985">Bu API, TLS anahtar değişimi işlemleri ve sertifika doğrulaması için kullanılacak eğrilerin türünü TLS oturumuna bildirir.</span><span class="sxs-lookup"><span data-stu-id="5a587-985">This API notifies the TLS session of the type of curves to be used for TLS key exchange operations and certificate verification.</span></span> <span data-ttu-id="5a587-986">TLS el sıkışma aşamasında, bir ECC algoritması seçilirse, hangi eğrinin kullanılacağına karar vermek için istemci ve sunucu Exchange ECC eğrisi ile ilgili parametreleri seçilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-986">During the TLS handshake phase, if an ECC algorithm is selected the client and server exchange ECC curve-related parameters to decide which curve to use.</span></span>

<span data-ttu-id="5a587-987">Aşağıdaki kod segmenti, API 'nin nasıl kullanılacağını gösterir.</span><span class="sxs-lookup"><span data-stu-id="5a587-987">The following code segment illustrates how to use the API.</span></span> <span data-ttu-id="5a587-988">Bağımsız değişkenlerin (*nx_crypto_ecc_supported_groups, nx_crypto_ecc_supported_groups_size ve nx_crypto_ecc_curves)* tümünün *nx_crypto_generic_ciphersuites. c* içinde tanımlandığını unutmayın.</span><span class="sxs-lookup"><span data-stu-id="5a587-988">Note that the arguments (*nx_crypto_ecc_supported_groups, nx_crypto_ecc_supported_groups_size, and nx_crypto_ecc_curves)* are all defined in *nx_crypto_generic_ciphersuites.c*.</span></span> <span data-ttu-id="5a587-989">Bu nedenle, bu semboller doğrudan kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-989">Therefore these symbols can be used directly.</span></span>

```C
status = nx_secure_tls_ecc_initialize(&tls_session,     
                    nx_crypto_ecc_supported_groups,      
                    nx_crypto_ecc_supported_groups_size,     
                    nx_crypto_ecc_curves);
```
<span data-ttu-id="5a587-990">Nx_crypto_generic_ciphersuites. c ' deki örnek yapılandırma, ECC etkinleştirildiğinde kullanılan bir ECC ciphersuite arama tablosu içerir.</span><span class="sxs-lookup"><span data-stu-id="5a587-990">The example configuration in nx_crypto_generic_ciphersuites.c contains an ECC ciphersuite lookup table that is used when ECC is enabled.</span></span> <span data-ttu-id="5a587-991">ECC kullanmak için, nx_secure_tls_session_create ile TLS oturumları oluştururken nx_crypto_tls_ciphers_ecc ciphersuite tablo parametresi olarak geçirin.</span><span class="sxs-lookup"><span data-stu-id="5a587-991">To use ECC, simply pass nx_crypto_tls_ciphers_ecc as the ciphersuite table parameter when creating TLS sessions with nx_secure_tls_session_create.</span></span> <span data-ttu-id="5a587-992">Örnek tablo hem ECC hem de ECC olmayan cipherpaketleri içerir.</span><span class="sxs-lookup"><span data-stu-id="5a587-992">The example table contains both ECC and non-ECC ciphersuites.</span></span>

### <a name="tls-cryptographic-cipher-table"></a><span data-ttu-id="5a587-993">TLS şifreleme şifre tablosu</span><span class="sxs-lookup"><span data-stu-id="5a587-993">TLS Cryptographic Cipher Table</span></span>

<span data-ttu-id="5a587-994">NX_SECURE_TLS_CRYPTO yapısı şu şekilde tanımlanır:</span><span class="sxs-lookup"><span data-stu-id="5a587-994">The NX_SECURE_TLS_CRYPTO structure is defined as:</span></span>

```C
typedef struct NX_SECURE_METHODS_STRUCT
{
    /* Table that maps ciphersuites to crypto methods. */
    NX_SECURE_TLS_CIPHERSUITE_INFO* nx_secure_tls_ciphersuite_lookup_table;
    USHORT nx_secure_tls_ciphersuite_lookup_table_size;

    /* Table that maps X.509 cipher identifiers to crypto methods. */
    NX_SECURE_X509_CRYPTO *nx_secure_tls_x509_cipher_table;
    USHORT nx_secure_tls_x509_cipher_table_size;

    /* Specific routines needed for specific TLS versions. */
#if (NX_SECURE_TLS_TLS_1_0_ENABLED || NX_SECURE_TLS_TLS_1_1_ENABLED)
    NX_CRYPTO_METHOD *nx_secure_tls_handshake_hash_md5_method;
    NX_CRYPTO_METHOD *nx_secure_tls_handshake_hash_sha1_method;
    NX_CRYPTO_METHOD *nx_secure_tls_prf_1_method;
#endif

#if (NX_SECURE_TLS_TLS_1_2_ENABLED)
    NX_CRYPTO_METHOD *nx_secure_tls_handshake_hash_sha256_method;
    NX_CRYPTO_METHOD *nx_secure_tls_prf_sha256_method;
#endif

#if (NX_SECURE_TLS_TLS_1_3_ENABLED)
    const NX_CRYPTO_METHOD *nx_secure_tls_hkdf_method;
    const NX_CRYPTO_METHOD *nx_secure_tls_hmac_method;
    const NX_CRYPTO_METHOD *nx_secure_tls_ecdhe_method;
#endif

} NX_SECURE_TLS_CRYPTO;
```
<span data-ttu-id="5a587-995">Tablo, genellikle şifreleme yordamları ve modülleriyle bulunan NetX güvenli TLS projesinde bulunan statik bir Sabitte bu yapının girişlerini doldurarak oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="5a587-995">The table is created by filling in the entries for this structure in a static constant located within the NetX Secure TLS project, usually located with the cryptographic routines and modules.</span></span>

<span data-ttu-id="5a587-996">Örneğin, NetX güvenli ile birlikte sunulan yalnızca yazılım ("genel") şifreleme kitaplığı, aşağıdaki tablo tanımını içerir (ECC olmayan ciphersuite desteği için<sup>19</sup>):</span><span class="sxs-lookup"><span data-stu-id="5a587-996">As an example, the software-only ("generic") cryptographic library provided with NetX Secure contains the following table definition (for non-ECC ciphersuite support<sup>19</sup>):</span></span>

```C
/* Define the cipher table object we can pass into TLS. */
const NX_SECURE_TLS_CRYPTO nx_crypto_tls_ciphers =
{
    /* TLS Ciphersuite lookup table and size. */
    _nx_crypto_ciphersuite_lookup_table,
    sizeof(_nx_crypto_ciphersuite_lookup_table) / 
    sizeof(NX_SECURE_TLS_CIPHERSUITE_INFO),

    /* X.509 certificate cipher table and size. */
    _nx_crypto_x509_cipher_lookup_table,
    sizeof(_nx_crypto_x509_cipher_lookup_table) / sizeof(NX_SECURE_X509_CRYPTO),

    /* TLS version-specific methods. */
#if (NX_SECURE_TLS_TLS_1_0_ENABLED || NX_SECURE_TLS_TLS_1_1_ENABLED)
    &crypto_method_md5,
    &crypto_method_sha1,
    &crypto_method_tls_prf_1,
#endif

#if (NX_SECURE_TLS_TLS_1_2_ENABLED)
    &crypto_method_sha256,
    &crypto_method_tls_prf_sha_256
#endif

#if (NX_SECURE_TLS_TLS_1_3_ENABLED)
    &crypto_method_hkdf,
    &crypto_method_hmac,
    &crypto_method_ecdhe,
#endif
};
```
<span data-ttu-id="5a587-997">Yapıda, ilk giriş TLS ciphersuite tablosudur.</span><span class="sxs-lookup"><span data-stu-id="5a587-997">In the structure, the first entry is the TLS ciphersuite table.</span></span> <span data-ttu-id="5a587-998">NX_SECURE_TLS_CIPHERSUITE_INFO yapısı, şifreleme yordamlarını (NX_CRYPTO_METHOD işaretçileri biçiminde), TLS belirtimlerinde tanımlandığı şekilde belirli cipherpaketlerine eşler.</span><span class="sxs-lookup"><span data-stu-id="5a587-998">The NX_SECURE_TLS_CIPHERSUITE_INFO structure maps cryptographic routines (in the form of NX_CRYPTO_METHOD pointers) to specific ciphersuites as defined in the TLS specifications.</span></span> <span data-ttu-id="5a587-999">İkinci değer, tablodaki ilk alan tarafından işaret edilen girdi sayısıdır.</span><span class="sxs-lookup"><span data-stu-id="5a587-999">The second value is the number of entries in the table pointed to by the first field.</span></span>

<span data-ttu-id="5a587-1000">Sonraki alan, dijital sertifikaları işlerken X. 509.440 tarafından kullanılan bir yordamlar tablosuna işaret eder ve yapı NX_SECURE_X509_CRYPTO, NX_SECURE_TLS_CIPHERSUITE_INFO biçiminde benzerdir.</span><span class="sxs-lookup"><span data-stu-id="5a587-1000">The next field points to a table of routines used by X.509 when processing digital certificates and the structure NX_SECURE_X509_CRYPTO is similar in form to NX_SECURE_TLS_CIPHERSUITE_INFO.</span></span> <span data-ttu-id="5a587-1001">Aşağıdaki alan tablodaki girdi sayısıdır.</span><span class="sxs-lookup"><span data-stu-id="5a587-1001">The following field is the number of entries in the table.</span></span>

<span data-ttu-id="5a587-1002">Aşağıdaki arama tablosu, belirli bir TLS sürümü için gereken bir dizi yordamlardır.</span><span class="sxs-lookup"><span data-stu-id="5a587-1002">Following the lookup table are a number of routines needed for specific versions of TLS.</span></span> <span data-ttu-id="5a587-1003">Örneğin, TLS sürüm 1,2 ' den önce, anahtar oluşturma ve el sıkışma karma yordamları SHA-1 ve MD5 birleşimini kullanacak şekilde düzeltildi – Bu yordamlar için yöntemler özel cipherpaketlerine bağlı olmadıkları için özel olarak şifre yapısında çağırılır.</span><span class="sxs-lookup"><span data-stu-id="5a587-1003">For example, prior to TLS version 1.2, the key generation and handshake hashing routines were fixed to use a combination of SHA-1 and MD5 – the methods for these routines are called out specifically in the cipher structure since they are not tied to specific ciphersuites.</span></span> <span data-ttu-id="5a587-1004">TLS sürüm 1,2 ' de, anahtar oluşturma ve karma yordamlar ciphersuite tarafından seçilir, ancak kullanılacak yordamları belirtmeyen ciphersuites için SHA-256 karma yöntemi kullanılır ve şifre yapısı bu yordamı özellikle çağırır.</span><span class="sxs-lookup"><span data-stu-id="5a587-1004">In TLS version 1.2, the key generation and hashing routines are chosen by the ciphersuite, but for ciphersuites which do not specify the routines to use, the SHA-256 hash method is used, and the cipher structure calls out that routine specifically.</span></span>

<span data-ttu-id="5a587-1005">TLS 1,3, çeşitli işlemler için birkaç ek özel şifre gerektirir.</span><span class="sxs-lookup"><span data-stu-id="5a587-1005">TLS 1.3 requires a few extra specific ciphers for various operations.</span></span>

19. <span data-ttu-id="5a587-1006">TLS 1,3 desteğinin ECC gerektirdiğini, TLS 1,3 etkinse nx_crypto_tls_ciphers_ecc kullanın.</span><span class="sxs-lookup"><span data-stu-id="5a587-1006">Note that TLS 1.3 support requires ECC – use nx_crypto_tls_ciphers_ecc if TLS 1.3 is enabled.</span></span>

### <a name="tls-ciphersuite-lookup-table"></a><span data-ttu-id="5a587-1007">TLS Ciphersuite arama tablosu</span><span class="sxs-lookup"><span data-stu-id="5a587-1007">TLS Ciphersuite Lookup Table</span></span>

<span data-ttu-id="5a587-1008">TLS için şifreleme tablosunu doldurmanız için, şifreleme yordamlarını belirli ciphersuite tanımlayıcılarıyla eşleyen bir ciphersuite arama tablosu da oluşturmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="5a587-1008">To fill in the cipher table for TLS, you will also need to create a ciphersuite lookup table that maps cryptographic routines to specific ciphersuite identifiers.</span></span> <span data-ttu-id="5a587-1009">Tanımlayıcılar, evrensel olan ıANA kayıtlı değerlerdir.</span><span class="sxs-lookup"><span data-stu-id="5a587-1009">The identifiers are IANA-registered values that are universal.</span></span> <span data-ttu-id="5a587-1010">Daha fazla bilgi için bkz. TLS RFC 'Leri.</span><span class="sxs-lookup"><span data-stu-id="5a587-1010">See the TLS RFCs for more information.</span></span> <span data-ttu-id="5a587-1011">Yordamlar her ciphersuite 'de kullanılan 5 ayrı yöntemi temsil eder (bazı cipherpaketleri 5 ' i kullanamaz): ortak şifre, ortak anahtar kimlik doğrulaması, oturum şifresi, oturum karması yordamı ve TLS Pseudo-Random Işlevi (PRF).</span><span class="sxs-lookup"><span data-stu-id="5a587-1011">The routines represent the 5 separate methods used in each ciphersuite (some ciphersuites may not use all 5): public cipher, public-key authentication, session cipher, session hash routine, and TLS Pseudo-Random Function (PRF).</span></span> <span data-ttu-id="5a587-1012">Aşağıdaki tabloda 5 yöntemi açıklanmaktadır:</span><span class="sxs-lookup"><span data-stu-id="5a587-1012">The following table explains each of the 5 methods:</span></span>

| <span data-ttu-id="5a587-1013">**Rutin kategori**</span><span class="sxs-lookup"><span data-stu-id="5a587-1013">**Routine category**</span></span>      | <span data-ttu-id="5a587-1014">**Açıklama**</span><span class="sxs-lookup"><span data-stu-id="5a587-1014">**Description**</span></span>                                                                                       | <span data-ttu-id="5a587-1015">**Örnek algoritmalar**</span><span class="sxs-lookup"><span data-stu-id="5a587-1015">**Example algorithms**</span></span>                                            |
| ------------------------- | ----------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------- |
| <span data-ttu-id="5a587-1016">Ortak şifre</span><span class="sxs-lookup"><span data-stu-id="5a587-1016">Public cipher</span></span>             | <span data-ttu-id="5a587-1017">TLS el sıkışması sırasında anahtar alışverişi yapmak için kullanılır</span><span class="sxs-lookup"><span data-stu-id="5a587-1017">Used to exchange keys during the TLS handshake</span></span>                                                        | <span data-ttu-id="5a587-1018">RSA, Diffie-Hellman, ECC</span><span class="sxs-lookup"><span data-stu-id="5a587-1018">RSA, Diffie-Hellman, ECC</span></span>                                          |
| <span data-ttu-id="5a587-1019">Ortak anahtar kimlik doğrulaması</span><span class="sxs-lookup"><span data-stu-id="5a587-1019">Public-key authentication</span></span> | <span data-ttu-id="5a587-1020">TLS el sıkışması sırasında verilerin kimliğini doğrulamak veya imzalamak için kullanılır</span><span class="sxs-lookup"><span data-stu-id="5a587-1020">Used to authenticate or sign data during the TLS handshake</span></span>                                            | <span data-ttu-id="5a587-1021">RSA, DSS</span><span class="sxs-lookup"><span data-stu-id="5a587-1021">RSA, DSS</span></span>                                                          |
| <span data-ttu-id="5a587-1022">Oturum şifresi</span><span class="sxs-lookup"><span data-stu-id="5a587-1022">Session cipher</span></span>            | <span data-ttu-id="5a587-1023">TLS oturumu sırasında uygulama verilerini şifrelemek için kullanılan simetrik anahtar algoritması</span><span class="sxs-lookup"><span data-stu-id="5a587-1023">Symmetric-key algorithm used to encrypt application data during the TLS session</span></span>                       | <span data-ttu-id="5a587-1024">AES, RC4</span><span class="sxs-lookup"><span data-stu-id="5a587-1024">AES, RC4</span></span>                                                          |
| <span data-ttu-id="5a587-1025">Oturum karması</span><span class="sxs-lookup"><span data-stu-id="5a587-1025">Session hash</span></span>              | <span data-ttu-id="5a587-1026">TLS oturumu sırasında iletilerin bütünlüğünü korumak için kullanılır (verilerin değişmediğinden emin olmanızı sağlar)</span><span class="sxs-lookup"><span data-stu-id="5a587-1026">Used to preserve the integrity of messages during the TLS session (assures that data has not changed)</span></span> | <span data-ttu-id="5a587-1027">SHA-1, SHA-256</span><span class="sxs-lookup"><span data-stu-id="5a587-1027">SHA-1, SHA-256</span></span>                                                    |
| <span data-ttu-id="5a587-1028">TLS PRF</span><span class="sxs-lookup"><span data-stu-id="5a587-1028">TLS PRF</span></span>                   | <span data-ttu-id="5a587-1029">TLS el sıkışma 'nda anahtar malzeme ve el sıkışma karmasında kullanılır</span><span class="sxs-lookup"><span data-stu-id="5a587-1029">Used to generate key material and in the handshake hash in the TLS handshake</span></span>                          | <span data-ttu-id="5a587-1030">PRF, karma yordamlarını temel alır – SHA-1 + MD5, SHA-256, SHA-512</span><span class="sxs-lookup"><span data-stu-id="5a587-1030">The PRF is based on hash routines – SHA-1 + MD5, SHA-256, SHA-512</span></span> |

<span data-ttu-id="5a587-1031">NX_SECURE_TLS_CIPHERSUITE_INFO yapısı aşağıdaki gibi tanımlanır:</span><span class="sxs-lookup"><span data-stu-id="5a587-1031">The NX_SECURE_TLS_CIPHERSUITE_INFO structure is defined as follows:</span></span>

```C
typedef struct NX_SECURE_TLS_CIPHERSUITE_INFO_struct
{
    /* The IANA value of the ciphersuite as defined by the TLS spec.*/
    USHORT nx_secure_tls_ciphersuite;

    /* The Public Key operation in this suite - RSA or DH. */
    NX_CRYPTO_METHOD *nx_secure_tls_public_cipher;

    /* The Public Authentication method used for signing data. */
    NX_CRYPTO_METHOD *nx_secure_tls_public_auth;

    /* The session cipher being used - AES, RC4, etc. */
    NX_CRYPTO_METHOD *nx_secure_tls_session_cipher;

    /* The size of the initialization vectors for the session cipher (bytes).*/
    USHORT nx_secure_tls_iv_size;

    /* The key size for the session cipher (bytes). */
    UCHAR nx_secure_tls_session_key_size;

    /* The hash being used - MD5, SHA-1, SHA-256, etc. */
    NX_CRYPTO_METHOD *nx_secure_tls_hash;

    /* The size of the hash being used. SHA-1 is 20 bytes, MD5 is 16 bytes.*/
    USHORT nx_secure_tls_hash_size;

    /* The TLS PRF being used – this is only for TLSv1.2. */
    NX_CRYPTO_METHOD *nx_secure_tls_prf;

} NX_SECURE_TLS_CIPHERSUITE_INFO;
```
<span data-ttu-id="5a587-1032">Nx_secure_tls_ciphersuite alanı ıANA ciphersuite değerini içerir ve NX_CRYPTO_METHOD işaretçileri, bu ciphersuite tarafından kullanılan 5 yöntemi temsil eder.</span><span class="sxs-lookup"><span data-stu-id="5a587-1032">The nx_secure_tls_ciphersuite field contains the IANA ciphersuite value, and the NX_CRYPTO_METHOD pointers represent the 5 methods used by that ciphersuite.</span></span> <span data-ttu-id="5a587-1033">Skaler değerler (nx_secure_tls_iv_size, nx_secure_tls_key_size ve nx_secure_tls_hash_size), NX_CRYPTO_METHOD girişlerinde kullanılamayan bilgiler sağlayan bilgilendirme amaçlıdır.</span><span class="sxs-lookup"><span data-stu-id="5a587-1033">The scalar values (nx_secure_tls_iv_size, nx_secure_tls_key_size, and nx_secure_tls_hash_size) are informational, providing information that might not be available in the NX_CRYPTO_METHOD entries.</span></span>

<span data-ttu-id="5a587-1034">Örneğin, TLS için varsayılan ciphersuite, 128 bitlik anahtarlarla AES-CBC ve oturum karma için SHA-1 kullanımını belirten TLS_RSA_WITH_AES_128_CBC_SHA.</span><span class="sxs-lookup"><span data-stu-id="5a587-1034">As an example, we will look at the default ciphersuite for TLS, TLS_RSA_WITH_AES_128_CBC_SHA, which specifies the use of RSA, AES-CBC with 128-bit keys, and SHA-1 for session hashing.</span></span> <span data-ttu-id="5a587-1035">Bu ciphersuite için TLS PRF belirtilmedi, bu nedenle TLSv 1.2 modunda, varsayılan SHA-256 PRF kullanır.</span><span class="sxs-lookup"><span data-stu-id="5a587-1035">No TLS PRF is specified for this ciphersuite, so in TLSv1.2 mode, it will use the default SHA-256 PRF.</span></span> <span data-ttu-id="5a587-1036">Tüm ciphersuites 'in, tabloda belirtilen PRF 'ten bağımsız olarak, TLS 1,0 ve 1,1 ' de SHA-1 + MD5 PRF 'yi kullandığına unutmayın.</span><span class="sxs-lookup"><span data-stu-id="5a587-1036">Note that all ciphersuites use the SHA-1+MD5 PRF in TLS 1.0 and 1.1, regardless of the PRF specified in the table.</span></span>

<span data-ttu-id="5a587-1037">Genel şifreleme kitaplığındaki NX_SECURE_TLS_CIPHERSUITE_INFO tablosundaki giriş aşağıdaki gibi tanımlanır:</span><span class="sxs-lookup"><span data-stu-id="5a587-1037">The entry in the NX_SECURE_TLS_CIPHERSUITE_INFO table in the generic cryptographic library is defined as follows:</span></span>

```C
{ 
  TLS_RSA_WITH_AES_128_CBC_SHA,     /* Ciphersuite identifier */
  &crypto_method_rsa,               /* Public-key cipher (NX_CRYPTO_METHOD)*/
  &crypto_method_rsa,               /* Authentication method(NX_CRYPTO_METHOD)*/
  &crypto_method_aes_cbc_128,       /* Session cipher method(NX_CRYPTO_METHOD)*/
  16,                               /* Session cipher IV size in bytes */
  16,                               /* Session cipher key size in bytes */
  &crypto_method_hmac_sha1,         /* Session hash routine(NX_CRYPTO_METHOD) */
  20,                               /* Session hash output size in bytes */
  &crypto_method_tls_prf_sha_256    /* TLSv1.2 PRF */
},
```

<span data-ttu-id="5a587-1038">Oturum şifresi anahtar boyutunun ciphersuite tarafından belirlendiği, ancak ortak anahtar yöntemleri için anahtar boyutunun, el sıkışma sırasında alışverişi yapılan dijital sertifikalarda ortak anahtarlar bulunduğundan, TLS el sıkışması tamamlanana kadar bilinmediğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="5a587-1038">Note that for the session cipher the key size is determined by the ciphersuite, but for the public-key methods the key size is not known until the TLS handshake is underway since the public keys are contained in the digital certificates exchanged during the handshake.</span></span>

### <a name="x509-cipher-lookup-table"></a><span data-ttu-id="5a587-1039">X. 509.440 şifre arama tablosu</span><span class="sxs-lookup"><span data-stu-id="5a587-1039">X.509 Cipher Lookup Table</span></span>

<span data-ttu-id="5a587-1040">NX_SECURE_TLS_CIPHERSUITE_INFO tablosu gibi, NX_SECURE_X509_CRYPTO yapısı şifreleme yordamlarını bilinen değerlerle eşler.</span><span class="sxs-lookup"><span data-stu-id="5a587-1040">Like the NX_SECURE_TLS_CIPHERSUITE_INFO table, the NX_SECURE_X509_CRYPTO structure maps cryptographic routines to known values.</span></span> <span data-ttu-id="5a587-1041">X. 509.440 durumunda tanımlayıcılar aslında X. 509.440 tarafından tanımlanan ve ISO ve ITU standartları gövdelerinde kayıtlı olan OID 'ler vardır.</span><span class="sxs-lookup"><span data-stu-id="5a587-1041">In the case of X.509, the identifiers are actually OIDs defined by X.509 and registered with the ISO and ITU standards bodies.</span></span> <span data-ttu-id="5a587-1042">OID 'ler, dijital sertifikalarda kullanılan şifreleme yordamları dahil çeşitli iletişim standartlarındaki çeşitli bilgileri benzersiz şekilde tanımlamak için tasarlanan değişken uzunlukta çok baytlı değerlerdir.</span><span class="sxs-lookup"><span data-stu-id="5a587-1042">OIDs are variable-length multi-byte values designed to uniquely identify various information in various telecommunication standards, including cryptographic routines used in digital certificates.</span></span> <span data-ttu-id="5a587-1043">OID 'lerin değişken uzunlukta olması nedeniyle, NetX güvenli TLS resmi OID değerlerini dahili olarak kullanılan sabit uzunluklu sabitlere eşler (bkz. nx_secure_x509. h).</span><span class="sxs-lookup"><span data-stu-id="5a587-1043">Due to the fact that OIDs are variable length, NetX Secure TLS maps the official OID values to fixed-length constants that are used internally (see nx_secure_x509.h).</span></span> <span data-ttu-id="5a587-1044">Bu sabitler, aşağıdaki gibi tanımlanan NX_SECURE_X509_CRYPTO yapısında kullanılır:</span><span class="sxs-lookup"><span data-stu-id="5a587-1044">These constants are used in the NX_SECURE_X509_CRYPTO structure, which is defined as follows:</span></span>

```C
/* Structure to hold X.509 cryptographic routine information. */
typedef struct NX_SECURE_X509_CRYPTO_struct
{
    /* Internal NetX Secure identifier for certificate "ciphersuite" which consists
       of a hash and a public key operation. These can be mapped to OIDs in X.509.
        */
    USHORT nx_secure_x509_crypto_identifier;

    /* Public-Key Cryptographic method used by certificates. */
    NX_CRYPTO_METHOD *nx_secure_x509_public_cipher_method;

    /* Hash method used by certificates. */
    NX_CRYPTO_METHOD *nx_secure_x509_hash_method;
} NX_SECURE_X509_CRYPTO;
```

<span data-ttu-id="5a587-1045">İlk alan *nx_secure_x509_crypto_identifier*, NETX güvenli tarafından kullanılan iç OID gösterimidir.</span><span class="sxs-lookup"><span data-stu-id="5a587-1045">The first field, *nx_secure_x509_crypto_identifier*, is the internal OID representation used by NetX Secure.</span></span>

<span data-ttu-id="5a587-1046">İkinci ve üçüncü alanlar, bir karma yordamıyla eşleştirilmiş bir ortak anahtar işlemi olan OID tarafından tanımlanan şifreleme yöntemlerini temsil eden NX_CRYPTO_METHOD nesneleri işaret eder.</span><span class="sxs-lookup"><span data-stu-id="5a587-1046">The second and third fields point to NX_CRYPTO_METHOD objects that represent the cryptographic methods identified by the OID, a public-key operation paired with a hash routine.</span></span> <span data-ttu-id="5a587-1047">Her dijital sertifikanın Şifreleme yordamları için birden fazla OID 'ye sahip olabileceğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="5a587-1047">Note that each digital certificate may have more than one OID for cryptographic routines.</span></span>

<span data-ttu-id="5a587-1048">X. 509.440 için yöntem tablosu, ciphersuite arama tablosuyla aynı şekilde oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="5a587-1048">The method table for X.509 is constructed in the same manner as the ciphersuite lookup table.</span></span> <span data-ttu-id="5a587-1049">Örnek olarak, RSA_SHA1 için OID 'ye bakacağız.</span><span class="sxs-lookup"><span data-stu-id="5a587-1049">As an example, we will look at the OID for RSA_SHA1.</span></span> <span data-ttu-id="5a587-1050">RSA_SHA1 için gerçek OID aşağıdaki gibidir:</span><span class="sxs-lookup"><span data-stu-id="5a587-1050">The actual OID for RSA_SHA1 is as follows:</span></span>

```C
{iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-1(1) sha1-with-rsa-
signature(5)}
```
<span data-ttu-id="5a587-1051">OID, ASN. 1 sözdiziminde temsil edilir ve 1.2.840.113549.1.1.5 sayısal bir değere sahiptir.</span><span class="sxs-lookup"><span data-stu-id="5a587-1051">The OID is represented in ASN.1 syntax and has a numeric value of 1.2.840.113549.1.1.5.</span></span> <span data-ttu-id="5a587-1052">Bu değer daha sonra ikili biçimde kodlanır ve aşağıdaki baytları oluşturur:</span><span class="sxs-lookup"><span data-stu-id="5a587-1052">This value is then encoded in binary format, creating the following bytes:</span></span>

```C
UCHAR RSA_SHA1_OID = { 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05 };
```
<span data-ttu-id="5a587-1053">ASN. 1 ' den ikili biçime gerçek dönüştürme, bu belgenin kapsamı dışındadır.</span><span class="sxs-lookup"><span data-stu-id="5a587-1053">The actual conversion from ASN.1 to the binary format is beyond the scope of this document.</span></span> <span data-ttu-id="5a587-1054">Daha fazla bilgi için, OID 'ler için ASN. 1 için arama yapın.</span><span class="sxs-lookup"><span data-stu-id="5a587-1054">Search for ASN.1 encodings for OIDs for more information.</span></span> <span data-ttu-id="5a587-1055">NetX güvenli tarafından desteklenen OID 'lerin ikili temsili *nx_secure_x509. c* dosyasında bulunabilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-1055">The binary representation of the OIDs supported by NetX Secure can be found in the file *nx_secure_x509.c*.</span></span>

<span data-ttu-id="5a587-1056">Gerçek OID 'yi dahili olarak tanınan bir sabit ile eşleştirdikten sonra, NX_SECURE_X509_CRYPTO tablosunda RSA_SHA1 için bir giriş oluşturuyoruz:</span><span class="sxs-lookup"><span data-stu-id="5a587-1056">Once we have a mapping of the actual OID to an internally-recognized constant, we can create an entry for RSA_SHA1 in the NX_SECURE_X509_CRYPTO table:</span></span>

```C
{ 
    NX_SECURE_TLS_X509_TYPE_RSA_SHA_1,    /* Internal OID constant. */
    &crypto_method_rsa,                   /* RSA method (NX_CRYPTO_METHOD). */ 
    &crypto_method_sha1                   /* SHA-1 method (NX_CRYPTO_METHOD). */
}, 
```
### <a name="default-tls-routines"></a><span data-ttu-id="5a587-1057">Varsayılan TLS yordamları</span><span class="sxs-lookup"><span data-stu-id="5a587-1057">Default TLS Routines</span></span>

<span data-ttu-id="5a587-1058">Yukarıda belirtildiği gibi TLS, el sıkışma sırasında anahtar oluşturma ve ileti doğrulama için bazı varsayılan yordamlar gerektirir.</span><span class="sxs-lookup"><span data-stu-id="5a587-1058">As mentioned above, TLS requires some default routines for key generation and message verification during the handshake.</span></span> <span data-ttu-id="5a587-1059">Birincil yordam, TLS Pseudo-Random Işlevi veya PRF 'dir.</span><span class="sxs-lookup"><span data-stu-id="5a587-1059">The primary routine is the TLS Pseudo-Random Function, or PRF.</span></span> <span data-ttu-id="5a587-1060">PRF, karma yordamlarını temel alır ve anahtar oluşturma veya başka amaçlar için rastgele bir sözde rastgele veri miktarı<sup>oluşturmak için kullanılabilir</sup> .</span><span class="sxs-lookup"><span data-stu-id="5a587-1060">The PRF is based on hash routines and can be used to generate an arbitrary amount of pseudo-random data<sup>20</sup> for key generation or other purposes.</span></span>

<span data-ttu-id="5a587-1061">PRF 'nin yanı sıra, her TLS sürümü de sağlanması gereken varsayılan karma yordamlar kullanır.</span><span class="sxs-lookup"><span data-stu-id="5a587-1061">In addition to the PRF, each version of TLS utilizes default hash routines that also need to be provided.</span></span> <span data-ttu-id="5a587-1062">1,0 ve 1,1 TLS sürümleri için bu karma yordamlar, MD5 ve SHA-1 ' dir.</span><span class="sxs-lookup"><span data-stu-id="5a587-1062">For TLS versions 1.0 and 1.1, those hash routines are MD5 and SHA-1.</span></span> <span data-ttu-id="5a587-1063">TLS sürüm 1,2 yalnızca SHA-256 gerektirir.</span><span class="sxs-lookup"><span data-stu-id="5a587-1063">TLS version 1.2 requires only SHA-256.</span></span>

<span data-ttu-id="5a587-1064">NX_SECURE_TLS_CRYPTO yapısında, MD5, SHA-1, SHA-256, TLS sürüm 1.0/1.1 PRF ve varsayılan TLS 1,2 PRF için NX_CRYPTO_METHOD işaretçiler vardır.</span><span class="sxs-lookup"><span data-stu-id="5a587-1064">In the NX_SECURE_TLS_CRYPTO structure, there are NX_CRYPTO_METHOD pointers for MD5, SHA-1, SHA-256, the TLS version 1.0/1.1 PRF, and the default TLS 1.2 PRF.</span></span>

<span data-ttu-id="5a587-1065">TLS 1,3 desteği, HKDF (anahtar oluşturma), HMAC (el sıkışma sırasında kullanılan belirli karma işlemler için) ve ECDHE (TLS 1,3 işlevselliği için gereklidir) için alanlar ekler.</span><span class="sxs-lookup"><span data-stu-id="5a587-1065">TLS 1.3 support adds fields for HKDF (key generation), HMAC (for specific hashing operations used during the handshake) and ECDHE (required for TLS 1.3 functionality).</span></span>

<span data-ttu-id="5a587-1066">Genel yazılım şifreleme kitaplığı 'nda belirtilen TLS PRF yazılım sürümleridir.</span><span class="sxs-lookup"><span data-stu-id="5a587-1066">Provided in the generic software cryptography library are software versions of the TLS PRF.</span></span> <span data-ttu-id="5a587-1067">TLS 1.0/1.1 için, bu işleve *nx_crypto_tls_prf_1* denir.</span><span class="sxs-lookup"><span data-stu-id="5a587-1067">For TLS 1.0/1.1, this function is called *nx_crypto_tls_prf_1*.</span></span> <span data-ttu-id="5a587-1068">TLS 1,2 için işlev *nx_secure_tls_prf_sha256* olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="5a587-1068">For TLS 1.2, the function is called *nx_secure_tls_prf_sha256*.</span></span> <span data-ttu-id="5a587-1069">"1" soneki eski TLS 1,0 PRF 'yi temsil eder ve "SHA256" soneki, TLS 1,2 varsayılan PRF 'in SHA-256 ' ı temel aldığı olguyu ifade eder.</span><span class="sxs-lookup"><span data-stu-id="5a587-1069">The suffix "1" represents the legacy TLS 1.0 PRF, and the "sha256" suffix refers to the fact that the TLS 1.2 default PRF is based on SHA-256.</span></span> <span data-ttu-id="5a587-1070">Diğer PRF yordamları için destek gerektiğinde, bu yordamların soneki kullanılan karma yöntemi yansıtır.</span><span class="sxs-lookup"><span data-stu-id="5a587-1070">When support for other PRF routines is needed, the suffix for those routines will reflect the hash method used.</span></span> <span data-ttu-id="5a587-1071">PRF yordamları karma yöntemlere dayalı olduğundan, temeldeki karma yordamlar farklı hedef platformlarda bağımsız donanım hızlandırmalı olabilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-1071">Since the PRF routines are based on hash methods, the underlying hash routines may be hardware-accelerated independently on different target platforms.</span></span>

<span data-ttu-id="5a587-1072">TLS ciphersuite ve X. 509.440 arama tablolarına ek olarak, NX_SECURE_TLS_CRYPTO yapısında doldurulan varsayılan PRF ve karma yordamlar, bir TLS oturumu başlatmak için doldurulabilir ve kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-1072">In addition to the TLS ciphersuite and X.509 lookup tables, with the default PRF and hash routines filled in the NX_SECURE_TLS_CRYPTO structure can be populated and used to initialize a TLS session.</span></span>

20. <span data-ttu-id="5a587-1073">"Sözde rastgele", PRF 'nin belirleyici olduğunu ifade eder, yani aynı girişe verilen çıktıyı her zaman üretir, ancak çıktının tahmin edilebilir olmadığı konusunda rastgele olur.</span><span class="sxs-lookup"><span data-stu-id="5a587-1073">“Pseudo-random” refers to the fact that the PRF is deterministic, meaning it will always produce the same output given the same input, but random in the fact that the output is not predictable.</span></span> <span data-ttu-id="5a587-1074">TLS, bu PRF özelliğini kullanarak, el sıkışma sırasında RSA gibi bir ortak anahtar şifresi kullanılarak yapılan ana gizli dizi ile birleştirilmiş çeşitli genel verilerden oturum anahtarları oluşturur.</span><span class="sxs-lookup"><span data-stu-id="5a587-1074">TLS uses this property of the PRF to generate the session keys from various public data combined with the master secret exchanged during the handshake using a public-key cipher like RSA.</span></span>

### <a name="cryptographic-metadata"></a><span data-ttu-id="5a587-1075">Şifreleme meta verileri</span><span class="sxs-lookup"><span data-stu-id="5a587-1075">Cryptographic Metadata</span></span>

<span data-ttu-id="5a587-1076">NX_SECURE_TLS_CRYPTO tablosu ile TLS oturumunu başlatabilmemiz için, şifreleme yordamı meta verileri için arabellek alanı ayırdık.</span><span class="sxs-lookup"><span data-stu-id="5a587-1076">Before we can initialize the TLS session with the NX_SECURE_TLS_CRYPTO table, we need to allocate buffer space for the cryptographic routine metadata.</span></span> <span data-ttu-id="5a587-1077">Meta veriler, denetim bloğu tarafından temsil edilen belirli bir yordam ile ilişkili tüm durumları depolamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="5a587-1077">The metadata is used to store all the state associated with a particular routine, represented by its control block.</span></span> <span data-ttu-id="5a587-1078">Her bir NX_CRYPTO_METHOD *nx_crypto_metadata_area_size* alanı, bu yordam ile ilişkili denetim yapısının boyutuna AYARLANMALıDıR veya TLS başlatması, gereken alana göre düzgün şekilde hesaba geçmeyecektir ve bu da arabellek taşması sorunlarına neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="5a587-1078">The *nx_crypto_metadata_area_size* field of each NX_CRYPTO_METHOD must be set to the size of the control structure associated with that routine or the TLS initialization will fail to properly account for the space needed, possibly causing buffer overrun issues.</span></span>

<span data-ttu-id="5a587-1079">TLS oturumu oluşturulmadan önce, meta veri arabelleğinin ayrılmış olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="5a587-1079">Before the TLS session is created, the metadata buffer must be allocated.</span></span> <span data-ttu-id="5a587-1080">Arabellek nx_secure_tls_session_create tarafından otomatik olarak bölünür ve şifreleme yöntemi tablosunda sunulan yordamların her biri için boşluk ayrılır.</span><span class="sxs-lookup"><span data-stu-id="5a587-1080">The buffer is automatically divided up by nx_secure_tls_session_create and space is reserved for each of the routines that are provided in the cryptographic method table.</span></span> <span data-ttu-id="5a587-1081">Bir TLS oturumunda aynı anda yalnızca bir ciphersuite etkin olduğundan, desteklenen ciphersuite sayısı gerekli meta veri alanını etkilemez – boşluk, ciphersuite arama tablosunda bu kategori için maksimum denetim blok boyutunu kullanarak 5 ciphersuite yordamlarının her biri için ayrılır.</span><span class="sxs-lookup"><span data-stu-id="5a587-1081">Note that since only one ciphersuite is active at a time in a TLS session, the number of supported ciphersuites does not affect the needed metadata space – space is reserved for each of the 5 ciphersuite routines using the maximum control block size for that category in the ciphersuite lookup table.</span></span>

<span data-ttu-id="5a587-1082">Meta veri arabellek boyutunu kolay hesaplamayı kolaylaştırmak için, hizmet *nx_secure_metadata_size_calculate* aynı hesaplamaları nx_secure_tls_session_create olarak gerçekleştirir ancak gereken toplam meta veri arabellek boyutunu bayt cinsinden döndürür.</span><span class="sxs-lookup"><span data-stu-id="5a587-1082">In order to make calculating the metadata buffer size easy, the service *nx_secure_metadata_size_calculate* performs the same calculations as nx_secure_tls_session_create but simply returns the total required metadata buffer size in bytes.</span></span>

### <a name="initializing-the-tls-session"></a><span data-ttu-id="5a587-1083">TLS oturumu başlatılıyor</span><span class="sxs-lookup"><span data-stu-id="5a587-1083">Initializing the TLS session</span></span>

<span data-ttu-id="5a587-1084">NX_CRYPTO_METHOD ve NX_SECURE_TLS_CRYPTO nesneleri oluşturulduktan ve meta veri alanı ayrıldıktan sonra, aşağıdaki gibi bir TLS oturumu başlatabiliriz (yukarıdaki örneklerden alınan değerler):</span><span class="sxs-lookup"><span data-stu-id="5a587-1084">Once the NX_CRYPTO_METHOD and NX_SECURE_TLS_CRYPTO objects are created and the metadata area reserved, we can initialize a TLS session as follows (values taken from the above examples):</span></span>

```C
/* Pointer to the platform-specific cipher table. */
extern nx_crypto_tls_ciphers;

/* Cryptographic routine metadata buffer. Size is determined by calling 
nx_secure_tls_metadata_size_calculate with the nx_crypto_tls_ciphers table referenced 
above. */
UCHAR crypto_metadata[4500];

/* Initialize our TLS session using our cipher table and metadata area. Note that we can 
use sizeof for the metadata array because the size parameter expects the size in bytes.*/

nx_secure_tls_session_create(
    &tls_session,            /* Pointer to TLS session.      */
    &nx_crypto_tls_ciphers,  /* Pointer to cipher table.     */
    crypto_metadata,         /* Cryptography metadata buffer.*/
    sizeof(crypto_metadata), /* Size of metadata buffer.     */
);
```
