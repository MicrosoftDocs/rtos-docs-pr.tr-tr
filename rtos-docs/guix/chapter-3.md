---
title: Bölüm 3 - GUIX'e İşlevsel Genel Bakış
description: Bu bölümde, yüksek performanslı GUIX kullanıcı arabirimi ürününe işlevsel bir genel bakış yer almaktadır.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 2a53da048b18d35b6b15a4ad8d4138e1a2acd4e8
ms.sourcegitcommit: 95f4ae0842a486fec8f10d1480203695faa9592d
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 06/09/2021
ms.locfileid: "111875264"
---
# <a name="chapter-3---functional-overview-of-guix"></a><span data-ttu-id="a74b9-103">Bölüm 3 - GUIX'e İşlevsel Genel Bakış</span><span class="sxs-lookup"><span data-stu-id="a74b9-103">Chapter 3 - Functional Overview of GUIX</span></span>

<span data-ttu-id="a74b9-104">Bu bölümde, yüksek performanslı GUIX kullanıcı arabirimi ürününe işlevsel bir genel bakış yer almaktadır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-104">This chapter contains a functional overview of the high-performance GUIX user interface product.</span></span> 

## <a name="execution-overview"></a><span data-ttu-id="a74b9-105">Yürütmeye Genel Bakış</span><span class="sxs-lookup"><span data-stu-id="a74b9-105">Execution Overview</span></span>

<span data-ttu-id="a74b9-106">GUIX, olay odaklı bir programlama modeli uygulama.</span><span class="sxs-lookup"><span data-stu-id="a74b9-106">GUIX implements an event driven programming model.</span></span> <span data-ttu-id="a74b9-107">Bu, GUIX çerçevesinin öncelikli olarak GUIX olay kuyruğuna iletilen olayların alınmasıyla yönlendirildiğini belirtir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-107">This means that the GUIX framework is primarily driven by the receipt of events pushed into the GUIX event queue.</span></span> <span data-ttu-id="a74b9-108">Bu olayların işlemesi GUIX sistem başlatma sırasında oluşturulan bir ThreadX iş parçacığı olan GUIX iş parçacığı bağlamında sürer.</span><span class="sxs-lookup"><span data-stu-id="a74b9-108">The processing of these events takes place in the context of the GUIX thread, which is a ThreadX thread created during GUIX system initialization.</span></span>

<span data-ttu-id="a74b9-109">GUIX uygulamaları, pencere ve alt pencere öğeleri oluşturmak için GUIX API işlevlerini çağırarak kullanıcı arabirimini tanımlar ve renkleri, stilleri, yazı tiplerini ve her pencere öğesi türünün diğer çeşitli özniteliklerini tanımlamak için kullanılan ek API işlevlerini çağırarak bu pencere öğelerinin görünümünü özeller.</span><span class="sxs-lookup"><span data-stu-id="a74b9-109">GUIX applications define the user interface by calling GUIX API functions to create windows and child widgets, and customize the appearance of these widgets by calling additional API functions used to define colors, styles, fonts, and various other attributes of each window or widget type.</span></span> <span data-ttu-id="a74b9-110">Kullanıcı arabirimi ekranlarının görünümünü oluşturmak için GUIX Studio kullanıyorsanız, görüntülerinizi oluşturmak için GUIX API işlevlerini çağırmanın büyük bir işi GUIX Studio uygulaması tarafından sizin için yapılır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-110">If you are using GUIX Studio to create the appearance of your user-interface screens, much of this work of calling GUIX API functions to create your display is done for you by the GUIX Studio application.</span></span>

<span data-ttu-id="a74b9-111">GUIX uygulamaları, GUIX olay kuyruğundan alınan olayları işleerek sistem kullanıcısı ve dış iş mantığıyla etkileşime geçme.</span><span class="sxs-lookup"><span data-stu-id="a74b9-111">GUIX applications interact with the system user and with external business logic by handling events retrieved from the GUIX event queue.</span></span>
<span data-ttu-id="a74b9-112">Bu olaylar genellikle GUIX pencere öğeleri tarafından oluşturulur, ancak dış iş parçacıkları tarafından da oluşturulabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-112">These events are usually produced by GUIX widgets, but they can also be created by external threads.</span></span> <span data-ttu-id="a74b9-113">Tipik bir GUIX düğmesi gönderıldığında, bu düğme düğmenin üst penceresine bir olay gönderir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-113">When a typical GUIX button is pushed, that button sends an event to the button’s parent window.</span></span> <span data-ttu-id="a74b9-114">Uygulama programınız, düğme anında itme olayı için bir işleyici sağlayarak bu düğme anında basıldığında eyleme geçmektedir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-114">Your application program will act on that button push by providing a handler for the button push event.</span></span>

<span data-ttu-id="a74b9-115">Genellikle giriş sürücüleri gibi şeyler için ek GUIX iş parçacıkları oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-115">Additional GUIX threads are often created for things such as input drivers.</span></span> <span data-ttu-id="a74b9-116">Tipik bir dokunmatik ekran giriş sürücüsü, ana GUIX iş parçacığının dışında tek başına iş parçacığı olarak yürütülür.</span><span class="sxs-lookup"><span data-stu-id="a74b9-116">A typical touch screen input driver is executed as a standalone thread external to the main GUIX thread.</span></span> <span data-ttu-id="a74b9-117">Dokunma girişi sürücüsü, GUIX olay kuyruğuna olayları göndererek dokunma bilgilerini GUIX iş parçacığına gönderir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-117">The touch input driver sends touch information into the GUIX thread by sending events into the GUIX event queue.</span></span>

<span data-ttu-id="a74b9-118">Animasyonlar gibi birçok kullanıcı arabirimi işlem doğru zamanlama bilgileri gerektirmesi sayesinde GUIX basit ve kullanımı kolay bir zamanlayıcı arabirimi de sunar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-118">Since many user-interface operations such as animations require accurate timing information, GUIX also implements a simple and easy to use timer interface.</span></span> <span data-ttu-id="a74b9-119">Bu zamanlayıcı arabirimi ThreadX zamanlayıcı hizmeti üzerine oluşturulur ve sistem başlangıcında otomatik olarak yapılandırılır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-119">This timer interface is built upon the ThreadX timer service, and is configured automatically at system startup.</span></span>

<span data-ttu-id="a74b9-120">GUIX yazılımının büyük çoğunluğu herhangi bir donanım bağımlılığına karşı bağımsızdır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-120">The vast majority of the GUIX software is independent of any hardware dependencies.</span></span> <span data-ttu-id="a74b9-121">Çerçeve, donanıma özgü giriş sürücüleri ve donanıma özgü grafik sürücüleri gerektirir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-121">The framework does require hardware-specific input drivers and hardware-specific graphics drivers.</span></span> <span data-ttu-id="a74b9-122">Bu donanıma özgü sürücülerin nasıl uygulandığının ayrıntıları 5. bölüme ertelenmiştir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-122">The details of how these hardware specific drivers are implemented are deferred to chapter 5.</span></span>

## <a name="initialization"></a><span data-ttu-id="a74b9-123">Başlatma</span><span class="sxs-lookup"><span data-stu-id="a74b9-123">Initialization</span></span> 

<span data-ttu-id="a74b9-124">Başka ***gx_system_initialize*** GUIX hizmeti çağrılmadan önce hizmetin çağrılmaları gerekir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-124">The service ***gx_system_initialize*** must be called before any other GUIX service is called.</span></span> <span data-ttu-id="a74b9-125">GUIX sistem başlatması, ***ThreadX*** tx_application_define yordamından (başlatma bağlamı) veya uygulama iş parçacıklarından çağrılebilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-125">GUIX system initialization can be called from the ThreadX ***tx_application_define*** routine (initialization context) or from application threads.</span></span> <span data-ttu-id="a74b9-126">***gx_system_initialize*** GUIX olay kuyruğu oluşturur, GUIX zamanlayıcı tesisini başlatıyor, ana GUIX sistem iş parçacığını oluşturuyor ve uygulamanın yürütülmesi sırasında GUIX tarafından sürdürülen çeşitli veri yapılarını başlatıyor.</span><span class="sxs-lookup"><span data-stu-id="a74b9-126">The ***gx_system_initialize*** function creates the GUIX event queue, initializes the GUIX timer facility, creates the main GUIX system thread, and initializes various data structures maintained by GUIX during the execution of your application.</span></span>

<span data-ttu-id="a74b9-127">Uygulama ***gx_system_initialize*** döndürdikten sonra ekranlar, tuvaller, pencereler, pencere öğeleri oluşturma ve tüm GUIX nesnelerinin özelliklerini özelleştirmeye hazırdır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-127">After ***gx_system_initialize*** returns, the application is ready to create displays, canvases, windows, widgets, and customize the properties of all GUIX objects.</span></span> <span data-ttu-id="a74b9-128">GUIX nesne oluşturma API'lerinin büyük bir tx_application_define ***iş*** parçacıklarından çağrılabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a74b9-128">Much of the GUIX object creation API can be called from ***tx_application_define*** or from application threads.</span></span>

## <a name="application-interface-calls"></a><span data-ttu-id="a74b9-129">Uygulama Arabirimi Çağrıları</span><span class="sxs-lookup"><span data-stu-id="a74b9-129">Application Interface Calls</span></span> 

<span data-ttu-id="a74b9-130">Uygulama çağrıları büyük ölçüde tx_application_define ***(başlatma bağlamı)*** veya uygulama iş parçacıklarından yapılır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-130">Calls from the application are largely made from ***tx_application_define*** (initialization context) or from application threads.</span></span> <span data-ttu-id="a74b9-131">Hangi bağlamdan çağrıll tanımlan olduğunu belirlemek için lütfen Bölüm 4'te açıklanan guiX API'lerinin "İzin Verilenler" bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="a74b9-131">Please see the “Allowed From” section of each GUIX API described in Chapter 4 to determine what context it may be called from.</span></span>

<span data-ttu-id="a74b9-132">En çok yoğun işleme etkinlikleri, tüm olay işleme ve pencere öğesi/pencere çizimi dahil olmak üzere iç GUIX iş parçacığına ertelenmiştir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-132">For the most part, processing intensive activities are deferred to the internal GUIX thread, including all event processing and widget/window drawing.</span></span>

<span data-ttu-id="a74b9-133">GUIX API işlevleri herhangi bir iş parçacığından herhangi bir zamanda çağrılabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a74b9-133">The GUIX API functions can be called from any thread at any time.</span></span>
<span data-ttu-id="a74b9-134">Ancak, zaman açısından kritik iş mantığınızı kullanıcı arabirimi mantığından ayırmak için genellikle daha iyi bir mimari olarak kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-134">However it is usually considered to be better architecture to separate your time-critical business logic from your user interface logic.</span></span> <span data-ttu-id="a74b9-135">Kullanıcı arabirimi çizim işlemleri görüntü boyutunuz ve CPU performansınıza bağlı olarak bazen uzun sürebilir, normalde bir çizim işleminin tamamlandıktan sonra gecikmeli zaman açısından kritik iş parçacıklarının gecikmesini istemeyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a74b9-135">Since the user interface drawing operations can sometimes take a long time depending on your display size and CPU performance, you normally would not want to have time-critical threads delayed waiting for a drawing operation to complete.</span></span>

## <a name="internal-guix-thread"></a><span data-ttu-id="a74b9-136">İç GUIX İş Parçacığı</span><span class="sxs-lookup"><span data-stu-id="a74b9-136">Internal GUIX Thread</span></span> 

<span data-ttu-id="a74b9-137">Belirtildiği gibi GUIX, GUI işlemenin toplu işlemini gerçekleştiren bir iç iş parçacığına sahip.</span><span class="sxs-lookup"><span data-stu-id="a74b9-137">As mentioned, GUIX has an internal thread that performs the bulk of the GUI processing.</span></span> <span data-ttu-id="a74b9-138">Bu iş parçacığı , \* gx_system_initialize **_** ve ardından _\* gx_system_start \*\*_çağrılarak_ oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-138">This thread is created by the application software by calling ***gx_system_initialize** _ followed by _*_gx_system_start_\*\*.</span></span>

<span data-ttu-id="a74b9-139">İç GUIX iş parçacığının önceliği tarafından `#define GX_SYSTEM_THREAD_PRIORITY` belirlenir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-139">The priority of the internal GUIX thread is determined by the `#define GX_SYSTEM_THREAD_PRIORITY`.</span></span> <span data-ttu-id="a74b9-140">Bu değer varsayılan olarak 16 (orta öncelikli) olur, ancak bu değer gx_port.h veya gx_user.h üst bilgi dosyasında belirterek varsayılan değeri geçersiz karak değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-140">This value defaults to 16 (middle priority) but can be modified by specifying this value in the gx_port.h or gx_user.h header file, overriding the default value.</span></span>

<span data-ttu-id="a74b9-141">GUIX iş parçacığı zaman dilimi, varsayılan değeri `#define GX_SYSTEM_THREAD_TIMESLICE` 10 ms olan ile benzer şekilde tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-141">The GUIX thread time slice is similarly defined by the `#define GX_SYSTEM_THREAD_TIMESLICE`, which defaults to the value 10 ms.</span></span>

<span data-ttu-id="a74b9-142">Sistem iş parçacığının yığın sie `#define GX_THREAD_STACK_SIZE` ***değeri, gx_port.h*** üst bilgi dosyasında bulunan , ancak aynı zamanda bu değeri gx_user.h üst bilgi dosyanıza belirterek geçersiz kılınabilir tarafından belirlenir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-142">The stack sie of the system thread is determined by the `#define GX_THREAD_STACK_SIZE`, which is found in the ***gx_port.h*** header file, but can also be overridden by specifying this value in your gx_user.h header file.</span></span>

<span data-ttu-id="a74b9-143">İç GUIX iş parçacığı yürütme döngüsü üç eylemden oluşur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-143">The internal GUIX thread execution loop is composed of three actions.</span></span>
<span data-ttu-id="a74b9-144">İlk olarak GUIX, GUIX olay kuyruğundan olayları alın ve GUIX pencere öğeleri ve pencere öğeleri tarafından iş için bu olayları döndürür.</span><span class="sxs-lookup"><span data-stu-id="a74b9-144">First, GUIX retrieves events from the GUIX event queue and dispatches those events for processing by the GUIX windows and widgets.</span></span> <span data-ttu-id="a74b9-145">Olaylar genellikle düzenli aralıklarla süreerler, dokunmatik ekran veya tuş takımı gibi giriş cihazları ve kullanıcı girişini işleyene GUIX pencere öğeleri tarafından GUIX olay kuyruğuna eklenir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-145">Events are typically pushed into the GUIX event queue by periodic timers, input devices such as a touch screen or keypad, and by GUIX widgets themselves as they process user input.</span></span> <span data-ttu-id="a74b9-146">Ardından, tüm olaylar işlendikten sonra GUIX, ekran yenilemenin gerekli olup olmadığını belirler ve gerekirse görüntü grafik verilerini güncelleştirmek için gereken işlemeyi gerçekleştirir ve bu işlem genellikle kirli olarak işaretlenmiş pencerelerin ve pencere öğelerinin çizim işlevlerini çağırarak gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-146">Next, after all events have been processed, GUIX determines if a screen refresh is needed, and if so performs the processing necessary to update the display graphics data, mainly by calling the drawing functions of those windows and widgets which have been marked as dirty.</span></span> <span data-ttu-id="a74b9-147">Son olarak, GUIX yeni bir giriş olayı veya olayları gelene kadar GUIX iş parçacığını askıya alır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-147">Finally, GUIX suspends the GUIX thread until a new input event or events arrive.</span></span>

## <a name="event-processing"></a><span data-ttu-id="a74b9-148">Olay İşleme</span><span class="sxs-lookup"><span data-stu-id="a74b9-148">Event Processing</span></span> 

<span data-ttu-id="a74b9-149">Dokunma veya kalem girişi olayları, dokunma veya kalem girişi piksel konumunun altında en üstteki pencere veya pencere öğesi belirlenerek ve bu pencere/pencere öğesi olay işleme işlevi çağrılarak işlenir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-149">Touch or pen input events are processed by determining the top-most window or widget beneath the touch or pen input pixel position and calling that window/widget’s event processing function.</span></span> <span data-ttu-id="a74b9-150">Pencere öğesi kalem girişi olaylarını anlarsa, olayı bu pencere öğesi türü için uygun şekilde işler.</span><span class="sxs-lookup"><span data-stu-id="a74b9-150">If the widget understands pen input events, it will process the event as appropriate for that widget type.</span></span> <span data-ttu-id="a74b9-151">Yoksa, en üst pencere öğesi işleme için pencere öğesi üst öğeye dokunma veya kalem girişi olayı iletir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-151">If not, the top-most widget will pass the touch or pen input event to the widget's parent for processing.</span></span> <span data-ttu-id="a74b9-152">Olayın zincire bu şekilde geçirmesi, olay işlenmeden veya olay kök pencereye gelene kadar devam eder ve bu durumda olay atılır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-152">This passing of the event up the chain continues until either the event is handled or the event arrives at the root window, in which case the event is discarded.</span></span>

<span data-ttu-id="a74b9-153">Tuş takımı olayları, giriş odağı olan pencereye/pencere öğesine gönderilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-153">Keypad events are sent to the window/widget that has input focus.</span></span> <span data-ttu-id="a74b9-154">Giriş odak durumu GUIX bileşeni tarafından gx_system korunur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-154">Input focus status is maintained by the GUIX gx_system component.</span></span>

<span data-ttu-id="a74b9-155">Zamanlayıcı olayları her zaman iş için zamanlayıcının sahibi olan pencereye veya pencere öğesine sevk edilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-155">Timer events are always dispatched to the window or widget that owns the timer for processing.</span></span>

<span data-ttu-id="a74b9-156">Düğme tıklama olayları veya kaydırıcı değeri değişiklik olayları gibi dahili olarak oluşturulan olaylar her zaman olayı oluşturan pencere öğesinin üst öğesine gönderilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-156">Internally generated events, such as button click events or slider value change events, are always sent to the parent of the widget generating the event.</span></span> <span data-ttu-id="a74b9-157">Üst öğe olayı işlemezse, dokunma veya kalem giriş olaylarını gibi zincire geçirtir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-157">If the parent does not process the event, it is passed up the chain similar to touch or pen input events.</span></span>

## <a name="drawing"></a><span data-ttu-id="a74b9-158">Çizim</span><span class="sxs-lookup"><span data-stu-id="a74b9-158">Drawing</span></span> 

<span data-ttu-id="a74b9-159">Tüm olay işleme tamamlandıktan sonra GUIX iç iş parçacığı herhangi bir görüntü güncelleştirmesi gerektirildiğini ve gerekli olup olmadığını belirler. Uygun pencere/pencere öğesi çizim işlevleri çağrılır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-159">Once all the event processing is complete, the GUIX internal thread determines if any display update is needed and if so the appropriate window/widget drawing functions are called.</span></span> <span data-ttu-id="a74b9-160">Çizim tamamlandığında GUIX iç iş parçacığı bir sonraki GUIX olayı için olay kuyruğunda bekler.</span><span class="sxs-lookup"><span data-stu-id="a74b9-160">When drawing is complete, the GUIX internal thread simply waits on its event queue for the next GUIX event to process.</span></span>

<span data-ttu-id="a74b9-161">GUIX, her pencere *öğesi ve* tuval için yeniden çizilecek alanlar olan kirli alanlar kavramını uygulamaya almaktadır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-161">GUIX implements the concept of *dirty areas*, which are areas that need to be re-drawn, for each widget and canvas.</span></span> <span data-ttu-id="a74b9-162">Pencere öğesi yalnızca daha önce kirli olarak işaretlenmiş alanlara çizebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a74b9-162">A widget can only draw to areas that have previously been marked as dirty.</span></span> <span data-ttu-id="a74b9-163">Bir pencere öğesi çizim işlevi çağrıldı mı, tüm çizim işlemleri önceden tanımlanmış kirli dikdörtgene dahili olarak kırpılır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-163">When a widget drawing function is called, all drawing operations are internally clipped to the previously defined dirty rectangle.</span></span>
<span data-ttu-id="a74b9-164">Bu alanı dışına çizme girişimleri yoksayılır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-164">Attempts to draw outside of this area are ignored.</span></span>

<span data-ttu-id="a74b9-165">Pencere öğeleri ve pencereler api işlevini çağırarak kendilerini kirli ***gx_system_dirty_mark.***</span><span class="sxs-lookup"><span data-stu-id="a74b9-165">Widgets and windows mark themselves as dirty by calling the API function ***gx_system_dirty_mark***.</span></span> <span data-ttu-id="a74b9-166">Bu işlev, pencere öğesi veya pencerenin tamamını yeniden çizildi olarak işaretler.</span><span class="sxs-lookup"><span data-stu-id="a74b9-166">This function marks the entire widget or window as needing to be redrawn.</span></span> <span data-ttu-id="a74b9-167">bir pencere veya ***pencere gx_system_dirty_partial_add*** bir kısmını kirli olarak işaretlemek için alternatif olarak ikinci bir işlev olarak çağrılabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-167">A second function, ***gx_system_dirty_partial_add***, can be invoked as an alternative to mark only a portion of a window or widget as dirty.</span></span>

<span data-ttu-id="a74b9-168">Pencere öğelerini kirli olarak işaretleme ve ardından bu pencere öğelerini yalnızca tüm giriş olayları işlendiğinde yeniden çizme modeli ertelenmiş çizim *olarak adlandırılır.*</span><span class="sxs-lookup"><span data-stu-id="a74b9-168">This model of marking widgets as dirty and then redrawing those widgets only when all input events have been processed is referred to as *deferred drawing*.</span></span> <span data-ttu-id="a74b9-169">GUIX ertelenmiş çizim algoritması ve kirli liste bakımı, çizim verimliliğini artırmak için tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-169">The GUIX deferred drawing algorithm and dirty list maintenance is designed to improve drawing efficiency.</span></span> <span data-ttu-id="a74b9-170">Çizim işlemleri genellikle pahalı olduğu için GUIX gereksiz çizimleri önlemek için çok çalışır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-170">Since drawing operations are typically expensive, GUIX works hard to prevent unnecessary drawing.</span></span>

<span data-ttu-id="a74b9-171">Çizim bir GUIX tuvale *yapılır.*</span><span class="sxs-lookup"><span data-stu-id="a74b9-171">Drawing is done to a GUIX *canvas*.</span></span> <span data-ttu-id="a74b9-172">Tuval, grafik verilerini tutmak için ayrılmış bir bellek alanıdır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-172">A canvas is a memory area reserved to hold graphics data.</span></span> <span data-ttu-id="a74b9-173">Tuval, sistem mimarisine ve bellek kısıtlamalarına bağlı olarak donanım çerçevesi arabelleğine doğrudan bağlı olabilir veya bağlantılı değildir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-173">A canvas may or may not be directly linked to the hardware frame buffer, depending on the system architecture and memory constraints.</span></span> <span data-ttu-id="a74b9-174">Herhangi bir çizimin gerçekleşmesi için önce gx_canvas_drawing_initiate API işlevi çağrılarak ***bir tuvalin çizim için açılması*** gerekir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-174">Before any drawing can occur, a canvas must first be opened for drawing by calling the ***gx_canvas_drawing_initiate*** API function.</span></span> <span data-ttu-id="a74b9-175">Bu API, tuvali çizim için hazırlar ve geçerli çizim *bağlamını oluşturur.*</span><span class="sxs-lookup"><span data-stu-id="a74b9-175">This API prepares a canvas for drawing and established the current *drawing context*.</span></span> <span data-ttu-id="a74b9-176">GUIX bir sistem tuval yenilemesi gerçekleştirerek çizim için tuval açılır ve pencere öğesi düzeyinde çizim API'leri çağrılmadan önce çizim bağlamı kurulur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-176">When GUIX performs a system canvas refresh, the canvas is opened for drawing and the drawing context established before the widget-level drawing APIs are invoked.</span></span> <span data-ttu-id="a74b9-177">Bu nedenle pencere öğelerinin pencere öğesi çizim işlevi içindeki tuvalde çizim başlatması gerekli değildir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-177">Therefore widgets do not need to initiate drawing on a canvas within the widget drawing function.</span></span>

<span data-ttu-id="a74b9-178">Ancak, bir uygulama standart GUIX ertelenmiş çizim algoritmasının akışının dışında bir tuvale hemen  çizim yapmak isterse, uygulama diğer çizim API'si işlevlerini çağırmadan önce gx_canvas_drawing_initiate'yi doğrudan çağırmalı ve hemen çizim tamamlandıktan sonra ***gx_canvas_drawing_complete'yi*** çağırmalıdır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-178">However, if an application desires to perform immediate drawing to a canvas, outside the flow of the standard GUIX deferred drawing algorithm, the application must directly invoke the ***gx_canvas_drawing_initiate*** prior to calling any other drawing API functions, and must call ***gx_canvas_drawing_complete*** once the immediate drawing has been completed.</span></span>

## <a name="user-input"></a><span data-ttu-id="a74b9-179">Kullanıcı Girişi</span><span class="sxs-lookup"><span data-stu-id="a74b9-179">User Input</span></span> 

<span data-ttu-id="a74b9-180">GUIX, önceden tanımlanmış olay türlerine sahip dokunmatik ekran, fare ve klavye cihazlarını destekler.</span><span class="sxs-lookup"><span data-stu-id="a74b9-180">GUIX supports touch screen, mouse, and keyboard devices with predefined event types.</span></span> <span data-ttu-id="a74b9-181">Özel olay türleri tanımlayarak veya özel giriş cihazı önceden tanımlanmış olay türlerine eşlerken ek giriş cihazları kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-181">Additional input devices can be utilized by defining custom event types, or by mapping the custom input device to the predefined event types.</span></span>

<span data-ttu-id="a74b9-182">Bu cihazlarla ilişkili eylemler, iç GUIX iş parçacığı tarafından işlenen olaylara çevrilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-182">Actions associated with these devices are translated into events that are processed by the internal GUIX thread.</span></span> <span data-ttu-id="a74b9-183">Dokunmatik ekranı desteklemek için yazılan sürücü düzeyindeki yazılımlar, kaleme al, yukarı ve kalemle sürükleme işlemleri için GUIX olay kuyruğu olaylarını hazırlamalı ve göndermeli.</span><span class="sxs-lookup"><span data-stu-id="a74b9-183">Driver level software written to support a touch screen must prepare and send to the GUIX event queue events for pen-down, pen-up, and pen-drag operations.</span></span> <span data-ttu-id="a74b9-184">Benzer şekilde, bir tuş takımı giriş sürücüsünün tuşa basma ve anahtar bırakma girişi için olaylar oluşturması gerekir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-184">Similarly a keypad input driver must generate events for key press and key release input.</span></span>

## <a name="modal-dialog-execution"></a><span data-ttu-id="a74b9-185">Kalıcı İletişim Kutusu Yürütme</span><span class="sxs-lookup"><span data-stu-id="a74b9-185">Modal Dialog Execution</span></span> 

<span data-ttu-id="a74b9-186">Kalıcı iletişim kutusu yürütme, kullanıcıya diğer GUIX pencerelerinin veya pencere öğelerinin kullanıcı girişini aldan önce bir şekilde kapatılacak bir pencere sunarak ifade eder.</span><span class="sxs-lookup"><span data-stu-id="a74b9-186">Modal dialog execution refers to presenting a window to the user that must be closed in some way before any other GUIX windows or widgets can receive user input.</span></span> <span data-ttu-id="a74b9-187">Kalıcı iletişim kutuları, dokunma veya fare girişi olaylarının x,y konumundan bağımsız olarak iletişim kutusu görüntülenirken tüm kullanıcı girişini yakalar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-187">Modal dialogs capture all user input while the dialog window is displayed, regardless of the x,y position of touch or mouse input events.</span></span>

<span data-ttu-id="a74b9-188">Kalıcı iletişim kutuları, uygulama yazılımı tarafından önce gx_window_create çağrılarak normal şekilde pencere oluşturulur ve ardından gx_window_create API işlevi ***çağrılarak gx_window_execute.***</span><span class="sxs-lookup"><span data-stu-id="a74b9-188">Modal dialogs are triggered by the application software by first creating the window in the normal way by calling ***gx_window_create***, and then calling the GUIX API function ***gx_window_execute.***</span></span>

<span data-ttu-id="a74b9-189">İşlev ***gx_window_execute*** çağrıldı mı GUIX bir yerel olay işleme döngüsü girer.</span><span class="sxs-lookup"><span data-stu-id="a74b9-189">When the ***gx_window_execute*** function is called, GUIX enters a local event processing loop.</span></span> <span data-ttu-id="a74b9-190">gx_window_execute  işlevi, iletişim kutusu kullanıcı girişi tarafından veya çağrısı tarafından kapatılana kadar çağırana ***gx_window_close.***</span><span class="sxs-lookup"><span data-stu-id="a74b9-190">The ***gx_window_execute*** function does not return to the caller until the dialog window is closed, either by user input or by calling ***gx_window_close***.</span></span> <span data-ttu-id="a74b9-191">Bu nedenle, GUIX iç iş parçacığı dışında ***herhangi bir gx_window_execute*** işlevden hiçbir zaman çağrılmama önemlidir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-191">For this reason, it is very important never to call the ***gx_window_execute*** function from any thread other than the GUIX internal thread.</span></span>

## <a name="periodic-processing"></a><span data-ttu-id="a74b9-192">Düzenli İşlem</span><span class="sxs-lookup"><span data-stu-id="a74b9-192">Periodic Processing</span></span> 

<span data-ttu-id="a74b9-193">GUIX, görüntüleme etkileri, sprite animasyonu ve uygulama düzenli istekleri için destek sağlamak amacıyla bir ThreadX zamanlayıcısı kullanır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-193">In order to provide display effects, sprite animation, and support for application periodic requests, GUIX uses one ThreadX timer.</span></span> <span data-ttu-id="a74b9-194">Bu tek süreölçer, GUIX zamanıyla ilgili tüm ihtiyaçların yapılması için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-194">This single timer is used to drive all GUIX time-related needs.</span></span> <span data-ttu-id="a74b9-195">Varsayılan olarak, GUIX iç süreölçeri işleme sıklığı, sabit daha önce gx_port.h veya **gx_user.h** üst bilgisinde tanımlanmamışsa, **_gx_api.h_** içinde tanımlanan sabit GX_SYSTEM_TIMER_MS aracılığıyla 20 saniye olarak ayarlanır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-195">By default, the frequency for the GUIX internal timer processing is set to 20ms via the constant **GX_SYSTEM_TIMER_MS**, which is defined in **_gx_api.h_**, unless the constant is previously defined in gx_port.h or gx_user.h header.</span></span> <span data-ttu-id="a74b9-196">GuiX kitaplığını derleme sırasında veya gx_user.h içinde açıkça yeniden tanım kullanarak varsayılan sıklık uygulama tarafından bir derleme ***seçeneğiyle değiştirilebilir.***</span><span class="sxs-lookup"><span data-stu-id="a74b9-196">The default frequency may be changed by the application via a compilation option when building the GUIX library or by explicitly redefining it in ***gx_user.h***.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="a74b9-197">GUIX zamanlayıcı sıklığının RTOS süreölçer tıklarında ifade edildiklerini ve değerine göre **GX_SYSTEM_TIMER_TICKS.**</span><span class="sxs-lookup"><span data-stu-id="a74b9-197">Note that the GUIX timer frequency is expressed in RTOS timer ticks, and is defined by the constant **GX_SYSTEM_TIMER_TICKS**.</span></span> <span data-ttu-id="a74b9-198">değerinin **değeri GX_SYSTEM_TIMER_TICKS** ve GX_SYSTEM_TIMER_MS **kullanılarak** **TX_TIMER_TICKS_PER_SECOND.**</span><span class="sxs-lookup"><span data-stu-id="a74b9-198">The value of **GX_SYSTEM_TIMER_TICKS** is calculated using **GX_SYSTEM_TIMER_MS** and **TX_TIMER_TICKS_PER_SECOND**.</span></span> <span data-ttu-id="a74b9-199">Kullanıcı GUIX zamanlayıcı sıklığını ve çözünürlüğünü ayarlamak için ***gx_port.h** _ veya _ *_gx_user.h_** içinde bu değerlerden herhangi birini yeniden tanımlayabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-199">The user can re-define any of these values in the ***gx_port.h** _ or _ *_gx_user.h_** to adjust the GUIX timer frequency and resolution.</span></span>

## <a name="display-driver"></a><span data-ttu-id="a74b9-200">Sürücü Görüntüle</span><span class="sxs-lookup"><span data-stu-id="a74b9-200">Display Driver</span></span> 

<span data-ttu-id="a74b9-201">Ekran sürücüleri, çekirdek Gux koduna bir çizim işlevleri kümesi sağlamaktan sorumludur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-201">Display drivers are responsible for providing a set of drawing functions to the core GUIX code.</span></span> <span data-ttu-id="a74b9-202">Bu çizim işlevlerinin her birinin uygulanması sürücü tarafından belirlenir ve uygulamanın donanım hızlandırma desteğinden faydalanması mümkün olduğunda.</span><span class="sxs-lookup"><span data-stu-id="a74b9-202">The implementation of each of these drawing functions is determined by the driver, and when possible the implementation will leverage hardware acceleration support.</span></span> <span data-ttu-id="a74b9-203">Genel olarak çizim işlevi, fiziksel çerçeve arabelleği olabilecek bir bellek arabelleğine piksel verileri yazarak çalışır veya sürücü mimarisine bağlı olarak ikincil bir arabellek olabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-203">In general the drawing function works by writing pixel data to a memory buffer, which may be the physical frame buffer or it may be a secondary buffer depending on the driver architecture.</span></span> <span data-ttu-id="a74b9-204">Birçok sürücü iki çerçeve arabelleği kullanarak çift arabelleğe alma uygular ve bu arabellekler arabellek geçiş işlevi çağrılarak çalışır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-204">Many drivers implement double buffering using two frame buffers, and these buffers are toggled by invoking the buffer toggle function.</span></span> <span data-ttu-id="a74b9-205">GUX bu işlevleri uygun zamanlarda dahili olarak çağırır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-205">GUIX calls these functions internally at the appropriate times.</span></span> <span data-ttu-id="a74b9-206">Bellek kısıtlı sistemler için çizim işlevleri yalnızca tek bir bellek çerçeve arabelleğine yazabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-206">For memory constrained systems, the drawing functions may only write to a single memory frame buffer.</span></span>

<span data-ttu-id="a74b9-207">GUX her bir alt düzey çizim işlevinin varsayılan yazılım uygulamalarını her bir destek renk derinliğine ve biçimine sağlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-207">GUIX provides default software implementations of each low-level drawing function at every support color depth and format.</span></span> <span data-ttu-id="a74b9-208">Bu işlevler, **GX_DISPLAY** yapısı içinde tutulan işlev işaretçileri aracılığıyla çağrılır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-208">These functions are invoked via function pointers maintained within the **GX_DISPLAY** structure.</span></span> <span data-ttu-id="a74b9-209">Donanıma özgü sürücüler oluşturulduğunda, genellikle bu işlev işaretçilerinden bazılarının hedef donanıma özgü işlevlerle birlikte üzerine yazılır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-209">When hardware-specific drivers are created, they typically will overwrite some number of these function pointers with functions that are specific to the target hardware.</span></span>

<span data-ttu-id="a74b9-210">Tipik bir donanım görüntüleme sürücüsü, önce gerekli renk derinliği ve biçimi için varsayılan GUıDX görüntüleme sürücüsü oluşturularak uygulanır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-210">A typical hardware display driver is implemented by first creating the default GUIX display driver for the required color depth and format.</span></span>
<span data-ttu-id="a74b9-211">Daha sonra Donanım Sürücüsü, belirli donanım uygulamaları için optimize edilmiş veya özelleştirilmek zorunda olan işlevlerin yerini alır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-211">Then the hardware driver will replace those functions that need to be optimized or customized for the particular hardware implementation.</span></span>

<span data-ttu-id="a74b9-212">GUX desteği piksel rengi biçimi 1-BPP tek renkli 32-BPP a:r: g:b biçiminde değişiyor.</span><span class="sxs-lookup"><span data-stu-id="a74b9-212">GUIX support pixel color formats ranging from 1-bpp monochrome to 32-bpp a:r:g:b format.</span></span> <span data-ttu-id="a74b9-213">GUX, r:g: b ile b:g: r bayt sıralaması, paketlenmiş piksel ve sözcük hizalanmış piksel formatları ve alfa kanalları gibi her geniş renk derinliği kategorisi içinde birçok çeşitlemeyi de destekler.</span><span class="sxs-lookup"><span data-stu-id="a74b9-213">GUIX also supports many variations within each broad color-depth category, such as r:g:b versus b:g:r byte order, packed pixel versus word-aligned pixel formats, and alpha channels.</span></span> <span data-ttu-id="a74b9-214">Şu anda 25 farklı renk biçimi destekleniyor, ancak donanım satıcıları yeni Çeşitlemeler sundukça bu liste büyür.</span><span class="sxs-lookup"><span data-stu-id="a74b9-214">There are currently 25 distinct color formats supported, but this list grows as hardware vendors deliver new variations.</span></span>

## <a name="display-memory-architectures"></a><span data-ttu-id="a74b9-215">Bellek mimarilerini görüntüleme</span><span class="sxs-lookup"><span data-stu-id="a74b9-215">Display Memory Architectures</span></span>

<span data-ttu-id="a74b9-216">Çeşitli donanım hedefleri ve ekranlar, hedefin bellek kısıtlamalarına ve uygulamanın işlev gereksinimlerine bağlı olarak çeşitli farklı görüntü belleği mimarilerinden yararlanır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-216">Various hardware targets and displays utilize a variety of different display memory architectures, depending on the memory constraints of the target and the functionality requirements of the application.</span></span> <span data-ttu-id="a74b9-217">Yaygın bellek mimarilerinden bazılarını, her birinin kısa bir açıklamasıyla özetler.</span><span class="sxs-lookup"><span data-stu-id="a74b9-217">We will outline some of the common memory architectures here with a brief description of each.</span></span>

<span data-ttu-id="a74b9-218">Model 1) çerçeve arabelleği yok, dış GRAM 'da tutulan grafik verileri:</span><span class="sxs-lookup"><span data-stu-id="a74b9-218">Model 1) No frame buffer, graphics data held in external GRAM:</span></span>

![Çerçeve arabelleği yok, dış GRAM 'da tutulan grafik verileri](./media/guix/user-guide/no-frame-buffer.png)

<span data-ttu-id="a74b9-220">Yukarıdaki modelde, CPU 'ya yerel bellekte bir çerçeve arabelleği için bellek yok.</span><span class="sxs-lookup"><span data-stu-id="a74b9-220">In the model above, no memory for a frame buffer exists in memory local to the CPU.</span></span> <span data-ttu-id="a74b9-221">Tüm grafik verileri, görüntünün kendisiyle birleştirilmiş bir dış GRAM 'da depolanır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-221">All graphics data is stored in an external GRAM which is incorporated into the display itself.</span></span> <span data-ttu-id="a74b9-222">Dış GRAM arabirimi paralel veya seri olabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-222">The interface to the external GRAM can be parallel or serial.</span></span> <span data-ttu-id="a74b9-223">Bu tür bir mimari çok düşük maliyettir; ancak grafik verileri güncelleştirilirken istenmeyen bir etkisi olabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-223">This type of architecture is very low cost; however it can exhibit unwanted tearing effect when the graphics data is updated.</span></span>

<span data-ttu-id="a74b9-224">Model 2) bir yerel çerçeve arabelleği:</span><span class="sxs-lookup"><span data-stu-id="a74b9-224">Model 2) One local frame buffer:</span></span>

![Bir yerel çerçeve arabelleği](./media/guix/user-guide/one-local-frame-buffer.png)

<span data-ttu-id="a74b9-226">Bu modelde, Grafik verilerinin belleği, CPU 'ya doğrudan erişilebilen Rastgele erişimli bir bellekten ayrılır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-226">In this model, memory for the graphics data is allocated from a random-access memory that is directly accessible the CPU.</span></span> <span data-ttu-id="a74b9-227">Grafik verilerini (zamanlama sinyalleriyle birlikte) yerel bellekten görüntülemeye tekrar tekrar iletmek için adanmış donanım mevcut olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-227">Dedicated hardware must be present to repeatedly transmit the graphics data (along with timing signals) from the local memory to the display.</span></span> <span data-ttu-id="a74b9-228">Bu model, grafik belleğinin, CPU tarafından kullanılabilen yerel SRAM veya DRAM 'nin bir bloğu olduğu model 1 ' den farklıdır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-228">This model differs from model 1 in that the graphics memory is a block of the local SRAM or DRAM available to the CPU.</span></span> <span data-ttu-id="a74b9-229">Bu, yığın ve program değişkenlerinin canlı olduğu bellekle aynı olabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-229">This may be the same memory in which stack and program variables live.</span></span>

<span data-ttu-id="a74b9-230">Model 3) yerel çerçeve arabelleği + dış GRAM:</span><span class="sxs-lookup"><span data-stu-id="a74b9-230">Model 3) Local frame buffer + external GRAM:</span></span>

![Yerel çerçeve arabelleği + dış GRAM](./media/guix/user-guide/local-frame-buffer-external-gram.png)

<span data-ttu-id="a74b9-232">Model 3, ilk iki öğesinin bir birleşimidir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-232">Model 3 is a combination of the first two.</span></span> <span data-ttu-id="a74b9-233">Bu modelde, bir çerçeve arabelleğini tutmak için yeterli yerel bellek vardır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-233">In this model, sufficient local memory exists to hold one frame buffer.</span></span> <span data-ttu-id="a74b9-234">Ayrıca, görüntü cihazı bir dış GRAM sağlar ve GRAM 'da sağlanan verileri kullanarak kendisini otomatik olarak yeniler.</span><span class="sxs-lookup"><span data-stu-id="a74b9-234">In addition, the display device provides an external GRAM and automatically refreshes itself using the data provided in the GRAM.</span></span> <span data-ttu-id="a74b9-235">Bu mimari, gelişmiş güncelleştirme verimliliğinden faydalanır çünkü yerel çerçeve arabelleğinin değiştirilen bölümünü tek bir blok aktarımından dış GRAM 'ya aktarabiliyoruz, genellikle ekleme DMA kanallarını kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-235">This architecture benefits from improved update efficiency because we can transfer the modified portion of the local frame buffer to the external GRAM in one block transfer, often utilizing onboard DMA channels.</span></span> <span data-ttu-id="a74b9-236">Bu model Ayrıca, yalnızca tamamlanmış grafik içerikleri dış GRAM 'a kopyalandığı için ilk iki modelden de bulunabilecek olan araçları ve titreşimi ortadan kaldırır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-236">This model also eliminates the tearing and flicker that can be present in either of the first two models, because only completed graphics contents is copied to the external GRAM.</span></span>

<span data-ttu-id="a74b9-237">Model 4) ping-pong çerçeve arabellekleri:</span><span class="sxs-lookup"><span data-stu-id="a74b9-237">Model 4) Ping-pong frame buffers:</span></span>

![Ping-pong çerçeve arabellekleri](./media/guix/user-guide/ping-pong-frame-buffers.png)

<span data-ttu-id="a74b9-239">Model 4 ' te, iki yerel çerçeve arabelleği sağlamak için yeterli bellek vardır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-239">In model 4, sufficient memory is present to provide two local frame buffers.</span></span> <span data-ttu-id="a74b9-240">Bu durumda, GUıDX, bir çerçeve arabelleğini etkin çerçeve arabelleği ve diğeri ise çalışma çerçevesi arabelleği olarak değerlendirir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-240">In this case, GUIX treats one frame buffer as the active frame buffer, and the other as the working frame buffer.</span></span> <span data-ttu-id="a74b9-241">Bir görüntüleme güncelleştirmesi veya çizim işlemi devam ederken, çalışma arabelleğinde gerçekleşir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-241">When a display update or drawing operation is in progress, it takes place in the working buffer.</span></span> <span data-ttu-id="a74b9-242">Çizim işlemi tamamlandığında, arabellekler çalışır ve çalışma arabelleği etkin arabellek olur ve etkin arabellek çalışma arabelleği olur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-242">When the drawing operation completes, the buffers are toggled, and the working buffer becomes the active buffer and the active buffer becomes the working buffer.</span></span> <span data-ttu-id="a74b9-243">Bu model, Ayrıca, tek bir arabelleğe alınmış sistemde gözlemlenebilir ekran titreşimini ve yük korumasını ortadan kaldırır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-243">This model also eliminates screen flicker and tearing that can be observed in a single buffered system.</span></span>

<span data-ttu-id="a74b9-244">Model 5) tuval birleştirme ile Pong arabellekleri:</span><span class="sxs-lookup"><span data-stu-id="a74b9-244">Model 5) Ping-pong buffers with canvas compositing:</span></span>

![Tuval birleştirme özellikli ping-pong arabellekleri](./media/guix/user-guide/ping-pong-buffers-canvas-composting.png)

<span data-ttu-id="a74b9-246">Model 5 ' te, kullanılabilir belleğin sınırlarına kadar herhangi bir sayıda canvaya oluşturulabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-246">In model 5, any number of canvases can be created, up to the limits of available memory.</span></span> <span data-ttu-id="a74b9-247">Tuvaller, tuval bileşimini oluşturmak için uygulama tarafından tanımlanan şekilde kaplama veya karışacaktır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-247">The canvases can be overlaid or blended together as defined by the application to create the canvas composite.</span></span> <span data-ttu-id="a74b9-248">Bir ekran yenileme işleminden sonra yeni bir bileşik oluşturulduğunda, etkin ve çalışan bileşik arabellekler standart ping-pong arabellek mimarisine benzer bir işlem halinde yapılır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-248">When a new composite is created after a screen refresh operation, the active and working composite buffers are toggled in an operation identical to the standard ping-pong buffer architecture.</span></span> <span data-ttu-id="a74b9-249">Model 5 ' i, son çıkış bileşik ' e karışarak ekran belirme ve karıştırma işlemlerini gerçekleştirme yeteneği ekler.</span><span class="sxs-lookup"><span data-stu-id="a74b9-249">Model 5 adds the ability to perform screen fade and blending operations by blending the canvases into the final output composite.</span></span>

<span data-ttu-id="a74b9-250">Model 6) dış GRAM ile tuval birleştirme:</span><span class="sxs-lookup"><span data-stu-id="a74b9-250">Model 6) Canvas compositing with external GRAM:</span></span>

![Dış GRAM ile tuval birleştirme](./media/guix/user-guide/canvas-compositing-external-gram.png)

<span data-ttu-id="a74b9-252">Model 6, 5 ' teki hafif bir çeşittir ve yalnızca bir bileşik arabelleğin gerekli olduğu ve bileşik arabelleğin dış GRAM 'ya aktarılmasının.</span><span class="sxs-lookup"><span data-stu-id="a74b9-252">Model 6 is a slight variation on Model 5, in which only one composite buffer is required and the composite buffer is then transferred to external GRAM.</span></span> <span data-ttu-id="a74b9-253">Bu model, tam ekran karıştırma ve yer paylaşımlarını da destekler.</span><span class="sxs-lookup"><span data-stu-id="a74b9-253">This model also supports full screen blending and overlays.</span></span>

## <a name="string-encoding"></a><span data-ttu-id="a74b9-254">Dize kodlama</span><span class="sxs-lookup"><span data-stu-id="a74b9-254">String Encoding</span></span> 

<span data-ttu-id="a74b9-255">GUX varsayılan olarak UTF8 biçim dize kodlamasını destekler.</span><span class="sxs-lookup"><span data-stu-id="a74b9-255">GUIX by default supports UTF8 format string encoding.</span></span> <span data-ttu-id="a74b9-256">***Gx_user. h*** üstbilgi dosyasında **GX_DISABLE_UTF8_SUPPORT** tanımlayarak UTF8 dize kodlaması desteği devre dışı bırakılabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-256">Support for UTF8 string encoding can be disabled by defining **GX_DISABLE_UTF8_SUPPORT** in the ***gx_user.h*** header file.</span></span> <span data-ttu-id="a74b9-257">UTF8 kodlaması devre dışıysa, GUıDX yalnızca standart 8 bit ASCII ve Latin-1 kod sayfası karakter kodlamasını kullanır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-257">If UTF8 encoding is disabled, GUIX will internally use only standard 8-bit ASCII plus Latin-1 code page character encoding.</span></span> <span data-ttu-id="a74b9-258">UTF8 dize kodlamasının devre dışı bırakılması, biraz daha küçük bir Gux kitaplığı ayak izine ve dize işleme ve metin çizim işlevlerinin biraz daha hızlı bir şekilde yürütülmesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-258">Disabling UTF8 string encoding results in a slightly smaller GUIX library footprint and slightly faster runtime execution of string handling and text drawing functions.</span></span>

<span data-ttu-id="a74b9-259">UTF8 dize kodlaması aşağıdaki nitelikleri içerir:</span><span class="sxs-lookup"><span data-stu-id="a74b9-259">UTF8 string encoding has the following traits:</span></span>

  - <span data-ttu-id="a74b9-260">ASCII dizeleri standart 7 bit ASCII kodlamasından daha fazla depolama alanı almaz.</span><span class="sxs-lookup"><span data-stu-id="a74b9-260">ASCII strings take no more storage space than standard 7-bit ASCII encoding.</span></span>

  - <span data-ttu-id="a74b9-261">Çoğu ANSI-C dize işlevleri, hiçbir değişiklik yapılmadan UTF8 dize kodlaması ile çalışır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-261">Most ANSI-C string functions work with UTF8 string encoding without modification.</span></span>

<span data-ttu-id="a74b9-262">Kanji karakter kümeleri de dahil olmak üzere dünyanın tüm etkin karakter kümeleri, UTF8 dize kodlaması ile gösterilebilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-262">All active character sets in the world, including Kanji character sets, can be represented using UTF8 string encoding.</span></span>

### <a name="static-and-dynamic-strings"></a><span data-ttu-id="a74b9-263">Statik ve dinamik dizeler</span><span class="sxs-lookup"><span data-stu-id="a74b9-263">Static and Dynamic Strings</span></span> 

<span data-ttu-id="a74b9-264">Metin görüntülemeyi destekleyen GUıDX pencere öğelerinizi atanan dizeler, normalde aşağıda açıklanan Gux dize tablosunun bir parçası olarak sabit depolamaya yerleştirilmiş olan statik olarak tanımlanmış dize sabitleri ve \***sprintf** _ veya _ *_gx_utility_ltoa_* \* gibi hizmetler kullanılarak çalışma zamanında oluşturulan dizeler olan dinamik olarak tanımlanmış dizeler olabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-264">The strings assigned to your GUIX widgets which support text display can be statically defined string constants, which are normally placed in constant storage as part of the GUIX String table described below, and dynamically defined strings, which are strings generated at runtime using services such as ***sprintf** _ or _*_gx_utility_ltoa_\*\*.</span></span>

<span data-ttu-id="a74b9-265">Dinamik dizeler örnekleri, bir Gux istem pencere öğesi içinde sayı olarak veya kullanıcının konum ve biçim tercihlerine göre dinamik olarak biçimlendirilen bir "saat/tarih" dizesi olarak görüntülenmiş bir değer içerebilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-265">Examples of dynamic strings might include a value displayed as a number within a GUIX prompt widget, or a “time / date” string which is dynamically formatted based on the user’s location and format preferences.</span></span> <span data-ttu-id="a74b9-266">Çalışma zamanında **GX_PROMPT** veya **GX_TEXT_BUTTON pencere öğeleri** gibi Guix pencere sayfalarına atanacak dizeler oluşturursanız, bu çalışma zamanı tarafından oluşturulan dizeler için depolamayı statik olarak ayırmayı seçmeniz gerekir (ör.</span><span class="sxs-lookup"><span data-stu-id="a74b9-266">If you create strings at runtime which will be assigned to GUIX widgets such as **GX_PROMPT** or **GX_TEXT_BUTTON widgets**, you must choose to either statically allocate the storage for these runtime generated strings (i.e</span></span>
<span data-ttu-id="a74b9-267">Genel karakter dizileri) veya dinamik bir bellek ayırıcı işlevi tanımlayabilir ve yükleyebilir ve bu pencere öğelerinin atanan metin dizelerinin özel bir kopyasını oluşturmasına yönlendiren **GX_STYLE_TEXT_COPY** stilini kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a74b9-267">global character arrays), or you can define and install a dynamic memory allocator function and use the **GX_STYLE_TEXT_COPY** style, which instructs those widgets to create a private copy of text strings assigned.</span></span>

<span data-ttu-id="a74b9-268">Dinamik olarak oluşturulan bir dizeyi tutmak ve sonra bu dizeyi **GX_STYLE_TEXT_COPY** stiline sahip olmayan bir pencere öğesine atamak için, otomatik karakter dizisi gibi geçici depolamayı kullanmanın bir programlama hatasıdır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-268">It is a programming error to use temporary storage, such as an automatic character array, to hold a dynamically generated string and then assign this string to a widget that does not have the **GX_STYLE_TEXT_COPY** style.</span></span> <span data-ttu-id="a74b9-269">Bu stil etkin olmadığında pencere öğesi yalnızca sağlanan dize işaretçisini kopyalar ve dize verileri statik olarak ayrılmalıdır veya pencere öğesi dize işaretçisi, beklenmeyen sonuçlar üreten çöp verilerinde büyük olasılıkla bitecektir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-269">When this style is not enabled, the widget simply copies the provided string pointer, and the string data must be statically allocated or the widget string pointer will likely end up pointing at garbage data producing unpredictable results.</span></span>

### <a name="passing-gx_string-arguments"></a><span data-ttu-id="a74b9-270">GX_STRING bağımsız değişkenlerini geçirme</span><span class="sxs-lookup"><span data-stu-id="a74b9-270">Passing GX_STRING arguments</span></span> 

<span data-ttu-id="a74b9-271">GX_STRING parametresini kabul eden Gux API işlevleri, **GX_STRING. gx_string_ptr** alanı tarafından işaret edilen dizenin uzunluğunun **GX_STRING. gx_string_length** alanının değeriyle eşleştiğini her zaman doğrular.</span><span class="sxs-lookup"><span data-stu-id="a74b9-271">The GUIX API functions which accept a GX_STRING parameter always verify that the length of the string pointed to by the **GX_STRING.gx_string_ptr** field match the value of the **GX_STRING.gx_string_length** field.</span></span> <span data-ttu-id="a74b9-272">İki alan tutarlı değilse, **GX_INVALID_STRING_LENGTH** bir hata döndürülür ve çağrılan API, dize atamasını kabul etmeden döndürülür.</span><span class="sxs-lookup"><span data-stu-id="a74b9-272">If the two fields are not consistent, a **GX_INVALID_STRING_LENGTH** error is returned and the API called returns without accepting the string assignment.</span></span>

<span data-ttu-id="a74b9-273">GUX yazılımının güvenlik açısından dikkat edilmesi gereken noktalar, \***strlen** _ veya _ *_strcpy_* \* gibi standart C dize işlevlerini hiçbir zaman kullanmaz.</span><span class="sxs-lookup"><span data-stu-id="a74b9-273">For safety considerations the GUIX software never internally uses the standard C string functions such as ***strlen** _ or _*_strcpy_\*\*.</span></span> <span data-ttu-id="a74b9-274">Bu işlevlerin, genellikle bağlı uygulamalarda bu durum büyük bir süredir olan dize verileri dinamik olarak elde edildiğinde kötü amaçlı saldırılara açıktır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-274">These functions have been known to be susceptible to malicious attacks when string data is acquired dynamically which is often the case with connected applications.</span></span>

<span data-ttu-id="a74b9-275">Bir parametre olarak kabul edilen () sürüm 5,6 tanımlı API işlevlerinden önce Gux kitaplığı yayınları `GX_CONST GX_CHAR *text` .</span><span class="sxs-lookup"><span data-stu-id="a74b9-275">GUIX library releases prior to release 5.6 defined API functions which accepted (`GX_CONST GX_CHAR *text`) as a parameter.</span></span> <span data-ttu-id="a74b9-276">Bu işlevler, geriye doğru uyumluluk için hala desteklenirken, bir giriş parametresi olarak kabul edilen () tercih edilen API işlevleri tarafından kullanımdan kaldırılmıştır ve değiştirilmiştir `GX_CONST GX_STRING *string` .</span><span class="sxs-lookup"><span data-stu-id="a74b9-276">These functions, while still supported for backwards compatibility, have been obsoleted and replaced by the preferred API functions which accept (`GX_CONST GX_STRING *string`) as an input parameter.</span></span>

<span data-ttu-id="a74b9-277">Varsayılan olarak, kullanım dışı bırakılan metin işleme API 'SI, önceden yazılmış tüm uygulamaların Gux kitaplığındaki en son güncelleştirmelerle düzgün bir şekilde derlenmesine olanak tanımak için etkinleştirilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-277">By default, the deprecated text handling API is enabled allowing all previously written applications to build cleanly with the latest updates to the GUIX library.</span></span> <span data-ttu-id="a74b9-278">Kullanım dışı bırakılan metin işleme API 'sini devre dışı bırakmak için **GX_DISABLE_DEPRECATED_STRING_API** tanım **_gx_user. h_\*_ üst bilgi dosyasına eklenmelidir. Tüm yeni uygulamalar _ GX_DISABLE_DEPRECATED_STRING_API tanımlamalıdır**\* ve yalnızca değiştirme API işlevlerini kullanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-278">To disable the the deprecated text handling API, the definition **GX_DISABLE_DEPRECATED_STRING_API** should be added to the **_gx_user.h_*_ header file. All new applications should define _\* GX_DISABLE_DEPRECATED_STRING_API*\* and should use only the replacement API functions.</span></span> <span data-ttu-id="a74b9-279">GUX kitaplığı sürüm sürüm 5,6 veya üzeri için Gux Studio tarafından oluşturulan tüm çıkış dosyaları yalnızca değiştirme API işlevlerini kullanır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-279">All output files generated by GUIX Studio for GUIX library version release 5.6 or later will utilize only the replacement API functions.</span></span>

<span data-ttu-id="a74b9-280">Aşağıdaki tabloda, kullanım dışı ve yeni tanımlanmış değiştirme API 'SI işlev adları listelenmektedir:</span><span class="sxs-lookup"><span data-stu-id="a74b9-280">The following table lists the deprecated and newly defined replacement API function names:</span></span>

| <span data-ttu-id="a74b9-281">**Kullanım dışı Işlev adı**</span><span class="sxs-lookup"><span data-stu-id="a74b9-281">**Deprecated Function Name**</span></span>              | <span data-ttu-id="a74b9-282">**Yenisiyle değiştirilmiş**</span><span class="sxs-lookup"><span data-stu-id="a74b9-282">**Replaced With**</span></span>                              |
| ------------------------------------------ | ----------------------------------------------- |
| <span data-ttu-id="a74b9-283">gx_binres_language_table_load</span><span class="sxs-lookup"><span data-stu-id="a74b9-283">gx_binres_language_table_load</span></span>          | <span data-ttu-id="a74b9-284">gx_binres_language_table_load_ext</span><span class="sxs-lookup"><span data-stu-id="a74b9-284">gx_binres_language_table_load_ext</span></span>          |
| <span data-ttu-id="a74b9-285">gx_canvas_rotated_text_draw</span><span class="sxs-lookup"><span data-stu-id="a74b9-285">gx_canvas_rotated_text_draw</span></span>            | <span data-ttu-id="a74b9-286">gx_canvas_rotated_text_draw_ext</span><span class="sxs-lookup"><span data-stu-id="a74b9-286">gx_canvas_rotated_text_draw_ext</span></span>            |
| <span data-ttu-id="a74b9-287">gx_canvas_text_draw</span><span class="sxs-lookup"><span data-stu-id="a74b9-287">gx_canvas_text_draw</span></span>                     | <span data-ttu-id="a74b9-288">gx_canvas_text_draw_ext</span><span class="sxs-lookup"><span data-stu-id="a74b9-288">gx_canvas_text_draw_ext</span></span>                     |
| <span data-ttu-id="a74b9-289">gx_context_string_get</span><span class="sxs-lookup"><span data-stu-id="a74b9-289">gx_context_string_get</span></span>                   | <span data-ttu-id="a74b9-290">gx_context_string_get_ext</span><span class="sxs-lookup"><span data-stu-id="a74b9-290">gx_context_string_get_ext</span></span>                   |
| <span data-ttu-id="a74b9-291">gx_display_language_table_get</span><span class="sxs-lookup"><span data-stu-id="a74b9-291">gx_display_language_table_get</span></span>          | <span data-ttu-id="a74b9-292">gx_display_language_table_get_ext</span><span class="sxs-lookup"><span data-stu-id="a74b9-292">gx_display_language_table_get_ext</span></span>          |
| <span data-ttu-id="a74b9-293">gx_display_language_table_set</span><span class="sxs-lookup"><span data-stu-id="a74b9-293">gx_display_language_table_set</span></span>          | <span data-ttu-id="a74b9-294">gx_display_language_table_set_ext</span><span class="sxs-lookup"><span data-stu-id="a74b9-294">gx_display_language_table_set_ext</span></span>          |
| <span data-ttu-id="a74b9-295">gx_display_string_get</span><span class="sxs-lookup"><span data-stu-id="a74b9-295">gx_display_string_get</span></span>                   | <span data-ttu-id="a74b9-296">gx_display_string_get_ext</span><span class="sxs-lookup"><span data-stu-id="a74b9-296">gx_display_string_get_ext</span></span>                   |
| <span data-ttu-id="a74b9-297">gx_display_string_table_get</span><span class="sxs-lookup"><span data-stu-id="a74b9-297">gx_display_string_table_get</span></span>            | <span data-ttu-id="a74b9-298">gx_display_string_table_get_ext</span><span class="sxs-lookup"><span data-stu-id="a74b9-298">gx_display_string_table_get_ext</span></span>            |
| <span data-ttu-id="a74b9-299">gx_multi_line_text_button_text_set</span><span class="sxs-lookup"><span data-stu-id="a74b9-299">gx_multi_line_text_button_text_set</span></span>   | <span data-ttu-id="a74b9-300">gx_multi_line_text_button_text_set_ext</span><span class="sxs-lookup"><span data-stu-id="a74b9-300">gx_multi_line_text_button_text_set_ext</span></span>   |
| <span data-ttu-id="a74b9-301">gx_multi_line_text_input_char_insert</span><span class="sxs-lookup"><span data-stu-id="a74b9-301">gx_multi_line_text_input_char_insert</span></span> | <span data-ttu-id="a74b9-302">gx_multi_line_text_input_char_insert_ext</span><span class="sxs-lookup"><span data-stu-id="a74b9-302">gx_multi_line_text_input_char_insert_ext</span></span> |
| <span data-ttu-id="a74b9-303">gx_multi_line_text_input_text_set</span><span class="sxs-lookup"><span data-stu-id="a74b9-303">gx_multi_line_text_input_text_set</span></span>    | <span data-ttu-id="a74b9-304">gx_multi_line_text_input_text_set_ext</span><span class="sxs-lookup"><span data-stu-id="a74b9-304">gx_multi_line_text_input_text_set_ext</span></span>    |
| <span data-ttu-id="a74b9-305">gx_multi_line_text_view_text_set</span><span class="sxs-lookup"><span data-stu-id="a74b9-305">gx_multi_line_text_view_text_set</span></span>     | <span data-ttu-id="a74b9-306">gx_multi_line_text_view_text_set_ext</span><span class="sxs-lookup"><span data-stu-id="a74b9-306">gx_multi_line_text_view_text_set_ext</span></span>     |
| <span data-ttu-id="a74b9-307">gx_prompt_text_get</span><span class="sxs-lookup"><span data-stu-id="a74b9-307">gx_prompt_text_get</span></span>                      | <span data-ttu-id="a74b9-308">gx_prompt_text_get_ext</span><span class="sxs-lookup"><span data-stu-id="a74b9-308">gx_prompt_text_get_ext</span></span>                      |
| <span data-ttu-id="a74b9-309">gx_prompt_text_set</span><span class="sxs-lookup"><span data-stu-id="a74b9-309">gx_prompt_text_set</span></span>                      | <span data-ttu-id="a74b9-310">gx_prompt_text_set_ext</span><span class="sxs-lookup"><span data-stu-id="a74b9-310">gx_prompt_text_set_ext</span></span>                      |
| <span data-ttu-id="a74b9-311">gx_single_line_text_input_text_set</span><span class="sxs-lookup"><span data-stu-id="a74b9-311">gx_single_line_text_input_text_set</span></span>   | <span data-ttu-id="a74b9-312">gx_single_line_text_input_text_set_ext</span><span class="sxs-lookup"><span data-stu-id="a74b9-312">gx_single_line_text_input_text_set_ext</span></span>   |
| <span data-ttu-id="a74b9-313">gx_system_string_width_get</span><span class="sxs-lookup"><span data-stu-id="a74b9-313">gx_system_string_width_get</span></span>             | <span data-ttu-id="a74b9-314">gx_system_string_width_get_ext</span><span class="sxs-lookup"><span data-stu-id="a74b9-314">gx_system_string_width_get_ext</span></span>             |
| <span data-ttu-id="a74b9-315">gx_system_version_string_get</span><span class="sxs-lookup"><span data-stu-id="a74b9-315">gx_system_version_string_get</span></span>           | <span data-ttu-id="a74b9-316">gx_system_version_string_get_ext</span><span class="sxs-lookup"><span data-stu-id="a74b9-316">gx_system_version_string_get_ext</span></span>           |
| <span data-ttu-id="a74b9-317">gx_text_button_text_get</span><span class="sxs-lookup"><span data-stu-id="a74b9-317">gx_text_button_text_get</span></span>                | <span data-ttu-id="a74b9-318">gx_text_button_text_get_ext</span><span class="sxs-lookup"><span data-stu-id="a74b9-318">gx_text_button_text_get_ext</span></span>                |
| <span data-ttu-id="a74b9-319">gx_text_button_text_set</span><span class="sxs-lookup"><span data-stu-id="a74b9-319">gx_text_button_text_set</span></span>                | <span data-ttu-id="a74b9-320">gx_text_button_text_set_ext</span><span class="sxs-lookup"><span data-stu-id="a74b9-320">gx_text_button_text_set_ext</span></span>                |
| <span data-ttu-id="a74b9-321">gx_text_scroll_wheel_callback_set</span><span class="sxs-lookup"><span data-stu-id="a74b9-321">gx_text_scroll_wheel_callback_set</span></span>     | <span data-ttu-id="a74b9-322">gx_text_scroll_wheel_callback_set_ext</span><span class="sxs-lookup"><span data-stu-id="a74b9-322">gx_text_scroll_wheel_callback_set_ext</span></span>     |
| <span data-ttu-id="a74b9-323">gx_utility_string_to_alphamap</span><span class="sxs-lookup"><span data-stu-id="a74b9-323">gx_utility_string_to_alphamap</span></span>          | <span data-ttu-id="a74b9-324">gx_utility_string_to_alphamap_ext</span><span class="sxs-lookup"><span data-stu-id="a74b9-324">gx_utility_string_to_alphamap_ext</span></span>          |
| <span data-ttu-id="a74b9-325">gx_widget_string_get</span><span class="sxs-lookup"><span data-stu-id="a74b9-325">gx_widget_string_get</span></span>                    | <span data-ttu-id="a74b9-326">gx_widget_string_get_ext</span><span class="sxs-lookup"><span data-stu-id="a74b9-326">gx_widget_string_get_ext</span></span>                    |
| <span data-ttu-id="a74b9-327">gx_widget_text_blend</span><span class="sxs-lookup"><span data-stu-id="a74b9-327">gx_widget_text_blend</span></span>                    | <span data-ttu-id="a74b9-328">gx_widget_text_blend_ext</span><span class="sxs-lookup"><span data-stu-id="a74b9-328">gx_widget_text_blend_ext</span></span>                    |
| <span data-ttu-id="a74b9-329">gx_widget_text_draw</span><span class="sxs-lookup"><span data-stu-id="a74b9-329">gx_widget_text_draw</span></span>                     | <span data-ttu-id="a74b9-330">gx_widget_text_draw_ext</span><span class="sxs-lookup"><span data-stu-id="a74b9-330">gx_widget_text_draw_ext</span></span>                     |

### <a name="guix-string-table"></a><span data-ttu-id="a74b9-331">GUIX Dize Tablosu</span><span class="sxs-lookup"><span data-stu-id="a74b9-331">GUIX String Table</span></span> 

<span data-ttu-id="a74b9-332">GUIX dize tablosu ve dize kaynakları bir GUIX görüntüleme örneğiyle kaydedilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-332">The GUIX string table and string resources are registered with a GUIX display instance.</span></span>

<span data-ttu-id="a74b9-333">Çok görüntülemeli sistemlerde her ekran kendi dize tablosuna sahiptir ve her görüntü kendi seçili dilinde çalışmasına izin verir. Bu kaynak türleri her görüntü renk biçimine ve renk derinliğine özgü olduğu için diğer GUIX kaynak türleri (renkler, yazı tipleri ve piksel haritaları) GUIX Görüntüleme bileşeni tarafından da korunur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-333">Each display in a multi-display system has its own string table, and each display can run in its own selected language.The other GUIX resource types (colors, fonts, and pixelmaps) are also maintained by the GUIX Display component, since these resource types are specific to each display color format and color depth.</span></span>

<span data-ttu-id="a74b9-334">Uygulama dizesi tabloyu el ile oluşturabilirsiniz ancak çoğu zaman görünen dize tablosu guiX Studio uygulaması tarafından proje kaynak dosyanız kapsamında tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-334">While you can manually create your application string table, most often the display string table is defined by the GUIX Studio application as part of your project resource file.</span></span> <span data-ttu-id="a74b9-335">Kullanılabilir diller kaynak üst bilgi dosyasında da tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-335">The available languages are also defined in the resource header file.</span></span> <span data-ttu-id="a74b9-336">Görünen dize tablosu, uygulama dizelerinin işaretçilerinin yer alan çok sütunlu bir tablosudur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-336">The display string table is a multi-column table of pointers to application strings.</span></span> <span data-ttu-id="a74b9-337">Dize tablosu sütunlarının her biri, uygulama tarafından desteklenen bir dili temsil eder.</span><span class="sxs-lookup"><span data-stu-id="a74b9-337">Each column of the string table represents one language supported by the application.</span></span>
<span data-ttu-id="a74b9-338">Uygulamanız yalnızca bir dili destekliyorsa (örneğin İngilizce) dize tablonda yalnızca bir sütun olur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-338">If your application supports only one language, for example English, then your string table will have only one column.</span></span> <span data-ttu-id="a74b9-339">Yine de, uygulama yazılımınızı değiştirmeden istediğiniz zaman ek diller için destek ebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a74b9-339">Still, you can add support for additional languages at any time without modifying your application software.</span></span>

<span data-ttu-id="a74b9-340">Etkin dize tablosu, api işlevi ***çağrılarak gx_display_string_table_set*** atanır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-340">The active string table is assigned by calling the ***gx_display_string_table_set*** API function.</span></span> <span data-ttu-id="a74b9-341">Bu işlev GUIX Studio tarafından oluşturulan başlangıç kodu tarafından otomatik olarak çağrılır, ancak etkin dize tablosu değiştirmek için doğrudan uygulama tarafından da çağrılabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-341">This function is called automatically by the GUIX Studio generated startup code, but can also be called directly by the application to change the active string table.</span></span>

<span data-ttu-id="a74b9-342">Etkin dil, api işlevi ***çağrılarak gx_display_active_language_set*** atanır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-342">The active language is assigned by calling the ***gx_display_active_language_set*** API function.</span></span> <span data-ttu-id="a74b9-343">Bu işlev, görüntüleme dizesi tablosunda hangi sütunun etkin olduğunu belirler.</span><span class="sxs-lookup"><span data-stu-id="a74b9-343">This function determines which column of the display string table is active.</span></span>

<span data-ttu-id="a74b9-344">Bu işlev çağrıldığında, **GX_EVENT_LANGUAGE_CHANGE** GUIX pencere öğelerine yeni etkin dize verilerini görüntülemek üzere güncelleştirmelerine izin veren bir olay gönderilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-344">When this function is invoked, a **GX_EVENT_LANGUAGE_CHANGE** event is sent to all visible GUIX widgets, allowing them to update to display the newly active string data.</span></span>

<span data-ttu-id="a74b9-345">Pencere öğeleri ve uygulama yazılımı, dize kimliği değerlerini ve API işlevlerini kullanarak statik ***gx_display_string_get_ext*** ***veya gx_widget_string_get_ext*** çözümler.</span><span class="sxs-lookup"><span data-stu-id="a74b9-345">Widgets and application software resolve statically defined strings using string ID values and the ***gx_display_string_get_ext*** or ***gx_widget_string_get_ext*** API functions.</span></span> <span data-ttu-id="a74b9-346">Bu işlevler, **belirli GX_STRING** kimliği ve o anda etkin olan dille ilişkili olan verileri döndürür.</span><span class="sxs-lookup"><span data-stu-id="a74b9-346">These functions return the **GX_STRING** associated with a given string ID and the currently active language.</span></span>

### <a name="bi-directional-text-display"></a><span data-ttu-id="a74b9-347">Çift Yönlü Metin Görüntüleme</span><span class="sxs-lookup"><span data-stu-id="a74b9-347">Bi-directional Text Display</span></span> 

<span data-ttu-id="a74b9-348">GUIX, çift yönlü metin desteği için iki strateji sağlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-348">GUIX provide two strategies for bi-directional text support.</span></span>

<span data-ttu-id="a74b9-349">Seçeneklerden biri, GUIX Studio uygulamasında çift metin yeniden sıralama yapmaktır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-349">One option is to do bidi text reordering within the GUIX Studio application.</span></span> <span data-ttu-id="a74b9-350">Bu seçeneğin kullanımı GUIX Studio, çıkış dosyasına görüntüleme sırasına göre çift metin oluşturmakla sorumludur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-350">Using this option GUIX Studio is responsible for generating bidi text to the output file in its display order.</span></span> <span data-ttu-id="a74b9-351">Bu çözümün çalışma zamanı performansı üzerinde sıfır etkisi vardır ve GUIX çalışma zamanı kitaplığına herhangi bir ekleme gerektirmez.</span><span class="sxs-lookup"><span data-stu-id="a74b9-351">This solution has zero impact on the runtime performance and does not require any additions to the GUIX runtime library.</span></span> <span data-ttu-id="a74b9-352">GUIX Studio'nun displayorder bidi metin dizeleri oluşturmasına izin vermek için GUIX Studio dil yapılandırması iletişim kutusundaki Görüntü Düzeninde **Bidi** Metni Oluştur onay kutusunu seçmeniz gerekir:</span><span class="sxs-lookup"><span data-stu-id="a74b9-352">To allow GUIX Studio to generate displayorder bidi text strings, you should select the **Generate Bidi Text in Display Order** checkbox in the GUIX Studio language configuration dialog:</span></span>

![Dilleri yapılandırma](./media/guix/user-guide/configure-languages.png)

<span data-ttu-id="a74b9-354">Bu seçenekler seçiliyken, oluşturulan kaynak dosyası görüntüleme sırasında oluşturulan Bidi dizelerini içerir ve GUIX çalışma zamanı kitaplığında ek işlem gerekmez.</span><span class="sxs-lookup"><span data-stu-id="a74b9-354">With these options selected, the generated resource file will contain Bidi strings generated in display order, and no extra processing is required within the GUIX runtime library.</span></span>

<span data-ttu-id="a74b9-355">İkinci seçenek, çalışma zamanında çift metin yeniden sıralamasını yapmaktır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-355">The second option is to do bidi text reordering at runtime.</span></span> <span data-ttu-id="a74b9-356">Bu seçenek dinamik olarak tanımlanan ve GUIX Studio uygulaması tarafından oluşturulmamış çift metin dizesini işlemesi gereken uygulamalar için de kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-356">This option is supported for those applications that must handle bidi text string that are dynamically defined, and not generated by the GUIX Studio application.</span></span> <span data-ttu-id="a74b9-357">Bu durumda GUIX çalışma zamanı kitaplığı, her metin dizesini çizmeden önce bidi metnini yeniden sıralamakla sorumludur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-357">In this case the GUIX runtime library is responsible for reordering the bidi text before drawing each text string.</span></span> <span data-ttu-id="a74b9-358">Bu çözümün çalışma zamanı performansı ve bellek etkisi vardır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-358">This solution has a runtime performance and memory impact.</span></span> <span data-ttu-id="a74b9-359">Çift metin yeniden sıralama işlemi için yeterli dinamik bellek kullanılabilir olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-359">Sufficient dynamic memory must be available for bidi text reordering process.</span></span> <span data-ttu-id="a74b9-360">Bu çözüm, GUIX kitaplığı GX_DYNAMIC_BIDI_TEXT_SUPPORT koşullu uygulamanın tanımlanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-360">This solution requires that the conditional GX_DYNAMIC_BIDI_TEXT_SUPPORT be defined when building the GUIX library.</span></span> <span data-ttu-id="a74b9-361">Çalışma zamanında ***bidi*** ***gx_system_bidi_text_enable/gx_system_bidi_text_disable*** etkinleştirmek/devre dışı bırakmak için iki API işlevi sağlanır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-361">Two API functions ***gx_system_bidi_text_enable*** and ***gx_system_bidi_text_disable*** are provided to enable/disable bidi text support at runtime.</span></span>

<span data-ttu-id="a74b9-362">Hem kullanıcı adı GX_DYNAMIC_BIDI_TEXT_SUPPORT **hem** de GUIX Studio'yu görüntü sırasına göre Bidi metni oluşturmak üzere yapılandırmamalı.</span><span class="sxs-lookup"><span data-stu-id="a74b9-362">You should not use both **GX_DYNAMIC_BIDI_TEXT_SUPPORT** and configure GUIX Studio to generate Bidi text in display order.</span></span> <span data-ttu-id="a74b9-363">bidi metin dizesi işleme için bir strateji veya diğeri seçmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-363">You must select one strategy or the other for bidi text string handling.</span></span>

## <a name="memory-usage"></a><span data-ttu-id="a74b9-364">Bellek Kullanımı</span><span class="sxs-lookup"><span data-stu-id="a74b9-364">Memory Usage</span></span> 

<span data-ttu-id="a74b9-365">GUIX, uygulama programıyla birlikte yer almaktadır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-365">GUIX resides along with the application program.</span></span> <span data-ttu-id="a74b9-366">Sonuç olarak, GUIX'in statik bellek (veya sabit bellek) kullanımı geliştirme araçları tarafından belirlenir; Örneğin, derleyici, bağlantılayıcı ve bulucu.</span><span class="sxs-lookup"><span data-stu-id="a74b9-366">As a result, the static memory (or fixed memory) usage of GUIX is determined by the development tools; e.g., the compiler, linker, and locator.</span></span> <span data-ttu-id="a74b9-367">Dinamik bellek (veya çalışma zamanı belleği) kullanımı uygulamanın doğrudan denetimi altındadır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-367">Dynamic memory (or run-time memory) usage is under direct control of the application.</span></span>

### <a name="static-memory-usage"></a><span data-ttu-id="a74b9-368">Statik Bellek Kullanımı</span><span class="sxs-lookup"><span data-stu-id="a74b9-368">Static Memory Usage</span></span> 

<span data-ttu-id="a74b9-369">Geliştirme araçlarının çoğu uygulama programı görüntüsünü beş temel bölüme böler: yönerge *,* *sabit,* başlatılan *veriler,* başlatılmamış *veriler* ve *GUIX iş parçacığı yığını.*</span><span class="sxs-lookup"><span data-stu-id="a74b9-369">Most of the development tools divide the application program image into five basic areas: *instruction*, *constant*, *initialized data*, *uninitialized data*, and the *GUIX thread stack*.</span></span>  <span data-ttu-id="a74b9-370">Aşağıdaki şekilde, bu bellek alanlarının olası bir düzeni gösterilmiştir:</span><span class="sxs-lookup"><span data-stu-id="a74b9-370">The figure below demonstrates one possible layout of these memory areas:</span></span>

![Bellek düzeni](./media/guix/user-guide/memory-area-example.png)

<span data-ttu-id="a74b9-372">Bunun yalnızca bir örnek olduğunu anlamak önemlidir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-372">It is important to understand that this only an example.</span></span> <span data-ttu-id="a74b9-373">Gerçek statik bellek düzeni işlemciye, geliştirme araçlarına, temel alınan donanıma ve uygulamanın kendisine özeldir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-373">The actual static memory layout is specific to the processor, development tools, underlying hardware, and the application itself.</span></span>

<span data-ttu-id="a74b9-374">Yönerge alanı, programın tüm işlemci yönergelerini içerir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-374">The instruction area contains all of the program’s processor instructions.</span></span> <span data-ttu-id="a74b9-375">Bu alan genellikle ROM'da bulunur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-375">This area is often located in ROM.</span></span>

<span data-ttu-id="a74b9-376">Sabit alan, GUIX'te varsayılan ayarları ve tüm uygulama kaynaklarını (görüntüler, dizeler, yazı tipleri ve renkler) içeren çeşitli derlenmiş sabitler içerir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-376">The constant area contains various compiled constants, which in GUIX contains default settings and all application resources (images, strings, fonts, and colors).</span></span> <span data-ttu-id="a74b9-377">Ayrıca, bu alan başlatılan veri alanı "ilk kopyasını" içerir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-377">In addition, this area contains the “initial copy” of the initialized data area.</span></span> <span data-ttu-id="a74b9-378">Derleyicinin başlatma işlemi sırasında sabit alanı bu kısmı RAM'de genel olarak başlatılan verileri ayarlamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-378">During the compiler’s initialization process, this portion of the constant area is used to set up the global initialized data in RAM.</span></span> <span data-ttu-id="a74b9-379">Sabit alan genellikle en büyük olandır ve genellikle yönerge alanına sahiptir ve genellikle ROM'da bulunur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-379">The constant area is typically the largest and usually follows the instruction area and is often located in ROM.</span></span>

<span data-ttu-id="a74b9-380">GUIX piksel haritaları ve yazı tipleri genellikle büyük miktarlarda sabit veri depolaması gerektirir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-380">GUIX pixelmaps and fonts typically require large amounts of constant data storage.</span></span> <span data-ttu-id="a74b9-381">Bu büyük statik veri alanları normalde ROM veya FLASH içinde tutulur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-381">These large static data areas are normally kept in ROM or FLASH.</span></span>

<span data-ttu-id="a74b9-382">GUIX iş parçacığı yığını, gx_system.h dosyasındaki ilklanmamış veri ***alanında (genel değişken*** olarak) aşağıdaki gibi tanımlanır:</span><span class="sxs-lookup"><span data-stu-id="a74b9-382">The GUIX thread stack is defined within the uninitialized data area (as a global variable) in ***gx_system.h*** file as follows:</span></span>

```C
_gx_system_thread_stack[GX_THREAD_STACK_SIZE];
```

<span data-ttu-id="a74b9-383">**GX_THREAD_STACK_SIZE** **_gx_port.h_** dosyasında tanımlanır, ancak ***gx_user.h*** üst bilgi dosyasında veya proje seçenekleri ya da komut satırı parametreleri aracılığıyla bu simge tanımlayarak uygulama tarafından geçersiz kılınabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-383">**GX_THREAD_STACK_SIZE** is defined in **_gx_port.h_**, but may be overridden by the application by defining this symbol in the ***gx_user.h*** header file or via project options or command line parameters.</span></span> <span data-ttu-id="a74b9-384">Yığın boyutu en kötü olay işleme ve iç içe geçmiş çizim çağrılarını işecek kadar büyük olmalı.</span><span class="sxs-lookup"><span data-stu-id="a74b9-384">The stack size must be large enough to handle the worst case event handling and nested drawing calls.</span></span>

### <a name="dynamic-memory-usage"></a><span data-ttu-id="a74b9-385">Dinamik Bellek Kullanımı</span><span class="sxs-lookup"><span data-stu-id="a74b9-385">Dynamic Memory Usage</span></span> 

<span data-ttu-id="a74b9-386">Daha önce belirtildiği gibi, dinamik bellek kullanımı uygulamanın doğrudan denetimi altındadır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-386">As mentioned before, dynamic memory usage is under direct control of the application.</span></span> <span data-ttu-id="a74b9-387">Tuvallerle ilişkili denetim blokları ve bellek, hedefin bellek alanı içinde herhangi bir yere yerleştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-387">Control blocks and memory associated with canvases, etc. can be placed anywhere in the target’s memory space.</span></span> <span data-ttu-id="a74b9-388">Bu önemli bir özelliktir çünkü çalışma zamanında farklı fiziksel bellek türlerinin kolay kullanımını kolaylaştırır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-388">This is an important feature because it facilitates easy utilization of different types of physical memory – at run-time.</span></span>

<span data-ttu-id="a74b9-389">Örneğin, hedef donanım ortamının hem hızlı belleğe hem de yavaş belleğe sahip olduğunu varsayalım.</span><span class="sxs-lookup"><span data-stu-id="a74b9-389">For example, suppose a target hardware environment has both fast memory and slow memory.</span></span> <span data-ttu-id="a74b9-390">Uygulamanın çizim için ek performansa ihtiyacı varsa, en iyi performans için tuval belleği açıkça yüksek hızlı bellek alanına yerleştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-390">If the application needs extra performance for drawing, the canvas memory can be explicitly placed in the high-speed memory area for best performance.</span></span>

<span data-ttu-id="a74b9-391">Çeşitli isteğe bağlı GUIX hizmetleri ve özellikleri, genellikle yığın olarak adlandırılan bir çalışma zamanı dinamik bellek ayırma mekanizması gerektirir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-391">Several optional GUIX services and features require a runtime dynamic memory allocation mechanism, commonly referred to as a heap.</span></span> <span data-ttu-id="a74b9-392">Bu hizmetler ve özellikler tamamen isteğe bağlıdır ve birçok GUIX uygulaması herhangi bir yığın kullanmaz ve çalışma zamanı bellek ayırma mekanizması tanımlamaz.</span><span class="sxs-lookup"><span data-stu-id="a74b9-392">These services and features are completely optional, and many GUIX applications do not use any heap and do not define a runtime memory allocation mechanism.</span></span>

<span data-ttu-id="a74b9-393">Çalışma zamanı bellek ayırması gerektiren hizmetleri kullanıyorsanız, bellek dinamik olarak ayrılmış veya serbest bırakıldığında GUIX'in çağıryacağı işlevleri yüklemeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-393">If you will be using services which require runtime memory allocation, you must install functions which GUIX will call when memory must be dynamically allocated or freed.</span></span> <span data-ttu-id="a74b9-394">Bu işlevleri istediğiniz gibi gerçekleştirebilirsiniz, böylece bu durumda bile dinamik bellek havuzunun konumu uygulama denetimi altında olur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-394">You can implement these functions as you prefer, so that even in this case the location of the dynamic memory pool is under application control.</span></span> <span data-ttu-id="a74b9-395">Dinamik bellek ayırma desteğini yüklemek için uygulamanın, bellek ayırma ve bellek boş ***gx_system_memory_allocator_set*** tanımlamak üzere program başlatma sırasında API hizmetini çağırarak başlatması gerekir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-395">To install support for dynamic memory allocation, the application should invoke the API service ***gx_system_memory_allocator_set*** during program startup to define your memory allocation and memory free services.</span></span> <span data-ttu-id="a74b9-396">Tam bir örnek için bu API'nin belgelerine bakın.</span><span class="sxs-lookup"><span data-stu-id="a74b9-396">Refer to the documentation of this API for a complete example.</span></span>

<span data-ttu-id="a74b9-397">Çalışma zamanı bellek ayırma ve ayırmayı geri yükleme hizmeti gerektiren GUIX hizmetleri şunlardır:</span><span class="sxs-lookup"><span data-stu-id="a74b9-397">GUIX services which require a runtime memory allocation and de-allocation service include:</span></span>

  - <span data-ttu-id="a74b9-398">Dış depolamadan GUIX çalışma zamanı ortamına ikili kaynak yükleme.</span><span class="sxs-lookup"><span data-stu-id="a74b9-398">Loading binary resources from external storage into the GUIX runtime environment.</span></span>

  - <span data-ttu-id="a74b9-399">Yazılım çalışma zamanı jpeg görüntü kod çözücü.</span><span class="sxs-lookup"><span data-stu-id="a74b9-399">The software runtime jpeg image decoder.</span></span>

  - <span data-ttu-id="a74b9-400">Yazılım çalışma zamanı png görüntü kod çözücü.</span><span class="sxs-lookup"><span data-stu-id="a74b9-400">The software runtime png image decoder.</span></span>

  - <span data-ttu-id="a74b9-401">Metin pencere öğelerini GX_STYLE_TEXT_COPY.</span><span class="sxs-lookup"><span data-stu-id="a74b9-401">Using text widgets with GX_STYLE_TEXT_COPY.</span></span>

  - <span data-ttu-id="a74b9-402">Çalışma zamanı pixemap yeniden boyutlandırma ve döndürme yardımcı programı işlevleri.</span><span class="sxs-lookup"><span data-stu-id="a74b9-402">Runtime pixemap resize and rotation utility functions.</span></span>
  - <span data-ttu-id="a74b9-403">Çalışma zamanı ekranı ve pencere öğesi denetimi blok ayırma.</span><span class="sxs-lookup"><span data-stu-id="a74b9-403">Runtime screen and widget control block allocation.</span></span>

<span data-ttu-id="a74b9-404">Daha küçük uygulamalar için GUIX kaynakları genellikle uygulama görüntüsünün bir parçası olarak derlenmiş ve statik olarak bağlantılıdır ve ikili kaynak yüklemesi gerekli değildir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-404">For smaller applications, GUIX resources are usually compiled and statically linked as part of the application image, and binary resource installation is not required.</span></span> <span data-ttu-id="a74b9-405">İkili kaynaklar, bir uygulamanın çalışma zamanında flash sürücü veya URL gibi bir depolama konumdan yüklenen kaynakları (yazı tipleri, görüntüler, diller) yüklemesine olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-405">Binary resources allow an application to install resources (fonts, images, languages) at runtime loaded from some storage location, such as a flash drive or a URL.</span></span>

<span data-ttu-id="a74b9-406">Çalışma zamanı jpeg ve png kod çözücüleri isteğe bağlı bileşenlerdir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-406">The runtime jpeg and png decoders are optional components.</span></span> <span data-ttu-id="a74b9-407">GuiX uygulamalarının çoğu GUIX Studio aracının tüm gerekli görüntü dosyalarının kodunu önceden çözmesine ve bunları özel GUIX Pixemap veri kaynakları olarak depolamasına olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-407">Most GUIX applications allow the GUIX Studio tool to pre-decode all required image files, and store them as proprietary GUIX Pixemap data resources.</span></span> <span data-ttu-id="a74b9-408">Bu hizmetler, jpeg ve/veya PNG görüntülerinin piksel haritası biçimine dönüştürmesini gerektiren uygulamalar için tamlık sağlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-408">These services are provided for completeness for those applications that require runtime conversion of jpeg and/or PNG images to pixelmap format.</span></span>

<span data-ttu-id="a74b9-409">**GX_STYLE_TEXT_COPY,** kullanıcının belirli bir pencere öğesi veya pencere öğelerinin dinamik olarak atanan metnin kendi özel kopyasını tutacaklarını belirtmesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-409">**GX_STYLE_TEXT_COPY** allows the user to specify that a particular widget or widgets will keep it’s own private copy of dynamically assigned text.</span></span> <span data-ttu-id="a74b9-410">Bu seçeneğin kullanımı, bellek ayırma mekanizmasının kullanımdan önce yüklü olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-410">Using this option requires that the memory allocation mechanism be installed prior to use.</span></span> <span data-ttu-id="a74b9-411">Metin türü pencere öğesi **<span class="underline">oluşturulduğunda</span>** bu stil bayrağı sağlanmazsa, uygulamanın dinamik olarak oluşturulan ve atanan tüm metin dizeleri için statik depolama alanları ayırması gerekir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-411">If this style flag is **<span class="underline">not</span>** provided when a text type widget is created, the application must allocate static storage areas for all dynamically created and assigned text strings.</span></span> <span data-ttu-id="a74b9-412">Bu durumda, otomatik değişkenler çalışma zamanı tarafından oluşturulan dize verilerini tutmak için kullanılmamalı.</span><span class="sxs-lookup"><span data-stu-id="a74b9-412">Automatic variables should not be used in this case to hold runtime generated string data.</span></span> <span data-ttu-id="a74b9-413">Kullanıcı **GX_STYLE_TEXT_COPY** etkinleştirilirse, her pencere öğesi atanan metnin kendi kopyasını oluşturacak olduğu için GUIX pencere öğelerine atanan dize verilerini tutmak için otomatik değişkenler kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-413">If the **GX_STYLE_TEXT_COPY** style is enabled, automatic variables may be used to hold string data assigned to GUIX widgets, since each widget will create its own copy of the assigned text.</span></span>

<span data-ttu-id="a74b9-414">Piksel haritası yeniden boyutlandırma ve döndürme yardımcı programı işlevleri, sonuçta elde edilen piksel haritasını uygulamanın kullanımına yeni bir piksel haritası olarak döndürmektedir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-414">Pixelmap resize and rotation utility functions return the resulting translated pixelmap as a new pixelmap available to the application.</span></span>
<span data-ttu-id="a74b9-415">Bu hizmetler kullanılıyorsa, çalışma zamanı tarafından oluşturulan piksel haritası veri bloklarını tutmak için yeterli dinamik bellek kullanılabilir olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-415">Sufficient dynamic memory must be available to hold these runtime generated pixelmap data blocks if these services are used.</span></span>

<span data-ttu-id="a74b9-416">Son olarak, GUIX ekranlarının ve pencere öğelerinin denetim blokları statik veya dinamik olarak ayırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a74b9-416">Finally, the control blocks for the GUIX screens and widgets can be statically or dynamically allocated.</span></span> <span data-ttu-id="a74b9-417">Daha küçük uygulamalar için, program başlatma sırasında tüm uygulama ekranları oluşturmak ve statik olarak ayrılmış denetim blokları kullanmak yaygındır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-417">For smaller applications, it is common to create all application screens during program startup and use statically allocated control blocks.</span></span> <span data-ttu-id="a74b9-418">Büyük uygulamalar için, ekran ve alt pencere öğesi denetimlerini gerektiğinde dinamik olarak oluşturmak yaygındır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-418">For large applications, it is common to create the screen and child widget controls dynamically on an as-needed bases.</span></span> <span data-ttu-id="a74b9-419">Dinamik olarak ayrılan denetim blokları  GUIX Studio özellikleri görünümünde Çalışma Zamanı Ayır onay kutusu seçerek veya standart API aracılığıyla bir pencere öğesi oluştururken stil **bayrağı GX_STYLE_DYNAMICALLY_ALLOCATED** işareti geçerek belirtilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-419">Dynamically allocated control blocks are specified by selecting the **Runtime Allocate** checkbox in the GUIX Studio properties view, or by passing in the style flag **GX_STYLE_DYNAMICALLY_ALLOCATED** when creating a widget via the standard API.</span></span> <span data-ttu-id="a74b9-420">Dinamik olarak ayrılan pencere öğesi denetim bloklarının kullanımı, bellek ayırma ve serbest ayırma hizmetlerinin yukarıda açıklandığı gibi tanımlanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-420">Using dynamically allocated widget control blocks requires that memory allocation and deallocation services are defined as described above.</span></span>

## <a name="guix-components"></a><span data-ttu-id="a74b9-421">GUIX Bileşenleri</span><span class="sxs-lookup"><span data-stu-id="a74b9-421">GUIX Components</span></span> 

<span data-ttu-id="a74b9-422">GUIX API'leri, GUIX sisteminin temel bileşenlerine karşılık gelen birkaç temel gruba ayrılır ve düzenlenmiştir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-422">The GUIX APIs are divided and organized into several basic groups which correspond to fundamental components of the GUIX system.</span></span> <span data-ttu-id="a74b9-423">Temel bileşenler şunlardır:</span><span class="sxs-lookup"><span data-stu-id="a74b9-423">The fundamental components include:</span></span>

| <span data-ttu-id="a74b9-424">Bileşenler</span><span class="sxs-lookup"><span data-stu-id="a74b9-424">Components</span></span>  | <span data-ttu-id="a74b9-425">Açıklama</span><span class="sxs-lookup"><span data-stu-id="a74b9-425">Description</span></span>  |
| ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| <span data-ttu-id="a74b9-426">GX_SYSTEM</span><span class="sxs-lookup"><span data-stu-id="a74b9-426">GX_SYSTEM</span></span>  | <span data-ttu-id="a74b9-427">Başlatmadan, olaylardan, süreerlerden, dize tablolardan ve görünür pencere öğesi hiyerarşi yönetiminden sorumlu GUIX sistem bileşeni.</span><span class="sxs-lookup"><span data-stu-id="a74b9-427">The GUIX system component, responsible for initialization, events, timers, string tables, and visible widget hierarchy management.</span></span>                                                                                                                                                                                                                                                                      |
| <span data-ttu-id="a74b9-428">GX_CANVAS</span><span class="sxs-lookup"><span data-stu-id="a74b9-428">GX_CANVAS</span></span>  | <span data-ttu-id="a74b9-429">Çizim alanı.</span><span class="sxs-lookup"><span data-stu-id="a74b9-429">A drawing area.</span></span> <span data-ttu-id="a74b9-430">Tuval, donanım çerçevesi arabelleğinin ince soyutlamaları olabileceği gibi, saf bellek tuvali de olabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-430">A Canvas can be a thin abstraction of the hardware frame buffer, or it might also be a pure memory canvas.</span></span> <span data-ttu-id="a74b9-431">Tuval türü, api işlevine geçirilen parametreler gx_canvas_create belirlenir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-431">The canvas type is determined by parameters passed to the gx_canvas_create API function.</span></span>                                                                                                                                                                                   |
| <span data-ttu-id="a74b9-432">GX_CONTEXT</span><span class="sxs-lookup"><span data-stu-id="a74b9-432">GX_CONTEXT</span></span> | <span data-ttu-id="a74b9-433">Çizim bağlamı bileşeni.</span><span class="sxs-lookup"><span data-stu-id="a74b9-433">The drawing context component.</span></span> <span data-ttu-id="a74b9-434">Çizim bağlamı, geçerli çizim işlemleri için ekran, tuval ve fırça ve kırpma alanı hakkında bilgi içerir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-434">The drawing context contains information about the screen, canvas, and brush, and clipping area for the current drawing operations.</span></span>                                                                                                                                                                                                                                      |
| <span data-ttu-id="a74b9-435">GX_DISPLAY</span><span class="sxs-lookup"><span data-stu-id="a74b9-435">GX_DISPLAY</span></span> | <span data-ttu-id="a74b9-436">Uygulama ve GUIX pencere öğelerinin tuvalde çizim gerçekleştirmesine olanak sağlayan API'ler ve sürücü düzeyinde uygulamalar sağlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-436">Provides the APIs and driver-level implementations to allow your application and the GUIX widgets to perform drawing on a canvas.</span></span> <span data-ttu-id="a74b9-437">GX_DISPLAY tuvalin gerekli renk biçimini kullanarak her tuvalde grafikleri doğru şekilde işlemek için uygulanır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-437">GX_DISPLAY is implemented to correctly render graphics on each canvas using that canvas’ required color format.</span></span> <span data-ttu-id="a74b9-438">Bu GX_DISPLAY, her bir görüntüye bağlı tuvallere çizilen pencere öğeleri için kullanılabilen kaynakları da (renkler, yazı tipleri ve piksel haritaları) yönetir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-438">The GX_DISPLAY component also manages the resources (colors, fonts, and pixelmaps) available to widgets drawing to canvases linked to each display.</span></span> |
| <span data-ttu-id="a74b9-439">GX_WIDGET</span><span class="sxs-lookup"><span data-stu-id="a74b9-439">GX_WIDGET</span></span>  | <span data-ttu-id="a74b9-440">Temel görünür pencere öğesi nesnesi ve ilişkili API'ler.</span><span class="sxs-lookup"><span data-stu-id="a74b9-440">The basic visible widget object and associated APIs.</span></span> <span data-ttu-id="a74b9-441">Tüm GUIX pencere öğesi türleri temel alınan veya türetilen temel GX_WIDGET türetilen.</span><span class="sxs-lookup"><span data-stu-id="a74b9-441">All GUIX widget types are based on or derived from the basic GX_WIDGET type.</span></span>                                                                                                                                                                                                                                                                      |
| <span data-ttu-id="a74b9-442">GX_UTILITY</span><span class="sxs-lookup"><span data-stu-id="a74b9-442">GX_UTILITY</span></span> | <span data-ttu-id="a74b9-443">Dikdörtgenlerle çalışmaya yardımcı program işlevleri, dize dönüştürme işlevleri ve ANSI olmayan matematiksel işlevler bu gruba dahil edilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-443">Utility functions for working with rectangles, functions for string conversion, and non-ANSI mathematical functions are included in this group.</span></span>                                                                                                                                                                                                                                                         |

<span data-ttu-id="a74b9-444">GuiX, bu temel bileşenlere ek olarak, kitaplıkta sağlanan her pencere öğesi türüne özgü API'ler içerir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-444">In addition to these basic components, GUIX includes APIs unique to each type of widget provided in the library.</span></span> <span data-ttu-id="a74b9-445">Bu API'ler, bu Kullanıcı Kılavuzu'nun 4. Bölümünde "GUIX Hizmetlerinin Açıklaması" bölümünde açıklanmıştır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-445">These APIs are described in Chapter 4 of this User Guide, “Description of GUIX Services”.</span></span>

## <a name="guix-system-component"></a><span data-ttu-id="a74b9-446">GUIX Sistem Bileşeni</span><span class="sxs-lookup"><span data-stu-id="a74b9-446">GUIX System Component</span></span>

<span data-ttu-id="a74b9-447">GUIX sistem bileşeni, kullanıcı arabirimi uygulamasına genel olan çeşitli hizmetler sağlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-447">The GUIX system component provides several services that are global to the UI application.</span></span> <span data-ttu-id="a74b9-448">Bu hizmetler *şunlardır: başlatma, olay yönetimi, görüntü yönetimi, kaynak yönetimi, zamanlayıcı yönetimi ve* *pencere öğesi yönetimi.*</span><span class="sxs-lookup"><span data-stu-id="a74b9-448">These services include: *initialization, event management, display management, resource management, timer management,* and *widget management*.</span></span> <span data-ttu-id="a74b9-449">Her hizmet, uygulama programınız için gereklidir ve bu hizmetler aşağıdaki alt bölümlerde daha ayrıntılı olarak açıklanmıştır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-449">Each service is essential to the organization of your application program, and these services are described in more detail in the following sub-sections.</span></span>

### <a name="initialization"></a><span data-ttu-id="a74b9-450">Başlatma</span><span class="sxs-lookup"><span data-stu-id="a74b9-450">Initialization</span></span> 

<span data-ttu-id="a74b9-451">GUIX başlatması, ***ThreadX*** tx_application_define yordamından (başlatma bağlamı) veya uygulama iş parçacıklarından uygulama tarafından çağrılmış gx_system_initialize hizmeti çağıran uygulama tarafından başarılı olur. </span><span class="sxs-lookup"><span data-stu-id="a74b9-451">GUIX initialization is accomplished by the application calling the service ***gx_system_initialize***, which may be called by the application from the ThreadX ***tx_application_define*** routine (initialization context) or from application threads.</span></span> <span data-ttu-id="a74b9-452">Gx_system_initialize  işlevi tüm genel GUIX veri yapılarını başlatarak GUIX sistem mutex, olay kuyruğu, zamanlayıcı ve iş parçacığı oluşturur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-452">The ***gx_system_initialize*** function initializes all global GUIX data structures and creates the GUIX system mutex, event queue, timer, and thread.</span></span> <span data-ttu-id="a74b9-453">Bu ***gx_system_initialize,*** uygulama GUIX kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-453">Once ***gx_system_initialize*** returns, the application can use GUIX.</span></span>

### <a name="thread-processing"></a><span data-ttu-id="a74b9-454">İş Parçacığı İşleme</span><span class="sxs-lookup"><span data-stu-id="a74b9-454">Thread Processing</span></span> 

<span data-ttu-id="a74b9-455">Başlatma sırasında oluşturulan iç GUIX iş parçacığı GUIX'te işlemenin çoğundan sorumludur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-455">The internal GUIX thread – created during initialization – is responsible for most of the processing in GUIX.</span></span> <span data-ttu-id="a74b9-456">Bu iş parçacığında işlem ilk olarak, temel alınan görüntü sürücüsü için gereken ek başlatmayı tamamlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-456">The processing in this thread first completes any additional initialization required by the underlying display driver.</span></span> <span data-ttu-id="a74b9-457">Bu işlem tamamlandıktan sonra GUIX iş parçacığı ilk olarak GUIX olay kuyruğunda mevcut olan tüm olayları işleyin ve gerekirse ekranı yeniler bir döngü girer.</span><span class="sxs-lookup"><span data-stu-id="a74b9-457">Once this is complete, the GUIX thread enters a loop which first processes all events present in the GUIX event queue and then refreshes the screen if required.</span></span> <span data-ttu-id="a74b9-458">Ekran yenileme, görünür olan ve kirli olarak işaretlenen ve yeniden çizilene göre gerekli GUIX çizim işlevlerini yürütür.</span><span class="sxs-lookup"><span data-stu-id="a74b9-458">The screen refresh executes the necessary GUIX drawing functions, based on what is visible and has been marked as dirty meaning it needs to be redrawn.</span></span> <span data-ttu-id="a74b9-459">Ekranda yenilenecek bir olay ve yenilenecek bir şey kalmadı olduğunda GUIX iş parçacığı askıya alınarak bir sonraki GUIX olayın gelmesini bekler.</span><span class="sxs-lookup"><span data-stu-id="a74b9-459">When there are no events and nothing left to refresh on the display, the GUIX thread will suspend, waiting for the next GUIX event to arrive.</span></span>

### <a name="rtos-binding"></a><span data-ttu-id="a74b9-460">RTOS Bağlama</span><span class="sxs-lookup"><span data-stu-id="a74b9-460">RTOS Binding</span></span> 

<span data-ttu-id="a74b9-461">GUIX sistem bileşeni varsayılan olarak iş parçacığı hizmetleri, olay kuyruğu hizmetleri ve zamanlayıcı hizmetleri gibi hizmetler için ThreadX gerçek zamanlı işletim sistemini kullanmak üzere yapılandırılmıştır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-461">The GUIX system component is by default configured to utilize the ThreadX real time operating system for services such as thread services, event queue services, and timer services.</span></span> <span data-ttu-id="a74b9-462">GUIX, guiX kitaplığını yeniden oluşturma ve önişlemci yönergesi GX_DISABLE_THREADX_BINDING kolayca diğer işletim sistemlerine taşınabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-462">GUIX can easily be ported to other operating systems by using the preprocessor directive GX_DISABLE_THREADX_BINDING and re-building the GUIX library.</span></span> <span data-ttu-id="a74b9-463">Bu, ThreadX bağımlılıklarını GUIX kaynak kodundan kaldırır ve uygulama geliştiricinin hedef sistem tarafından sağlanan RTOS'u kullanarak gerekli işletim sistemi hizmetlerini uygulamasına olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-463">This removes the ThreadX dependencies from the GUIX source code, and allows the application developer to implement the required operating system services using whatever RTOS is provided by the target system.</span></span> <span data-ttu-id="a74b9-464">[Ek F - GUIX RTOS Bağlama](appendix-f.md) Hizmetleri, GUIX'i ThreadX işletim sistemi dışında bir işletim sistemine bağlantı noktası olarak uygulamak için uygulanması gereken hizmetleri açıklar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-464">[Appendix F - GUIX RTOS Binding Services](appendix-f.md) describes the services that need to be implemented to port GUIX to an operating system other than the ThreadX operating system.</span></span>

### <a name="multithread-safety"></a><span data-ttu-id="a74b9-465">Çoklu İş Parçacığı Güvenliği</span><span class="sxs-lookup"><span data-stu-id="a74b9-465">Multithread Safety</span></span> 

<span data-ttu-id="a74b9-466">GUIX API'si GUIX iş parçacığı bağlamından ve diğer uygulama iş parçacıklarından kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-466">The GUIX API is available from the GUIX thread context as well as other application threads.</span></span> <span data-ttu-id="a74b9-467">Uygulama iş parçacıkları olayları göndererek ve alarak, paylaşılan değişkenlere erişerek ve GUIX API işlevlerini kullanarak GUIX iş parçacığıyla etkileşime geçebilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-467">Application threads can interact with the GUIX thread by sending and receiving events, by access to shared variables, and through use of the GUIX API functions.</span></span> <span data-ttu-id="a74b9-468">GUIX, çok iş parçacığı kaynak koruması için iç ThreadX mutex kullanır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-468">GUIX uses an internal ThreadX mutex for multi-thread resource protection.</span></span> <span data-ttu-id="a74b9-469">Ayrıca GUIX, ekran yenileme işlemi başlatıldıktan sonra görünür pencere öğelerinin iç yapısının değiştirilmesini de önler.</span><span class="sxs-lookup"><span data-stu-id="a74b9-469">In addition, GUIX prevents the internal structure of visible widgets from being modified once a screen refresh operation has begun.</span></span> <span data-ttu-id="a74b9-470">Çizim işlemleri devam ederken görünür nesnelerin ağacını değiştirebilecek API'ler engellenir ve ekran yenileme tamamlandıktan sonra yayınlanır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-470">APIs which would modify the tree of visible objects are blocked while drawing operations are in progress, and released once the screen refresh is complete.</span></span>

### <a name="system-timers"></a><span data-ttu-id="a74b9-471">Sistem Süre süreleri</span><span class="sxs-lookup"><span data-stu-id="a74b9-471">System Timers</span></span> 

<span data-ttu-id="a74b9-472">GUIX, uygulamaya genellikle GUIX pencerelerde görüntülenen verilerin düzenli güncelleştirmeleri için kullanılan düzenli aralıklarla süre veren süreerler sağlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-472">GUIX provides the application with periodic timers, which are often used for periodic update of data displayed in GUIX windows.</span></span> <span data-ttu-id="a74b9-473">Bu, ekran soldurma gibi GUIX sistem düzeyinde etkileri gerçekleştirmek için de kullanılan ThreadX düzenli aralıklarla zamanlayıcı aracılığıyla kullanılmaktadır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-473">This is accomplished via a ThreadX periodic timer, which is also used to perform GUIX system-level effects like screen fade in/out, etc.</span></span>

<span data-ttu-id="a74b9-474">Uygulama zamanlayıcılar oluşturabilir ve GUIX tarafından dahili olarak kullanılan zamanlayıcı tesisinden faydalanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a74b9-474">The application can create timers and utilize the same timer facility that is used internally by GUIX.</span></span> <span data-ttu-id="a74b9-475">Elbette uygulama, gerekirse Doğrudan ThreadX sürelerini de oluşturabilir ve kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-475">Of course the application can also directly create and use ThreadX timers if required.</span></span> <span data-ttu-id="a74b9-476">GUIX sürelerini kullanmanın avantajı, kullanımı çok kolay ve GUIX olay odaklı işleme sistemi içinde çalışmak üzere önceden yapılandırılmışlarıdır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-476">The advantage of the GUIX timers is that they are very easy to use and are pre-configured to work within the GUIX event-driven processing system.</span></span>

<span data-ttu-id="a74b9-477">Bir GUIX zamanlayıcısı oluşturmak ve başlatmak için uygulamanın işlevi ***gx_system_timer_start.***</span><span class="sxs-lookup"><span data-stu-id="a74b9-477">To create and start a GUIX timer, the application should invoke the function ***gx_system_timer_start***.</span></span> <span data-ttu-id="a74b9-478">Bu işlevin parametreleri, çağıran pencere öğesi işaretçisini, zamanlayıcı kimliğini (bir pencere öğesi birçok zamanlayıcıyı başlatmasına izin verir) ve ilk ve yeniden zaman aşımı değerlerini içerir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-478">The parameters to this function include a pointer to the calling widget, the timer id (allowing one widget to start many timers), and the initial and reschedule timeout values.</span></span> <span data-ttu-id="a74b9-479">Yeniden zamanlama zaman aşımı değeri 0 ise, zamanlayıcı yalnızca bir kez çalıştıracak ve süresi dolduktan sonra etkin zamanlayıcı listesinden kendisini silebilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-479">If the reschedule timeout value is 0, the timer will only run one time and will delete itself from the active timer list once it expires.</span></span>

<span data-ttu-id="a74b9-480">Başlatıldıktan sonra GUIX zamanlayıcısı GX_EVENT_TIMEOUT zamanlayıcı sahibine zamanlayıcı yeniden zamanlama değerine bağlı olarak bir kez veya düzenli aralıklarla olay gönderir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-480">Once started, the GUIX timer will send GX_EVENT_TIMEOUT events to the timer owner, either once or periodically depending on the timer reschedule value.</span></span> <span data-ttu-id="a74b9-481">BIR GUIX zamanlayıcısı, api işlevi çağrılarak ***gx_system_timer_stop.***</span><span class="sxs-lookup"><span data-stu-id="a74b9-481">A GUIX timer can be stopped by calling the API function ***gx_system_timer_stop***.</span></span>

### <a name="pen-speed-configuration"></a><span data-ttu-id="a74b9-482">Kalem Hızı Yapılandırması</span><span class="sxs-lookup"><span data-stu-id="a74b9-482">Pen Speed Configuration</span></span> 

<span data-ttu-id="a74b9-483">GUIX sistem bileşeni, kalem hızı izleme ile ilgili yapılandırma bilgilerini tutar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-483">The GUIX system component holds configuration information related to pen speed tracking.</span></span> <span data-ttu-id="a74b9-484">GUIX, GX_EVENT_VERTICAL_FLICK  ve **GX_EVENT_HORIZONTAL_FLICK** giriş sürücüsü tarafından oluşturulan PEN_DOWN hızına ve uzaklığına göre olayları dahili olarak oluştur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-484">GUIX internally generated **GX_EVENT_VERTICAL_FLICK** and **GX_EVENT_HORIZONTAL_FLICK** events based on the speed and distance of PEN_DOWN events generated by the touch input driver, if any.</span></span> <span data-ttu-id="a74b9-485">Uygulama, api işlevini kullanarak dahili olarak oluşturulan bu olayları tetiklemek için gereken en düşük **_mesafeyi ve gx_system_pen_configure_** yapılandırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a74b9-485">The application can configure the minimum distance and speed required to trigger these internally generated events using the **_gx_system_pen_configure_** API function.</span></span>

### <a name="screen-stack"></a><span data-ttu-id="a74b9-486">Ekran Yığını</span><span class="sxs-lookup"><span data-stu-id="a74b9-486">Screen Stack</span></span> 

<span data-ttu-id="a74b9-487">GUIX sistem bileşeni GUIX ekran yığınıyla ilgili hizmetler sağlar. Bu, uygulama tarafından çalışma zamanında hangi ekranların alınabiliyor, hangi ekranlara alınabiliyor, sanal pencere öğesi yığınını destekleyen isteğe bağlı bir işlevdir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-487">The GUIX system component provides services related to the GUIX screen stack, which is an optional functionality supporting a virtual widget stack onto which screens can be pushed, popped, and retrieved at runtime by the application.</span></span> <span data-ttu-id="a74b9-488">Ekran yığını, kullanıcının menü sisteminde çeşitli durumlara varma yolu çeşitli olduğu karmaşık menü sistemlerini yönetmek için kullanışlıdır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-488">The screen stack is useful for managing complex menu systems, wherein the route by which the user may arrive at various states in the menu system is varied.</span></span> <span data-ttu-id="a74b9-489">Menü sisteminde önceki durumuna dönmek, önce önceki ekran durumuna iterek, ardından yeni ekranı görüntüleyerek ve geçerli ekran silince yeni ekranın ekran yığınından önceki durumu görüntülemesine izin vererek kolayca yapılabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-489">Returning to the previous state in the menu system can be easily done by first pushing the previous screen state, then displaying the new screen, and allowing the new screen to pop the previous state from the screen stack when the current screen is dismissed.</span></span>

### <a name="clipboard-maintenance"></a><span data-ttu-id="a74b9-490">Pano Bakımı</span><span class="sxs-lookup"><span data-stu-id="a74b9-490">Clipboard Maintenance</span></span> 

<span data-ttu-id="a74b9-491">GUIX, çalışma zamanı yürütme sırasında metin kopyalamak ve yapıştırmak için bir pano destekler.</span><span class="sxs-lookup"><span data-stu-id="a74b9-491">GUIX supports a clipboard for copying and pasting text during runtime execution.</span></span> <span data-ttu-id="a74b9-492">Bu destek GUIX Sistemi bileşeni tarafından sağlanır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-492">This support is provided by the GUIX System component.</span></span>

### <a name="dirty-list-maintenance"></a><span data-ttu-id="a74b9-493">Kirli Liste Bakımı</span><span class="sxs-lookup"><span data-stu-id="a74b9-493">Dirty List Maintenance</span></span> 

<span data-ttu-id="a74b9-494">GUIX kirli pencere öğelerinin listesini bulundurarak, durum değişiklikleri nedeniyle görünür olan ve yeniden çizilen veya yeni görünür hale gelen pencere öğeleri anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-494">GUIX maintains a list of dirty widgets, meaning widgets that are visible and need to be redrawn due to status changes or being made newly visible.</span></span> <span data-ttu-id="a74b9-495">Bu kirli liste, GUIX'in her kullanıcı arabirimi değişikliği yapılırken tuval yenilemesi yapmak yerine kullanıcı arabirimi durumundaki tüm geçerli değişiklikleri yansıtması için bir tuval yenileme işlemi yapmalarına izin vererek çizim performansını artırır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-495">This dirty list improves drawing performance by allowing GUIX to do one canvas refresh operation to reflect all current changes to the UI status, rather than doing a canvas refresh as each UI change is made.</span></span>
<span data-ttu-id="a74b9-496">Bu kirli liste GUIX sistem bileşeni tarafından da korunur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-496">This dirty list is also maintained by the GUIX system component.</span></span>

### <a name="animation-control-block-pool"></a><span data-ttu-id="a74b9-497">Animasyon Denetimi Blok Havuzu</span><span class="sxs-lookup"><span data-stu-id="a74b9-497">Animation Control Block Pool</span></span> 

<span data-ttu-id="a74b9-498">Uygulamalar genellikle birden çok animasyon dizisini paralel olarak yürütmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-498">Applications often desire to execute multiple animation sequences, often in parallel.</span></span> <span data-ttu-id="a74b9-499">GUIX, uygulamanın ayırarak kullanabileceği bir animasyon denetim blokları havuzu sağlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-499">GUIX maintains a pool of animation control blocks from which the application can allocate and use.</span></span> <span data-ttu-id="a74b9-500">Bu, uygulamayı statik olarak bu denetim bloklarını tanımlamaya karşı serbesttir ve uygulamanın tanımy olabileceği her animasyon için benzersiz bir animasyon denetim bloğu tanımlamak yerine farklı zamanlarda yeniden kullanılmasına olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-500">This frees the application from statically defining these control blocks and allows them to be reused at different times, rather than defining a unique animation control block for every animation that the application might define.</span></span> <span data-ttu-id="a74b9-501">Animasyon denetim bloğu havuzu GUIX sistem bileşeni tarafından da korunur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-501">The animation control block pool is also maintained by the GUIX system component.</span></span>

### <a name="system-error-handling"></a><span data-ttu-id="a74b9-502">Sistem Hatası İşleme</span><span class="sxs-lookup"><span data-stu-id="a74b9-502">System Error Handling</span></span> 

<span data-ttu-id="a74b9-503">GUIX sistem hatası işleyicisi, uygulamanın API açısından daha zor olan GUIX'te iç sistem hatalarını bulma konusunda yardımcı olması için tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-503">The GUIX system error handler is intended to assist the application in finding internal system errors in GUIX that might be more difficult to determine from the API perspective.</span></span> <span data-ttu-id="a74b9-504">GUIX içinde bir sistem hatası oluştuğunda iç ***_gx_system_error_process*** çağrılır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-504">Whenever a system error occurs inside of GUIX the internal ***_gx_system_error_process*** function is called.</span></span> <span data-ttu-id="a74b9-505">Bu işlev, sağlanan hata kodunu kaydeder ve algılanan toplam sistem hatası sayısını artırır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-505">This function saves the error code provided and increments the total number of system errors detected.</span></span> <span data-ttu-id="a74b9-506">Sistem hata değişkenleri aşağıdaki gibi tanımlanır:</span><span class="sxs-lookup"><span data-stu-id="a74b9-506">The system error variables are defined as follows:</span></span>

<span data-ttu-id="a74b9-507">UINT **_gx_system_last_error;**</span><span class="sxs-lookup"><span data-stu-id="a74b9-507">UINT **_gx_system_last_error**;</span></span>

<span data-ttu-id="a74b9-508">ULONG **_gx_system_error_count;**</span><span class="sxs-lookup"><span data-stu-id="a74b9-508">ULONG **_gx_system_error_count**;</span></span>

<span data-ttu-id="a74b9-509">GUIX uygulaması garip görünüyorsa hata ayıklayıcıda hata sayısı değişkenine bakmak yararlı olur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-509">If the GUIX application is behaving strangely, it is useful to look at the error count variable in the debugger.</span></span> <span data-ttu-id="a74b9-510">Ayarlanırsa, sorunu gidermenin iyi bir yolu, _gx_system_error_process işlevinde  bir kesme noktası ayarlamak ve çağrılma zaman/nereden çağrıldılarını görmektir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-510">If it is set, a good way to troubleshoot the problem is to set a breakpoint in the ***_gx_system_error_process*** function and see when/where it is being called from.</span></span>

## <a name="guix-canvas-component"></a><span data-ttu-id="a74b9-511">GUIX Tuval Bileşeni</span><span class="sxs-lookup"><span data-stu-id="a74b9-511">GUIX Canvas Component</span></span>

<span data-ttu-id="a74b9-512">Tuval bileşeni, tuvalle ilgili tüm işlemelerden sorumludur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-512">The canvas component is responsible for all canvas related processing.</span></span> <span data-ttu-id="a74b9-513">Tuval etkili bir şekilde sanal çerçeve arabelleğidir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-513">A canvas is effectively a virtual frame buffer.</span></span> <span data-ttu-id="a74b9-514">Uygulamanın grafik çıktı üretmesi için en az bir tuval oluşturması gerekir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-514">Your application must create at least one canvas in order to produce graphical output.</span></span>
<span data-ttu-id="a74b9-515">Genellikle, sisteminiz tarafından desteklenen her fiziksel görüntü için en az bir tuval oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a74b9-515">Typically, you would create at least one canvas for each physical display supported by your system.</span></span>

<span data-ttu-id="a74b9-516">Tüm GUIX çizimleri tuvalde uzer.</span><span class="sxs-lookup"><span data-stu-id="a74b9-516">All GUIX drawing takes place on a canvas.</span></span> <span data-ttu-id="a74b9-517">Daha basit veya bellekle kısıtlanmış sistemlerde büyük olasılıkla görünür çerçeve arabelleğine doğrudan bağlanacak tek bir tuval olacaktır, ancak daha fazla belleğe ve daha gelişmiş grafik gereksinimlerine sahip sistemler birden çok tuvale ihtiyaç görebilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-517">In simpler or memory constrained systems, there will likely be only one canvas which might be directly linked to the visible frame buffer, whereas systems with more memory and more advanced graphics requirements might require multiple canvases.</span></span> <span data-ttu-id="a74b9-518">Birden çok tuvalin tek bir görüntü için kullanılabilir hale geliyor, ekran ve pencere soldurma ve soldurma etkileri gibi özelliklere olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-518">Making multiple canvases available for one display enables features such as screen and window fade-in and fade-out effects.</span></span>
<span data-ttu-id="a74b9-519">Tuvaller basit veya yönetilen iki ana türden biri olabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-519">Canvases can be one of two main types, simple or managed.</span></span>

<span data-ttu-id="a74b9-520">Basit bir tuval, uygulama tarafından kullanılan ekran dışı çizim alanıdır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-520">A simple canvas is an off-screen drawing area used by the application.</span></span>
<span data-ttu-id="a74b9-521">GUIX, basit bir tuvalle doğrudan bir şey yapmasa da uygulama, karmaşık çizimleri bir kapalı ekran arabelleğine işlemek için basit bir tuval kullanabilir ve ardından gerektiğinde görünür tuvali yenilemek için bu kapalı ekran arabelleği kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-521">GUIX does nothing directly with a simple canvas, but the application can use a simple canvas to render complex drawing to an off-screen buffer, and then use this off-screen buffer to refresh the visible canvas when needed.</span></span>

<span data-ttu-id="a74b9-522">Yönetilen tuval GUIX tarafından donanım çerçevesi arabelleği içinde otomatik olarak görüntülenir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-522">A managed canvas is automatically displayed within the hardware frame buffer by GUIX.</span></span> <span data-ttu-id="a74b9-523">Yönetilen tuval, birden çok yönetilen tuvali desteklemek için yeterli belleğe sahip olan sistemler için bileşik tuval oluşturabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-523">A managed canvas is included in building a composite canvas for those systems with enough memory to support multiple managed canvases.</span></span> <span data-ttu-id="a74b9-524">Yönetilen tuvaller GUIX tarafından yönetilen bir Z düzenine sahiptir ve görünüm kırpma tüm yönetilen tuvallerde uygulanır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-524">Managed canvases have a Z-order maintained by GUIX, and view clipping is enforced on all managed canvases.</span></span>

<span data-ttu-id="a74b9-525">Tuval, daha genel olduğu için çerçeve arabelleğinden farklıdır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-525">A canvas differs from a frame buffer in that it is more generic.</span></span> <span data-ttu-id="a74b9-526">Bellek kısıtlı sistemlerde yalnızca bir tuval olabilir ve bu tuvalin belleği görünür çerçeve arabelleği belleği olabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-526">In memory constrained systems, there may be only one canvas and the memory for this canvas might be the visible frame buffer memory.</span></span> <span data-ttu-id="a74b9-527">Ancak, daha gelişmiş grafik katmanlarını ve birden çok tuvali destekleyen daha karmaşık sistemler için, yönetilen tuvallerin her biri donanım çerçevesi arabellek belleğinden ayrı kendi bellek alanları ayrılır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-527">However, for more complex systems supporting more advanced graphical overlays and multiple canvases, the managed canvases are each allocated their own memory areas which are distinct from the hardware frame buffer memory.</span></span>
<span data-ttu-id="a74b9-528">Bu yönetilen tuvaller, çerçeve arabelleği yenileme veya geçiş işlemi sırasında görünür çerçeve arabelleğine işlenir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-528">These managed canvases are rendered into the visible frame buffer during the frame buffer refresh or toggle operation.</span></span>

<span data-ttu-id="a74b9-529">Birden çok grafik katmanını destekleyen donanımlar (örneğin, birden çok katmanlı çerçeve arabellekleri) için uygulama, gx_canvas_hardware_layer_bind API'sini kullanarak bir ***veya daha fazla tuvali donanım grafik katmanlarına*** bağ hale gx_canvas_hardware_layer_bind.</span><span class="sxs-lookup"><span data-stu-id="a74b9-529">For hardware supporting multiple graphics layers, i.e. multiple overlayed frame buffers, the application can bind one or more canvases to the hardware graphics layers using the ***gx_canvas_hardware_layer_bind*** API.</span></span> <span data-ttu-id="a74b9-530">Bu hizmet tuvale belirli bir donanım grafik katmanına bağlı olduğunu ve bağlantılı bir tuvalin tuval görünürlüğü için donanım desteğini (örneğin,</span><span class="sxs-lookup"><span data-stu-id="a74b9-530">This service informs the canvas that it is linked to a particular hardware graphics layer, and once linked this canvas will attempt to utilize hardware support for canvas visibility (i.e</span></span> <span data-ttu-id="a74b9-531">gx_canvas_show, gx_canvas_hide), tuval alfa karıştırma (gx_canvas_alpha_set ***)*** ve görüntü içindeki tuval uzaklığı ***(*** gx_canvas_offset_set ).</span><span class="sxs-lookup"><span data-stu-id="a74b9-531">gx_canvas_show, gx_canvas_hide), canvas alpha blending (i.e. ***gx_canvas_alpha_set***) and canvas offset within the display (***gx_canvas_offset_set***).</span></span>

<span data-ttu-id="a74b9-532">En basit tek tuval/tek çerçeve arabelleği kuruluşu dışında mimarilerde tuvalin boyutu uygulama tarafından belirlenir ve çerçeve arabelleğinin sabit boyutundan farklı olabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-532">For architectures other than the simplest single canvas/single frame buffer organization, the size of a canvas is determined by the application and may be different than the fixed size of a frame buffer.</span></span>
<span data-ttu-id="a74b9-533">Uygulama tarafından seçilen bir uzaklıkta da olabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-533">It may also be at an offset selected by the application.</span></span> <span data-ttu-id="a74b9-534">Z düzeni gibi diğer bilgiler tuval içinde korunur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-534">Other information, such as Z-order is maintained within the canvas.</span></span> <span data-ttu-id="a74b9-535">Tuval çizimi tamamlandığında, tuvalin içeriği görüntü sürücüsü tarafından fiziksel görüntüye aktarılır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-535">When the canvas drawing is complete, the contents of the canvas are transferred to the physical display by the display driver.</span></span> <span data-ttu-id="a74b9-536">Ayrı bir tuval ve çerçeve arabelleği bellek alanları için yeterli belleğe sahip olan bazı sistemlerde tuval güncelleştirmesi aslında görüntü sürücüsü aracılığıyla doğrudan fiziksel görüntüye yapılır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-536">In some systems that don’t have enough memory for a separate canvas and frame buffer memory areas, the canvas update is actually made directly to the physical display via the display driver.</span></span>

### <a name="canvas-creation"></a><span data-ttu-id="a74b9-537">Tuval Oluşturma</span><span class="sxs-lookup"><span data-stu-id="a74b9-537">Canvas Creation</span></span> 

<span data-ttu-id="a74b9-538">Bir tuval nesnesi başlatma sırasında veya uygulama iş parçacıklarının yürütülmesi sırasında herhangi bir zamanda oluşturulabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-538">A canvas object can be created during initialization or anytime during the execution of application threads.</span></span> <span data-ttu-id="a74b9-539">Bir uygulama tarafından oluşturulacak tuval nesnelerinin sayısına bir sınır yoktur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-539">There is no limit on the number of canvas objects that can be created by an application.</span></span> <span data-ttu-id="a74b9-540">Ancak çoğu uygulama, tüm GUIX çizimi için yalnızca bir tuval nesnesi oluşturur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-540">Most applications, however, will create only one canvas object for all GUIX drawing.</span></span>

### <a name="canvas-control-block"></a><span data-ttu-id="a74b9-541">Tuval Denetim Bloğu</span><span class="sxs-lookup"><span data-stu-id="a74b9-541">Canvas Control Block</span></span> 

<span data-ttu-id="a74b9-542">Her tuval nesnesinin özellikleri, denetim bloğu  GX_CANVAS bulunur ve **_gx_api.h içinde tanımlanır._**</span><span class="sxs-lookup"><span data-stu-id="a74b9-542">The characteristics of each canvas object are found in its control block **GX_CANVAS** and is defined in **_gx_api.h_**.</span></span> <span data-ttu-id="a74b9-543">Tuval nesnesi için gereken bellek uygulama tarafından sağlanır ve bellekte herhangi bir yerde yer alıyor olabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-543">The memory required for a canvas object is provided by the application and can be located anywhere in memory.</span></span> <span data-ttu-id="a74b9-544">Ancak, tuval nesnesi denetim bloğu ve çizim alanı, bunları herhangi bir işlevin kapsamı dışında tanımlayarak genel bir yapı haline yaygındır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-544">However, it is most common to make the canvas object control block and the drawing area a global structure by defining them outside the scope of any function.</span></span>

### <a name="canvas-alpha-channel"></a><span data-ttu-id="a74b9-545">Tuval Alfa Kanalı</span><span class="sxs-lookup"><span data-stu-id="a74b9-545">Canvas Alpha Channel</span></span>

<span data-ttu-id="a74b9-546">GUIX piksel başına karıştırma oranı belirten bit eşlem alfa kanalı, 16 bpp ve daha yüksek renk derinliğinde fırça karıştırma oranını belirten fırça alfası ve bir katman tuvali için karıştırma oranını belirten tuval alfası dahil olmak üzere birçok düzeyde ön plan ve arka plan renklerinin alfa karışımını destekler.</span><span class="sxs-lookup"><span data-stu-id="a74b9-546">GUIX supports alpha-blending of foreground and background colors on many levels, including bitmap alpha channel which specifies a blending ratio per pixel, brush alpha which specifies the blending ratio for a brush at 16 bpp and higher color depths, and canvas alpha which specifies the blending ratio for an overlay canvas.</span></span>

<span data-ttu-id="a74b9-547">Bir tuvalin alfa değeri, çerçeve arabelleği içinde görüntülenmek için bir araya bir araya getirdi birden çok tuval olduğunda kullanılır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-547">The alpha value of a canvas is used when there are multiple canvases which are composited together for display within the frame buffer.</span></span> <span data-ttu-id="a74b9-548">Tuval Z düzeni tuvalin diğer tuvallerin üzerinde olması gibi bir düzende ise tuval alfa değeri, tuvali arkalarında bulunanlarla karıştıran şekilde ayarlanmış olabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-548">If the canvas Z-order is such that a canvas is above other canvases, then the canvas alpha value can be set to blend the canvas with those that lie behind.</span></span> <span data-ttu-id="a74b9-549">Tuvalin alfa değerinin hızla değiştirilmesi, "soldurma" ekran geçişi etkileri sağlamak için kullanılır, ancak tuval alfası birçok şekilde kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-549">Rapidly modifying the alpha value of a canvas is used to provide “fade in” screen transition effects, but the canvas alpha can be used in many ways.</span></span>

<span data-ttu-id="a74b9-550">Tuval, gx_canvas_hardware_layer_bind() kullanarak bir donanım grafik katmanına bağlı ise GUIX, donanım desteğini kullanarak tuval alfa karıştırması uygulamaya çalışarak katman tuvalini karıştırmayla ilişkili yazılım ek yükünü en aza indirir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-550">If a canvas is bound to a hardware graphics layer using gx_canvas_hardware_layer_bind(), GUIX will attempt to implement canvas alpha blending utilizing hardware support, minimizing the software overhead associated with blending an overlay canvas.</span></span>

<span data-ttu-id="a74b9-551">Alfa değerleri 0 ile 255 arasında değişebilir; burada 0 değeri pikselin tamamen saydam olduğu anlamına gelir ve 0'dan büyük değerler daha az saydam tuval alfa değeri artarken tuval karıştırma için donanım yardımı sağlanıyorsa yalnızca 16 bpp ve üzerinde çalışan ekran sürücüleri için destek sağlanıyor.</span><span class="sxs-lookup"><span data-stu-id="a74b9-551">Alpha values range from 0 through 255, where a value of 0 means the pixel is fully transparent and values greater than 0 are increasing less transparent canvas alpha value can only be supported for screen drivers running at 16-bpp and higher unless hardware assistance for canvas blending is provided.</span></span>

### <a name="canvas-offset"></a><span data-ttu-id="a74b9-552">Tuval Uzaklığı</span><span class="sxs-lookup"><span data-stu-id="a74b9-552">Canvas Offset</span></span> 

<span data-ttu-id="a74b9-553">Bir tuval, api hizmetinin kullanımıyla birlikte gx_canvas_offset_set çerçeve ***arabelleği*** içinde kaydırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a74b9-553">A canvas can be offset within the visible frame buffer by invoking the ***gx_canvas_offset_set*** API service.</span></span> <span data-ttu-id="a74b9-554">Tuval uzaklıkları genellikle sprite animasyonları uygulamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-554">Canvas offsets are usually used to implement sprite animations.</span></span> <span data-ttu-id="a74b9-555">Bir tuval, ***gx_canvas_hardware_layer_bind*** API işlevinin çağrısıyla bir donanım grafik katmanına bağlı ise GUIX, donanım desteğini kullanarak tuval uzaklığı değişikliklerini uygulamaya çalışarak tuval konumunu kaydırmayla ilişkili yazılım ek yükünü en aza indirir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-555">If a canvas is bound to a hardware graphics layer by invoking the ***gx_canvas_hardware_layer_bind*** API function, GUIX will attempt to implement canvas offset changes utilizing hardware support, minimizing the software overhead associated with shifting the canvas position.</span></span>

### <a name="canvas-drawing"></a><span data-ttu-id="a74b9-556">Tuval Çizimi</span><span class="sxs-lookup"><span data-stu-id="a74b9-556">Canvas Drawing</span></span> 

<span data-ttu-id="a74b9-557">GUIX tuval bileşeni, uygulamaya tam bir çizim API'si sağlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-557">The GUIX canvas component provides a full drawing API to the application.</span></span> <span data-ttu-id="a74b9-558">Gx_canvas_line_draw veya ***gx_canvas_pixelmap_draw*** gibi çizim ***API'leri*** çağrılmadan önce, gx_canvas_drawing_initiate API işlevi çağrılarak hedef ***tuvalin çizim için açılması*** gerekir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-558">Before the drawing APIs such as ***gx_canvas_line_draw*** or ***gx_canvas_pixelmap_draw*** can be invoked, the target canvas must be opened for drawing by invoking the ***gx_canvas_drawing_initiate*** API function.</span></span> <span data-ttu-id="a74b9-559">Bu işlev, tuvali çizim için hazırlar ve bir çizim ***bağlamı oluşturur.***</span><span class="sxs-lookup"><span data-stu-id="a74b9-559">This function prepares a canvas for drawing and creates a ***drawing context***.</span></span>

<span data-ttu-id="a74b9-560">***gx_canvas_line_draw** _ veya _*_gx_canvas_text_draw_\*_ gibi tuvale işleme alan çizim API'leri, çizgi stilini, genişliğini ve renklerini tanımlamak için geçerli çizim bağlam fırçasında bulunan parametreleri kullanır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-560">The drawing APIs that render to the canvas, such as ***gx_canvas_line_draw** _ or _*_gx_canvas_text_draw_\*_, use parameters found in the current drawing context brush to define the line style, width, and colors.</span></span> <span data-ttu-id="a74b9-561">Bu fırça parametreleri , _*__* gx_context_brush_define_*_ _* **, \* _gx_context_brush_set_**gx_context_brush_style_set\**_ ve benzer API işlevleri çağrılarak _* gx_canvas_drawing_initiate \*\*_çağrılarak değiştirilir._</span><span class="sxs-lookup"><span data-stu-id="a74b9-561">These brush parameters are modified by calling the _*_gx_context_brush_define_*_, _\*_gx_context_brush_set_\*\*, \***gx_context_brush_style_set**_, and similar API functions after a drawing context has been established by calling _\*_gx_canvas_drawing_initiate_\*\*.</span></span>

<span data-ttu-id="a74b9-562">GUIX, pencere ve pencere öğesi çizme işlevlerini ertelenen tuval yenileme işlemi kapsamında çağırsa, hedef tuval pencere öğesi çizim işlevlerini çağırmadan önce çizim için açılır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-562">When GUIX invokes the window and widget drawing functions as part of a deferred canvas refresh operation, the target canvas is opened for drawing prior to calling the widget drawing function(s).</span></span> <span data-ttu-id="a74b9-563">Bu nedenle, hedef tuvali açmak için standart pencere öğesi çizim işlevleri gerekli değildir, bunlar için bu yapıldı.</span><span class="sxs-lookup"><span data-stu-id="a74b9-563">Therefore the standard widget drawing functions are not required to open the target canvas, this has been done for them.</span></span>

<span data-ttu-id="a74b9-564">Bazı durumlarda uygulama, tuvale hemen çizim yapmak istiyor olabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-564">In some cases the application may want to force immediate drawing to a canvas.</span></span> <span data-ttu-id="a74b9-565">Bu durumda, uygulama aşağıdaki adımları gerçekleştirebilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-565">In this case, the application can perform the following steps.</span></span>

1. <span data-ttu-id="a74b9-566">Uygulamanın ***gx_canvas_drawing_initiate*** istediği tuvalin içindeki hedef tuvali ve dikdörtgeni geçerek gx_canvas_drawing_initiate API işlevini çağırma.</span><span class="sxs-lookup"><span data-stu-id="a74b9-566">Call the ***gx_canvas_drawing_initiate*** API function, passing in the target canvas and rectangle within that canvas on which the application wants to draw.</span></span> 

2. <span data-ttu-id="a74b9-567">İstenen çizimi gerçekleştirmek için istediğiniz sayıda tuval çizimi API'lerini çağırma.</span><span class="sxs-lookup"><span data-stu-id="a74b9-567">Call any number of canvas drawing APIs to accomplish the desired drawing.</span></span>

3. <span data-ttu-id="a74b9-568">Çizimin ***gx_canvas_drawing_complete*** için api işlevini çağırma.</span><span class="sxs-lookup"><span data-stu-id="a74b9-568">Call the ***gx_canvas_drawing_complete*** API function to signal that drawing has been completed.</span></span> <span data-ttu-id="a74b9-569">Bu işlem tuvali görünür çerçeve arabelleğine boşaltır ve/veya sistem belleği mimarisine bağlı olarak bir arabelleğe geçiş işlemi tetikler.</span><span class="sxs-lookup"><span data-stu-id="a74b9-569">This flushes the canvas to the visible frame buffer and/or triggers a buffer toggle operation, depending on the system memory architecture.</span></span>

### <a name="drawing-apis"></a><span data-ttu-id="a74b9-570">Çizim API'leri</span><span class="sxs-lookup"><span data-stu-id="a74b9-570">Drawing APIs</span></span> 

<span data-ttu-id="a74b9-571">GUIX'in ekranda tüm görsel öğeleri çizmesi için gereken birkaç temel çizim temel öğeleri vardır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-571">There are several principal drawing primitives that are required by GUIX to draw all the visual elements on the screen.</span></span> <span data-ttu-id="a74b9-572">Bu çizim API'leri genellikle bir özel pencere öğesi çizim işlevinin parçası olarak uygulama yazılımı tarafından da çağrılabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-572">These drawing APIs can also be invoked by application software, usually as part of a custom widget drawing function.</span></span> <span data-ttu-id="a74b9-573">Bu GUIX tuval çizim API'leri parametre doğrulama ve kırpma işlemi gerçekleştirerek kırpılmış çizim koordinatlarını donanım ve renk biçimine özgü çizim uygulamaları için görüntü sürücüsüne iletir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-573">These GUIX canvas drawing APIs perform parameter validation and clipping, and then pass the clipped drawing coordinates down to the display driver for hardware and color-format specific drawing implementations.</span></span> <span data-ttu-id="a74b9-574">Bu çizim API'si işlevleri aşağıdaki gibi tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-574">These drawing API functions are defined as follows.</span></span>

- <span data-ttu-id="a74b9-575">gx_canvas_alpha_set</span><span class="sxs-lookup"><span data-stu-id="a74b9-575">gx_canvas_alpha_set</span></span>
- <span data-ttu-id="a74b9-576">gx_canvas_arc_draw</span><span class="sxs-lookup"><span data-stu-id="a74b9-576">gx_canvas_arc_draw</span></span>
- <span data-ttu-id="a74b9-577">gx_canvas_block_move</span><span class="sxs-lookup"><span data-stu-id="a74b9-577">gx_canvas_block_move</span></span>
- <span data-ttu-id="a74b9-578">gx_canvas_circle_draw</span><span class="sxs-lookup"><span data-stu-id="a74b9-578">gx_canvas_circle_draw</span></span>
- <span data-ttu-id="a74b9-579">gx_canvas_ellipse_draw</span><span class="sxs-lookup"><span data-stu-id="a74b9-579">gx_canvas_ellipse_draw</span></span>
- <span data-ttu-id="a74b9-580">gx_canvas_glyphs_draw</span><span class="sxs-lookup"><span data-stu-id="a74b9-580">gx_canvas_glyphs_draw</span></span>
- <span data-ttu-id="a74b9-581">gx_canvas_hardware_layer_bind</span><span class="sxs-lookup"><span data-stu-id="a74b9-581">gx_canvas_hardware_layer_bind</span></span>
- <span data-ttu-id="a74b9-582">gx_canvas_hide</span><span class="sxs-lookup"><span data-stu-id="a74b9-582">gx_canvas_hide</span></span>
- <span data-ttu-id="a74b9-583">gx_canvas_line_draw</span><span class="sxs-lookup"><span data-stu-id="a74b9-583">gx_canvas_line_draw</span></span>
- <span data-ttu-id="a74b9-584">gx_canvas_offset_set</span><span class="sxs-lookup"><span data-stu-id="a74b9-584">gx_canvas_offset_set</span></span>
- <span data-ttu-id="a74b9-585">gx_canvas_pie_draw</span><span class="sxs-lookup"><span data-stu-id="a74b9-585">gx_canvas_pie_draw</span></span>
- <span data-ttu-id="a74b9-586">gx_canvas_pixel_draw</span><span class="sxs-lookup"><span data-stu-id="a74b9-586">gx_canvas_pixel_draw</span></span>
- <span data-ttu-id="a74b9-587">gx_canvas_pixelmap_blend</span><span class="sxs-lookup"><span data-stu-id="a74b9-587">gx_canvas_pixelmap_blend</span></span>
- <span data-ttu-id="a74b9-588">gx_canvas_pixelmap_rotate</span><span class="sxs-lookup"><span data-stu-id="a74b9-588">gx_canvas_pixelmap_rotate</span></span>
- <span data-ttu-id="a74b9-589">gx_canvas_pixelmap_tile</span><span class="sxs-lookup"><span data-stu-id="a74b9-589">gx_canvas_pixelmap_tile</span></span>
- <span data-ttu-id="a74b9-590">gx_canvas_polygon_draw</span><span class="sxs-lookup"><span data-stu-id="a74b9-590">gx_canvas_polygon_draw</span></span>
- <span data-ttu-id="a74b9-591">gx_canvas_rectangle_draw</span><span class="sxs-lookup"><span data-stu-id="a74b9-591">gx_canvas_rectangle_draw</span></span>
- <span data-ttu-id="a74b9-592">gx_canvas_rotated_text_draw</span><span class="sxs-lookup"><span data-stu-id="a74b9-592">gx_canvas_rotated_text_draw</span></span>
- <span data-ttu-id="a74b9-593">gx_canvas_shift</span><span class="sxs-lookup"><span data-stu-id="a74b9-593">gx_canvas_shift</span></span>
- <span data-ttu-id="a74b9-594">gx_canvas_show</span><span class="sxs-lookup"><span data-stu-id="a74b9-594">gx_canvas_show</span></span>
- <span data-ttu-id="a74b9-595">gx_canvas_text_draw</span><span class="sxs-lookup"><span data-stu-id="a74b9-595">gx_canvas_text_draw</span></span>

<span data-ttu-id="a74b9-596">Çizim API'si GUIX Tuval API'si aracılığıyla çağrılır ve tüm çizim gx_canvas_\* API işlevleri kullanılarak yapılır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-596">The drawing API is invoked via the GUIX Canvas API, and all drawing is done using gx_canvas_\* API functions.</span></span> <span data-ttu-id="a74b9-597">Çizim, geçerli çizim bağlamında geçerli fırça kullanılarak yapılır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-597">Drawing is done using the current brush in the current drawing context.</span></span> <span data-ttu-id="a74b9-598">Yukarıdaki şekil çizimi işlevlerden herhangi biri, geçerli fırça tarafından tanımlandığı gibi düz renk dolgulu veya piksel haritası ile doldurulan ana hatlarıyla özet olabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-598">Any of the shape drawing functions above can be outlined, solid color filled, or pixelmap filled as defined by the current brush.</span></span> <span data-ttu-id="a74b9-599">Şekil ana hat genişliğini, rengini veya dolguyu değiştirmek için gx_context_brush_\* API işlevlerini kullanarak fırçayı geçerli çizim bağlamında tanımlayın.</span><span class="sxs-lookup"><span data-stu-id="a74b9-599">To modify the shape outline width, color, or fill, use the gx_context_brush_\* API functions to define the brush within the current drawing context.</span></span>

<span data-ttu-id="a74b9-600">Yukarıdaki uygulama düzeyi çizim API'leri tuvale gerçek çizim yapmaz, bunun yerine görüntü sürücüsü düzeyinde çizim işlevini çağıranın parametrelerini doğrular.</span><span class="sxs-lookup"><span data-stu-id="a74b9-600">The above application level drawing APIs don’t do actual drawing to the canvas, but instead verify the caller’s parameters before invoking the display driver level drawing function.</span></span> <span data-ttu-id="a74b9-601">Sürücü düzeyinde çizim işlevi aslında piksel verilerini tuval belleğine yazar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-601">The driver level drawing function actually writes pixel data into the canvas memory.</span></span>

<span data-ttu-id="a74b9-602">GUIX, piksel başına 1, 2, 4, 8, 16, 24 ve 32 bit (bpp) dahil olmak üzere çeşitli renk derinlikleri için stok veya genel görüntü sürücüsü çizimi işlevleri sağlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-602">GUIX provides stock or generic display driver drawing functions for various color depths, including 1, 2, 4, 8, 16, 24, and 32 bits per pixel (bpp).</span></span> <span data-ttu-id="a74b9-603">Bazı durumlarda, varsayılan yazılım çizim uygulaması, 2D çizim hızlandırıcısı sağlayan donanım hedefleri için donanım hızlandırmalı uygulamalarla değiştirilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-603">In some cases, the default software drawing implementation is replaced by hardware-accelerated implementations for those hardware targets that provide a 2D drawing accelerator.</span></span>

### <a name="color-depth"></a><span data-ttu-id="a74b9-604">Renk Derinliği</span><span class="sxs-lookup"><span data-stu-id="a74b9-604">Color Depth</span></span> 

<span data-ttu-id="a74b9-605">GUIX, 32 bpp'ye kadar renk derinliğinin yanı sıra tek renkli ve gri tonlamayı destekler.</span><span class="sxs-lookup"><span data-stu-id="a74b9-605">GUIX supports color depths up to 32-bpp as well as monochrome and grayscale.</span></span> <span data-ttu-id="a74b9-606">Renk derinliği desteğinin türü, temel alınan fiziksel ekranın özellikleri tarafından büyük ölçüde belirlenir ve tuval çizim alanı için ne kadar bellek gerekli olduğu üzerinde de bir etkisi vardır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-606">The type of color depth support largely determined by the capabilities of the underlying physical display and also has an impact on how much memory is required for the canvas drawing area.</span></span> <span data-ttu-id="a74b9-607">Aşağıda renk derinliği desteğinin bir listesi ve bu renk derinliği içindeki varyasyonların kısa bir açıklaması ve yer almaktadır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-607">The following is a list of color depth support along with a brief description of the variations within that color depth.</span></span>

| <span data-ttu-id="a74b9-608">Renk &nbsp; Biçimi</span><span class="sxs-lookup"><span data-stu-id="a74b9-608">Color&nbsp;Format</span></span>       | <span data-ttu-id="a74b9-609">Açıklama</span><span class="sxs-lookup"><span data-stu-id="a74b9-609">Description</span></span>                                                                                                   |
| ------------------ | -------------------------------------------------------------------------------------------------------------------------------- |
| <span data-ttu-id="a74b9-610">1 bitlik tek renkli</span><span class="sxs-lookup"><span data-stu-id="a74b9-610">1-bit monochrome</span></span>   | <span data-ttu-id="a74b9-611">Piksel paketli biçim başına 1 bit.</span><span class="sxs-lookup"><span data-stu-id="a74b9-611">1-bit per pixel packed format.</span></span>                                                                                                   |
| <span data-ttu-id="a74b9-612">2 bit gri tonlamalı</span><span class="sxs-lookup"><span data-stu-id="a74b9-612">2-bit grayscale</span></span>    | <span data-ttu-id="a74b9-613">4 gri düzey, her bir bayta dört piksel paketlenir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-613">4 gray levels, packed four pixels per byte.</span></span>                                                                                      |
| <span data-ttu-id="a74b9-614">4 bit gri tonlamalı</span><span class="sxs-lookup"><span data-stu-id="a74b9-614">4-bit grayscale</span></span>    | <span data-ttu-id="a74b9-615">16 gri düzey, her bir bayta iki piksel paketlenir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-615">16 gray levels, packed two pixels per byte.</span></span>                                                                                      |
| <span data-ttu-id="a74b9-616">4 bit renk</span><span class="sxs-lookup"><span data-stu-id="a74b9-616">4-bit color</span></span>        | <span data-ttu-id="a74b9-617">VGA biçimli planar bellek kuruluşu.</span><span class="sxs-lookup"><span data-stu-id="a74b9-617">A VGA format planar memory organization.</span></span>                                                                                         |
| <span data-ttu-id="a74b9-618">8 bit gri tonlamalı</span><span class="sxs-lookup"><span data-stu-id="a74b9-618">8-bit grayscale</span></span>    | <span data-ttu-id="a74b9-619">256 gri düzey</span><span class="sxs-lookup"><span data-stu-id="a74b9-619">256 gray levels</span></span>                                                                                                                  |
| <span data-ttu-id="a74b9-620">8 bit palet modu</span><span class="sxs-lookup"><span data-stu-id="a74b9-620">8-bit palette mode</span></span> | <span data-ttu-id="a74b9-621">Palet dizini olarak kullanılan piksel başına 1 byte</span><span class="sxs-lookup"><span data-stu-id="a74b9-621">1 byte per pixel used as palette index</span></span>                                                                                           |
| <span data-ttu-id="a74b9-622">8 bit r:g:b modu</span><span class="sxs-lookup"><span data-stu-id="a74b9-622">8-bit r:g:b mode</span></span>   | <span data-ttu-id="a74b9-623">Daha az yaygın olarak kullanılan 2:3:2 r:g:b biçimi.</span><span class="sxs-lookup"><span data-stu-id="a74b9-623">A less commonly used 2:3:2 r:g:b format.</span></span>                                                                                         |
| <span data-ttu-id="a74b9-624">16 bit</span><span class="sxs-lookup"><span data-stu-id="a74b9-624">16-bit</span></span>             | <span data-ttu-id="a74b9-625">Her piksel için iki bayt gerekir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-625">Each pixel requires two bytes.</span></span> <span data-ttu-id="a74b9-626">r:g:b veya b:g:r byte sırası olabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-626">Can be r:g:b or b:g:r byte order.</span></span> <span data-ttu-id="a74b9-627">Normalde 5:6:5 yapısı, ancak 5:5:5 yapısı veya 4:4:4:4 a:r:g:b yapısı da olabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-627">Normally 5:6:5 structure, but can also be 5:5:5 structure or 4:4:4:4 a:r:g:b structure.</span></span> |
| <span data-ttu-id="a74b9-628">24 bit</span><span class="sxs-lookup"><span data-stu-id="a74b9-628">24-bit</span></span>             | <span data-ttu-id="a74b9-629">Her piksel için 3 (paketlenmiş biçim) veya 4 (paketsiz biçim) bayt gerekir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-629">Each pixel requires 3 (packed format) or 4 (unpacked format) bytes.</span></span> <span data-ttu-id="a74b9-630">Donanım için gereken r:g:b veya b:g:r byte sırasına göre olabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-630">Can be in r:g:b or b:g:r byte order as required by hardware.</span></span> |
| <span data-ttu-id="a74b9-631">32 bit</span><span class="sxs-lookup"><span data-stu-id="a74b9-631">32-bit</span></span>             | <span data-ttu-id="a74b9-632">Her piksel için alfa kanalıyla 4 bayt gerekir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-632">Each pixel requires 4 bytes with an alpha channel.</span></span> <span data-ttu-id="a74b9-633">a:r:g:b veya b:g:r:a byte sırası olabilir ve donanıma göre belirlenir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-633">Can be a:r:g:b or b:g:r:a byte order and determined by hardware.</span></span>              |

### <a name="mouse-support"></a><span data-ttu-id="a74b9-634">Fare Desteği</span><span class="sxs-lookup"><span data-stu-id="a74b9-634">Mouse Support</span></span> 

<span data-ttu-id="a74b9-635">GUIX, istenen herhangi bir tuvale fare imleci çizmeyi destekler.</span><span class="sxs-lookup"><span data-stu-id="a74b9-635">GUIX supports drawing a mouse cursor on any desired canvas.</span></span> <span data-ttu-id="a74b9-636">Fare imleci yazılımda çizili olabilir veya donanım imleç katmanlarında destek olabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-636">The mouse cursor can be drawing in software or might be supported by hardware cursor overlay.</span></span> <span data-ttu-id="a74b9-637">Her iki durumda da, yazılım veya donanım fare imleç çizimi kullansanız da, uygulamaya fare imleç desteğiyle ilgili olarak sağlanan API aynıdır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-637">In either case, the API provided to the application related to mouse cursor support is the same whether using software or hardware mouse cursor drawing.</span></span>

<span data-ttu-id="a74b9-638">GUIX fare desteği yalnızca `#define GX_MOUSE_SUPPORT` GUIX kitaplığını oluşturmadan önce gx_user.h üst bilgi dosyasında tanımlandığı zaman etkinleştirilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-638">GUIX mouse support is only enabled if the `#define GX_MOUSE_SUPPORT` is defined in the gx_user.h header file before building the GUIX library.</span></span>

<span data-ttu-id="a74b9-639">Uygulama, api işlevini kullanarak fare imlecini ve etkin ***gx_canvas_mouse_define*** tanımlamalı.</span><span class="sxs-lookup"><span data-stu-id="a74b9-639">The application must define the mouse cursor and hotspot using the ***gx_canvas_mouse_define*** API function.</span></span> <span data-ttu-id="a74b9-640">Bu API, imleç görüntüsünün çizilecek tuval işaretçisini ve **fare** imleci görüntüsünü ve fare görüntüsünün etkin noktasını tanımlayan GX_MOUSE_CURSOR_INFO yapısının işaretçisini sol üst köşedeki görüntüye göre tanımlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-640">This API accepts a pointer to the canvas on which the cursor image should be drawn, and a pointer to a **GX_MOUSE_CURSOR_INFO** structure, which defines the mouse cursor image and hotspot of the mouse image relative the image top-left corner.</span></span>

## <a name="guix-display-component"></a><span data-ttu-id="a74b9-641">GUIX Görüntüleme Bileşeni</span><span class="sxs-lookup"><span data-stu-id="a74b9-641">GUIX Display Component</span></span> 

<span data-ttu-id="a74b9-642">Görüntüleme bileşeni GUIX'te temeldir çünkü kendi içinde bir veya daha fazla tuval, pencere öğesi ve pencere içeren tüm görüntüleme nesnelerinin işlemesini yönetir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-642">The display component is fundamental in GUIX, since it manages the processing of all display objects, which in themselves contain one or more canvases, widgets, and windows.</span></span> <span data-ttu-id="a74b9-643">Görüntüleme bileşeni ayrıca bir dizi işlev işaretçisi aracılığıyla her bir ekranla ilişkili temel donanım ekran sürücüsüyle etkileşime geçmektedir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-643">The display component also interacts with the underlying hardware screen driver associated with each display through a series of function pointers.</span></span>

### <a name="display-creation"></a><span data-ttu-id="a74b9-644">Görüntü Oluşturma</span><span class="sxs-lookup"><span data-stu-id="a74b9-644">Display Creation</span></span> 

<span data-ttu-id="a74b9-645">Başlatma sırasında veya uygulama iş parçacıklarının yürütülmesi sırasında herhangi bir zamanda bir görüntüleme nesnesi oluşturulabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-645">A display object can be created during initialization or anytime during the execution of application threads.</span></span> <span data-ttu-id="a74b9-646">Genellikle bir uygulama, her fiziksel ekranı yönetmek için bir görüntüleme nesnesi oluşturur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-646">Typically an application creates one display object to manage each physical screen.</span></span> <span data-ttu-id="a74b9-647">Uygulama ve kullanılabilir fiziksel ekranları tanımlamak için GUIX Studio kullandıysanız, ekranlarınızı oluşturmak ve başlatmak için gx_studio_display_configure API işlevini kullanırsınız.</span><span class="sxs-lookup"><span data-stu-id="a74b9-647">If you have used GUIX Studio to define your application and the physical displays available, you will use the gx_studio_display_configure API function to create and initialize each of your displays.</span></span>

### <a name="display-control-block"></a><span data-ttu-id="a74b9-648">Denetim Bloğu görüntüleme</span><span class="sxs-lookup"><span data-stu-id="a74b9-648">Display Control Block</span></span> 

<span data-ttu-id="a74b9-649">Her görüntüleme nesnesinin özellikleri \*\*\*\*\* GX_DISPLAY _ denetim bloğunda bulunur ve _\*_gx_api.h \*\* içinde_ tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-649">The characteristics of each display object are found in its control block ***GX_DISPLAY** _ and are defined in _*_gx_api.h_\*\*.</span></span> <span data-ttu-id="a74b9-650">Görüntüleme nesnesi için gereken bellek uygulama tarafından sağlanır ve bellekte herhangi bir yerde yer alıyor olabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-650">The memory required for a display object is provided by the application and can be located anywhere in memory.</span></span> <span data-ttu-id="a74b9-651">Ancak, en yaygın olarak herhangi bir işlevin kapsamı dışında tanımlayarak görüntüleme denetimi bloğu genel bir yapı yapmaktır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-651">However, it is most common to make the display control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="resource-management"></a><span data-ttu-id="a74b9-652">Kaynak Yönetimi</span><span class="sxs-lookup"><span data-stu-id="a74b9-652">Resource Management</span></span> 

<span data-ttu-id="a74b9-653">Kaynaklar, uygulamanın ihtiyaç kaynağı olan kullanıcı arabirimi bileşenleridir ancak uygulama kodu değildir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-653">Resources are UI components that are needed by the application, but they are not application code.</span></span> <span data-ttu-id="a74b9-654">Kaynaklar uygulama verileridir ve genellikle statik olarak tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-654">Resources are application data and are usually statically defined.</span></span> <span data-ttu-id="a74b9-655">Kaynak türleri piksel haritalarını, yazı tiplerini, renkleri ve dizeleri içerir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-655">Resource types include pixelmaps, fonts, colors, and strings.</span></span> <span data-ttu-id="a74b9-656">Bu kaynaklar genellikle herhangi bir uygulama yazılımı değiştirmeden herhangi bir zamanda değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-656">These resources can be changed at any time, usually without changing any application software.</span></span> <span data-ttu-id="a74b9-657">Uygulama yazılımında yapılan değişiklikler genellikle ilgili yeniden test ve doğrulamayı gerektirse de uygulama kodunda değişiklik yapmadan kullanıcı arabirimi görünümünün değiştirilmesine izin vermek için, ve başvurularının depolama alanını uygulama yazılımından ayrı tutmak önemlidir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-657">It is important to keep the storage of and references to resources separated from the application software to allow changing UI appearance without changing application code since changes to the application software usually require the associated re-testing and verification of that software.</span></span>

<span data-ttu-id="a74b9-658">GUIX ***görüntüleme*** modülü, ekranın renk derinliğine ve biçimine bağlı olan tüm kaynaklar için kaynak yönetimi olanakları sağlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-658">The GUIX ***display*** module provides resource management facilities for all resources that are dependent on the color depth and format of the display.</span></span> <span data-ttu-id="a74b9-659">Bu özellikler arasında etkin piksel haritası tablosu, etkin yazı tipi tablosu ve etkin renk tablosu bakımı yer alır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-659">These facilities include maintaining the active pixelmap table, active font table, and active color table.</span></span> <span data-ttu-id="a74b9-660">Dize tablosu kaynağı GUIX sistem modülü tarafından korunur, çünkü dize kaynaklarının normalde renk derinliğine ve biçimine göre değişmesi gerekli değildir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-660">The string table resource is maintained by the GUIX system module, since string resources do not normally need to be changed based on color depth and format.</span></span>

<span data-ttu-id="a74b9-661">Uygulama yazılımı kaynaklara kaynak kimliğine göre başvurur ve bu da karşılık gelen kaynak tablosuna bir dizindir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-661">The application software references resources by their resource Id, which is an index into the corresponding resource table.</span></span> <span data-ttu-id="a74b9-662">Bu, tabloyu değiştirmeye olanak sağlar. Örneğin, bir ürün "gün modundan" "gece moduna" değişse de renk kimliği değerleri aynı kalacaksa renk tablosu değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-662">This allows the table to be changed, for example the color table might be changed when a product changes from “day mode” to “night mode”, but the color ID values to remain the same.</span></span>

<span data-ttu-id="a74b9-663">Uygulama kaynaklarınız GUIX Studio uygulaması tarafından bir kaynak dosyasına (veya kaynak dosyaları kümesine) yazılır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-663">Your application resources are written to a resource file (or set of resource files) by the GUIX Studio application.</span></span> <span data-ttu-id="a74b9-664">Varsayılan renkler, piksel haritaları ve yazı tipleri yeni bir GUIX Studio projesi oluşturma sırasında otomatik olarak sağlanır, ancak bu varsayılanlar, uygulamanın görünüm ve görünümlerini tanımladığınız şekilde kolayca değiştirilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-664">Default colors, pixelmaps, and fonts are provided automatically when you create a new GUIX Studio project, but these defaults are easily replaced as you define the look and feel of your application.</span></span>

<span data-ttu-id="a74b9-665">Renklerin, yazı tiplerinin ve piksel haritalarının Kaynak Kimliklerinin etkin Görüntüleme bileşeni bilinene kadar gerçek renk, yazı tipi veya piksel haritası değerlerine çözümlenemediklerine dikkat edin.</span><span class="sxs-lookup"><span data-stu-id="a74b9-665">It is important to note that Resource IDs for colors, fonts, and pixelmaps cannot be resolved to their actual color, font, or pixelmap values until the active Display component is known.</span></span> <span data-ttu-id="a74b9-666">GUIX mimarisi birden çok etkin ekranı desteklediği için, Kaynak Kimlikleri yalnızca bir pencere öğesi ve ilişkili Kaynak Kimliği belirli bir görüntüye çözümlenemezse kaynak değerlerine çözümlenir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-666">Since the GUIX architecture supports multiple active displays, Resource IDs can only be resolved to resource values when a widget and its associated Resource ID can be resolved to a specific display.</span></span> <span data-ttu-id="a74b9-667">Bu özellik dinamik bağlama olarak bilinir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-667">This property is known as dynamic binding.</span></span> <span data-ttu-id="a74b9-668">Metin rengi gibi bir özelliğin Kaynak Kimliği (örneğin, kaynak kimliği **GX_COLOR_ID_TEXT) bir** görüntüde kullanılırken beyaz için 16 bit R:G:B değerine çözümleniyor olabilir, ancak aynı renk kimliği başka bir görüntüde kullanılırken siyah renkli bir siyah renkli değere çözümleniyor olabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-668">The Resource ID for a property such as a text color, for example the resource ID **GX_COLOR_ID_TEXT,** might resolve to a 16-bit R:G:B value for white when used on one display, but the same color ID might resolve to a monochrome black color value when used on another display.</span></span>

<span data-ttu-id="a74b9-669">Uygulamada, Kaynak kimliklerinin kaynak değerlerine dinamik olarak bağlanması, uygulama yazılımı ve GUIX iç bileşenlerinin genellikle kaynak kimliklerini yalnızca etkin çizim bağlamındaki kaynak değerlerine çözümlemesi gerektiği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-669">In practice this dynamic binding of Resources IDs to resource values means that application software and GUIX internal components should most often only resolve Resource IDs to resource values within an active drawing context.</span></span> <span data-ttu-id="a74b9-670">Etkin çizim bağlamı, GUIX'in her Kaynak Kimliğini belirli bir kaynak değerine çözümlemesini sağlayan o anda etkin olan ekranı belirtir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-670">An active drawing context specifies the currently active display, which allows GUIX to resolve each Resource ID to a specific resource value.</span></span> <span data-ttu-id="a74b9-671">Uygulama yazılımının çizim bağlamı dışında belirli bir kaynak değerini bulmak için gerekli olması, görünür pencere öğeleri için de yapılabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-671">If the application software is required to find a specific resource value outside of a drawing context, this can also be done for visible widgets.</span></span> <span data-ttu-id="a74b9-672">Görünür pencere öğeleri, etkin tuvali çözümlemek ve bu pencere öğesi için görüntülemek için de kullanılabilir bir kök pencere penceresine bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-672">Visible widgets are linked to a root window which can also be used to resolve the active canvas and display for that widget.</span></span>

<span data-ttu-id="a74b9-673">Bir pencere öğesi oluşturulmuş ancak henüz görüntülenmemişse (başka bir kök pencereye veya diğer görünür üst öğeye bağlı değil), pencere öğesiyle ilişkili tüm kaynak kimlikleri doğrudan belirli bir görüntüye atanan kaynak tablosuna dizin oluşturma dışında belirli bir kaynak değerine çözümlenemiyor.</span><span class="sxs-lookup"><span data-stu-id="a74b9-673">If a widget has been created but not yet displayed (i.e., has not been linked to any root window or other visible parent), any resource IDs associated with that widget cannot be resolved to a specific resource value other than by directly indexing into the resource table assigned to a specific display.</span></span> <span data-ttu-id="a74b9-674">Belirli bir kaynak tablosuna bu doğrudan erişim uygulama yazılımı tarafından güvenli bir şekilde yapılabilir, ancak iç GUIX kitaplık yazılımında hiçbir zaman yapılmaz.</span><span class="sxs-lookup"><span data-stu-id="a74b9-674">This direct access to a specific resource table can safely be done by the application software, but is never done in the internal GUIX library software.</span></span>

### <a name="widget-defaults"></a><span data-ttu-id="a74b9-675">Pencere Öğesi Varsayılanları</span><span class="sxs-lookup"><span data-stu-id="a74b9-675">Widget Defaults</span></span> 

<span data-ttu-id="a74b9-676">GUIX görüntüleme bileşeni ayrıca çeşitli pencere öğesi öznitelikleri için varsayılan tanımlar sağlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-676">The GUIX display component also provides default definitions for various widget attributes.</span></span> <span data-ttu-id="a74b9-677">Uygulama tarafından aksi belirtilmedikçe pencere öğeleri/pencereler bu sistem öznitelikleriyle oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-677">Unless otherwise specified by the application, widgets/windows are created with these system attributes.</span></span> <span data-ttu-id="a74b9-678">Bu sistem öznitelikleri genellikle sistem kaynak tablolarında bakımı yapılan yazı tipleri, renkler ve bit eşlemlerden oluşur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-678">These system attributes are mainly composed of fonts, colors, and bitmaps maintained in the system resource tables.</span></span> <span data-ttu-id="a74b9-679">Varsayılan kaydırma çubuğu görünümü için ek öznitelikler GUIX görüntüleme bileşeni tarafından da korunur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-679">Additional attributes for default scrollbar appearance are also maintained by the GUIX display component.</span></span>

<span data-ttu-id="a74b9-680">Varsayılan renk ayarları, her görüntüye atanan renk tablosu ve önceden tanımlanmış varsayılan renk kimlikleri tarafından tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-680">The default color settings are defined by the color table assigned to each display and the pre-defined default color IDs.</span></span> <span data-ttu-id="a74b9-681">Bu varsayılan renk kimlikleri aşağıdakileri içerir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-681">These default color ids include the following.</span></span>

| <span data-ttu-id="a74b9-682">Renk Kimliği</span><span class="sxs-lookup"><span data-stu-id="a74b9-682">Color ID</span></span> | <span data-ttu-id="a74b9-683">Açıklama</span><span class="sxs-lookup"><span data-stu-id="a74b9-683">Description</span></span> |
| ------------------ | -------------------------------------------------------------------------------------------------------------------------------- |
| <span data-ttu-id="a74b9-684">GX_COLOR_ID_CANVAS</span><span class="sxs-lookup"><span data-stu-id="a74b9-684">GX_COLOR_ID_CANVAS</span></span> | <span data-ttu-id="a74b9-685">Varsayılan tuval (arka planı görüntüleme) rengi</span><span class="sxs-lookup"><span data-stu-id="a74b9-685">Default canvas (i.e. display background) color</span></span> |
| <span data-ttu-id="a74b9-686">GX_COLOR_ID_WIDGET_FILL</span><span class="sxs-lookup"><span data-stu-id="a74b9-686">GX_COLOR_ID_WIDGET_FILL</span></span> | <span data-ttu-id="a74b9-687">Varsayılan pencere öğesi dolgu rengi</span><span class="sxs-lookup"><span data-stu-id="a74b9-687">Default widget fill color</span></span> |
| <span data-ttu-id="a74b9-688">GX_COLOR_ID_WINDOW_FILL</span><span class="sxs-lookup"><span data-stu-id="a74b9-688">GX_COLOR_ID_WINDOW_FILL</span></span> | <span data-ttu-id="a74b9-689">Varsayılan pencere dolgu rengi</span><span class="sxs-lookup"><span data-stu-id="a74b9-689">Default window fill color</span></span> |
| <span data-ttu-id="a74b9-690">GX_COLOR_ID_DISABLED_FILL</span><span class="sxs-lookup"><span data-stu-id="a74b9-690">GX_COLOR_ID_DISABLED_FILL</span></span> | <span data-ttu-id="a74b9-691">Varsayılan devre dışı bırakılmış pencere öğesi dolgu rengi</span><span class="sxs-lookup"><span data-stu-id="a74b9-691">Default disabled widget fill color</span></span> |
| <span data-ttu-id="a74b9-692">GX_COLOR_ID_DEFAULT_BORDER</span><span class="sxs-lookup"><span data-stu-id="a74b9-692">GX_COLOR_ID_DEFAULT_BORDER</span></span> | <span data-ttu-id="a74b9-693">Varsayılan pencere öğesi kenarlık rengi</span><span class="sxs-lookup"><span data-stu-id="a74b9-693">Default widget border color</span></span> |
| <span data-ttu-id="a74b9-694">GX_COLOR_ID_WINDOW_BORDER</span><span class="sxs-lookup"><span data-stu-id="a74b9-694">GX_COLOR_ID_WINDOW_BORDER</span></span> | <span data-ttu-id="a74b9-695">Varsayılan pencere kenarlık rengi</span><span class="sxs-lookup"><span data-stu-id="a74b9-695">Default window border color</span></span> |
| <span data-ttu-id="a74b9-696">GX_COLOR_ID_TEXT</span><span class="sxs-lookup"><span data-stu-id="a74b9-696">GX_COLOR_ID_TEXT</span></span> | <span data-ttu-id="a74b9-697">Varsayılan metin rengi</span><span class="sxs-lookup"><span data-stu-id="a74b9-697">Default text color</span></span> |
| <span data-ttu-id="a74b9-698">GX_COLOR_ID_SELECTED_TEXT</span><span class="sxs-lookup"><span data-stu-id="a74b9-698">GX_COLOR_ID_SELECTED_TEXT</span></span> | <span data-ttu-id="a74b9-699">Varsayılan seçilen metin rengi</span><span class="sxs-lookup"><span data-stu-id="a74b9-699">Default selected text color</span></span> |
| <span data-ttu-id="a74b9-700">GX_COLOR_ID_DISABLED_TEXT</span><span class="sxs-lookup"><span data-stu-id="a74b9-700">GX_COLOR_ID_DISABLED_TEXT</span></span> | <span data-ttu-id="a74b9-701">Varsayılan devre dışı metin rengi</span><span class="sxs-lookup"><span data-stu-id="a74b9-701">Default disabled text color</span></span> |
| <span data-ttu-id="a74b9-702">GX_COLOR_ID_SELECTED_TEXT_FILL</span><span class="sxs-lookup"><span data-stu-id="a74b9-702">GX_COLOR_ID_SELECTED_TEXT_FILL</span></span> | <span data-ttu-id="a74b9-703">Varsayılan seçili metin dolgusu rengi</span><span class="sxs-lookup"><span data-stu-id="a74b9-703">Default selected text fill color</span></span> |
| <span data-ttu-id="a74b9-704">GX_COLOR_ID_READONLY_TEXT</span><span class="sxs-lookup"><span data-stu-id="a74b9-704">GX_COLOR_ID_READONLY_TEXT</span></span> | <span data-ttu-id="a74b9-705">Varsayılan salt okunur metin rengi</span><span class="sxs-lookup"><span data-stu-id="a74b9-705">Default readonly text color</span></span> |
| <span data-ttu-id="a74b9-706">GX_COLOR_ID_READONLY_FILL</span><span class="sxs-lookup"><span data-stu-id="a74b9-706">GX_COLOR_ID_READONLY_FILL</span></span> | <span data-ttu-id="a74b9-707">Varsayılan salt okunur metin dolgusu rengi</span><span class="sxs-lookup"><span data-stu-id="a74b9-707">Default readonly text fill color</span></span> |
| <span data-ttu-id="a74b9-708">GX_COLOR_ID_SCROLL_FILL</span><span class="sxs-lookup"><span data-stu-id="a74b9-708">GX_COLOR_ID_SCROLL_FILL</span></span> |    <span data-ttu-id="a74b9-709">ScrollBar dolgusu rengi</span><span class="sxs-lookup"><span data-stu-id="a74b9-709">Scrollbar fill color</span></span> |
| <span data-ttu-id="a74b9-710">GX_COLOR_ID_SCROLL_BUTTON</span><span class="sxs-lookup"><span data-stu-id="a74b9-710">GX_COLOR_ID_SCROLL_BUTTON</span></span> | <span data-ttu-id="a74b9-711">Kaydırma çubuğu düğme dolgusu rengi</span><span class="sxs-lookup"><span data-stu-id="a74b9-711">Scrollbar button fill color</span></span> |
| <span data-ttu-id="a74b9-712">GX_COLOR_ID_SHADOW</span><span class="sxs-lookup"><span data-stu-id="a74b9-712">GX_COLOR_ID_SHADOW</span></span> | <span data-ttu-id="a74b9-713">Varsayılan gölge rengi</span><span class="sxs-lookup"><span data-stu-id="a74b9-713">Default shadow color</span></span> |
| <span data-ttu-id="a74b9-714">GX_COLOR_ID_SHINE</span><span class="sxs-lookup"><span data-stu-id="a74b9-714">GX_COLOR_ID_SHINE</span></span> | <span data-ttu-id="a74b9-715">Varsayılan vurgu rengi</span><span class="sxs-lookup"><span data-stu-id="a74b9-715">Default highlight color</span></span> |
| <span data-ttu-id="a74b9-716">GX_COLOR_ID_BUTTON_BORDER</span><span class="sxs-lookup"><span data-stu-id="a74b9-716">GX_COLOR_ID_BUTTON_BORDER</span></span> | <span data-ttu-id="a74b9-717">Düğme pencere öğesi kenarlık rengi</span><span class="sxs-lookup"><span data-stu-id="a74b9-717">Button widget border color</span></span> |
| <span data-ttu-id="a74b9-718">GX_COLOR_ID_BUTTON_UPPER</span><span class="sxs-lookup"><span data-stu-id="a74b9-718">GX_COLOR_ID_BUTTON_UPPER</span></span> | <span data-ttu-id="a74b9-719">Düğme pencere öğesi üst dolgusu rengi</span><span class="sxs-lookup"><span data-stu-id="a74b9-719">Button widget upper fill color</span></span> |
| <span data-ttu-id="a74b9-720">GX_COLOR_ID_BUTTON_LOWER</span><span class="sxs-lookup"><span data-stu-id="a74b9-720">GX_COLOR_ID_BUTTON_LOWER</span></span> | <span data-ttu-id="a74b9-721">Düğme pencere öğesi alt Fill Color</span><span class="sxs-lookup"><span data-stu-id="a74b9-721">Button widget lower fill color</span></span> |
| <span data-ttu-id="a74b9-722">GX_COLOR_ID_BUTTON_TEXT</span><span class="sxs-lookup"><span data-stu-id="a74b9-722">GX_COLOR_ID_BUTTON_TEXT</span></span> | <span data-ttu-id="a74b9-723">Düğme pencere öğesi metin rengi</span><span class="sxs-lookup"><span data-stu-id="a74b9-723">Button widget text color</span></span> |
| <span data-ttu-id="a74b9-724">GX_COLOR_ID_TEXT_INPUT_TEXT</span><span class="sxs-lookup"><span data-stu-id="a74b9-724">GX_COLOR_ID_TEXT_INPUT_TEXT</span></span> | <span data-ttu-id="a74b9-725">Metin girişi pencere öğesi metin rengi</span><span class="sxs-lookup"><span data-stu-id="a74b9-725">Text input widget text color</span></span> |
| <span data-ttu-id="a74b9-726">GX_COLOR_ID_TEXT_INPUT_FILL</span><span class="sxs-lookup"><span data-stu-id="a74b9-726">GX_COLOR_ID_TEXT_INPUT_FILL</span></span> | <span data-ttu-id="a74b9-727">Metin girişi dolgusu rengi</span><span class="sxs-lookup"><span data-stu-id="a74b9-727">Text input fill color</span></span> |
| <span data-ttu-id="a74b9-728">GX_COLOR_ID_SLIDER_TICK</span><span class="sxs-lookup"><span data-stu-id="a74b9-728">GX_COLOR_ID_SLIDER_TICK</span></span> | <span data-ttu-id="a74b9-729">Kaydırıcı değer çizgilerini çizmek için kullanılan renk.</span><span class="sxs-lookup"><span data-stu-id="a74b9-729">Color used to draw slider tick marks.</span></span> |
| <span data-ttu-id="a74b9-730">GX_COLOR_ID_SLIDER_GROOVE_BOTTOM</span><span class="sxs-lookup"><span data-stu-id="a74b9-730">GX_COLOR_ID_SLIDER_GROOVE_BOTTOM</span></span> | <span data-ttu-id="a74b9-731">Kaydırıcı oluk çizmek için kullanılan renk</span><span class="sxs-lookup"><span data-stu-id="a74b9-731">Color used to draw slider groove</span></span> |
| <span data-ttu-id="a74b9-732">GX_COLOR_ID_SLIDER_NEEDLE_OUTLINE</span><span class="sxs-lookup"><span data-stu-id="a74b9-732">GX_COLOR_ID_SLIDER_NEEDLE_OUTLINE</span></span> | <span data-ttu-id="a74b9-733">İğne ana hattını çizmek için kullanılan renk</span><span class="sxs-lookup"><span data-stu-id="a74b9-733">Color used to draw needle outline</span></span> |
| <span data-ttu-id="a74b9-734">GX_COLOR_ID_SLIDER_NEEDLE_FILL</span><span class="sxs-lookup"><span data-stu-id="a74b9-734">GX_COLOR_ID_SLIDER_NEEDLE_FILL</span></span> | <span data-ttu-id="a74b9-735">Kaydırıcı iğne dolgusu için kullanılan renk</span><span class="sxs-lookup"><span data-stu-id="a74b9-735">Color used to fill slider needle</span></span> |
| <span data-ttu-id="a74b9-736">GX_COLOR_ID_SLIDER_NEEDLE_LINE1</span><span class="sxs-lookup"><span data-stu-id="a74b9-736">GX_COLOR_ID_SLIDER_NEEDLE_LINE1</span></span> | <span data-ttu-id="a74b9-737">İğne vurgulaması çizmek için kullanılan renk</span><span class="sxs-lookup"><span data-stu-id="a74b9-737">Color used to draw needle highlight</span></span> |
| <span data-ttu-id="a74b9-738">GX_COLOR_ID_SLIDER_NEEDLE_LINE2</span><span class="sxs-lookup"><span data-stu-id="a74b9-738">GX_COLOR_ID_SLIDER_NEEDLE_LINE2</span></span> | <span data-ttu-id="a74b9-739">İğne gölgesi çizmek için kullanılan renk</span><span class="sxs-lookup"><span data-stu-id="a74b9-739">Color used to draw needle shadow</span></span> |

<span data-ttu-id="a74b9-740">Bu renk KIMLIĞI değerleri, her bir görüntülemeye atanan renk tablosu tarafından tanımlanan belirli bir renk değerine eşlenir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-740">These color ID values are mapped to a specific color value as defined by the color table assigned to each display.</span></span> <span data-ttu-id="a74b9-741">Bu varsayılanlar, ***gx_display_color_table_set*** API işlevi çağırarak bir görüntüleme için Grup olarak değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-741">These defaults can be changed as a group for one display by calling the ***gx_display_color_table_set*** API function.</span></span> <span data-ttu-id="a74b9-742">GUIX Studio kullanıyorsanız, uygulamanız ***gx_studio_display_configure*** işlevini çağırdığında görüntüleme rengi tablosu otomatik olarak başlatılır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-742">If you are using GUIX Studio, the display color table is automatically initialized when your application calls the ***gx_studio_display_configure*** function.</span></span>

<span data-ttu-id="a74b9-743">GUX görüntü bileşeni de varsayılan bir yazı tipi tablosu saklar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-743">The GUIX display component also maintains a default font table.</span></span> <span data-ttu-id="a74b9-744">Varsayılan yazı tipi tablosu, uygulama tarafından özel olarak belirtilmedikçe her pencere öğesi türü tarafından kullanılan yazı tipini tanımlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-744">The default font table defines the font used by each widget type unless specifically specified by the application.</span></span> <span data-ttu-id="a74b9-745">Önceden tanımlanmış görüntüleme yazı tipi tablo kimlikleri aşağıdaki değerleri içerir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-745">The pre-defined display font table IDs include the following values.</span></span>

| <span data-ttu-id="a74b9-746">Yazı tipi &nbsp; kimliği</span><span class="sxs-lookup"><span data-stu-id="a74b9-746">Font&nbsp;ID</span></span> | <span data-ttu-id="a74b9-747">Açıklama</span><span class="sxs-lookup"><span data-stu-id="a74b9-747">Description</span></span> |
| ------------------ | --------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="a74b9-748">GX_FONT_ID_DEFAULT</span><span class="sxs-lookup"><span data-stu-id="a74b9-748">GX_FONT_ID_DEFAULT</span></span> | <span data-ttu-id="a74b9-749">Belirli bir yazı tipi tanımlanmadığında kullanılan varsayılan yazı tipi</span><span class="sxs-lookup"><span data-stu-id="a74b9-749">Default font used when no specific font is defined</span></span> |
| <span data-ttu-id="a74b9-750">GX_FONT_ID_BUTTON</span><span class="sxs-lookup"><span data-stu-id="a74b9-750">GX_FONT_ID_BUTTON</span></span> | <span data-ttu-id="a74b9-751">Düğmelerdeki tüm metinler için kullanılan varsayılan yazı tipi</span><span class="sxs-lookup"><span data-stu-id="a74b9-751">Default font used for all text on buttons</span></span> |
| <span data-ttu-id="a74b9-752">GX_FONT_ID_TEXT_INPUT</span><span class="sxs-lookup"><span data-stu-id="a74b9-752">GX_FONT_ID_TEXT_INPUT</span></span> | <span data-ttu-id="a74b9-753">Metin düzenleme alanları için kullanılan varsayılan yazı tipi</span><span class="sxs-lookup"><span data-stu-id="a74b9-753">Default font used for text edit fields</span></span> |

<span data-ttu-id="a74b9-754">Herhangi bir metin türü pencere öğesi tarafından kullanılan yazı tipi KIMLIĞI, metin ile ilgili her pencere türü için belirtilen **gx_<widget_type>_font_set** API kullanılarak yeniden atanabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-754">The font ID used by any text type widget can be re-assigned by using the **gx_<widget_type>_font_set** API provided for each text-related widget type.</span></span> <span data-ttu-id="a74b9-755">Tüm yazı tipi tablosu **gx_display_font_table_set** API işlevi çağırarak yeniden atanabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-755">The entire font table can be re-assigned by calling the **gx_display_font_table_set** API function.</span></span>

### <a name="scrollbar-appearance"></a><span data-ttu-id="a74b9-756">Kaydırma çubuğu görünümü</span><span class="sxs-lookup"><span data-stu-id="a74b9-756">Scrollbar Appearance</span></span> 

<span data-ttu-id="a74b9-757">GUX ekranı Ayrıca bu görüntü için varsayılan kaydırma çubuğu görünüm ayarlarını korur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-757">GUIX Display also maintains default scrollbar appearance settings for that display.</span></span> <span data-ttu-id="a74b9-758">Bu ayarlar, aşağıda tanımlanan **GX_SCROLLBAR_APPEARANCE** yapısı tarafından tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-758">These settings are defined by the **GX_SCROLLBAR_APPEARANCE** structure which is defined below.</span></span> <span data-ttu-id="a74b9-759">GUX görünümü dikey kaydırma çubukları için bir ScrollBar görünümü ve yatay kaydırma çubuklarının ikinci yapısını tutar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-759">GUIX Display maintains one scrollbar appearance structure for vertical scrollbars and a second structure for horizontal scroll bars.</span></span> <span data-ttu-id="a74b9-760">Uygulama, bir **GX_SCROLLBAR_APPEARANCE** yapısını başlatarak ve apı işlevini ***gx_display_scroll_appearance_set*** çağırarak herhangi bir görüntü için varsayılan kaydırma çubuğu görünümünü değiştirebilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-760">The application can modify the default scrollbar appearance for any display by initializing a **GX_SCROLLBAR_APPEARANCE** structure and invoking the API function ***gx_display_scroll_appearance_set***.</span></span>

```c
typedef struct GX_SCROLLBAR_APPEARANCE_STRUCT
{
    GX_VALUE       gx_scroll_width;
    GX_VALUE       gx_scroll_thumb_width;
    GX_VALUE       gx_scroll_thumb_travel_min;
    GX_VALUE       gx_scroll_thumb_travel_max;
    GX_UBYTE       gx_scroll_thumb_border_style;
    GX_RESOURCE_ID gx_scroll_fill_pixelmap;
    GX_RESOURCE_ID gx_scroll_thumb_pixelmap;
    GX_RESOURCE_ID gx_scroll_up_pixelmap;
    GX_RESOURCE_ID gx_scroll_down_pixelmap;
    GX_RESOURCE_ID gx_scroll_thumb_color;
    GX_RESOURCE_ID gx_scroll_thumb_border_color;
    GX_RESOURCE_ID gx_scroll_button_color;
} GX_SCROLLBAR_APPEARANCE;
```
| <span data-ttu-id="a74b9-761">GX_SCROLLBAR_APPEARANCE yapısı üyesi</span><span class="sxs-lookup"><span data-stu-id="a74b9-761">GX_SCROLLBAR_APPEARANCE Structure Member</span></span> | <span data-ttu-id="a74b9-762">Açıklama</span><span class="sxs-lookup"><span data-stu-id="a74b9-762">Description</span></span> |
| --- | --- |
| <span data-ttu-id="a74b9-763">gx_scroll_width</span><span class="sxs-lookup"><span data-stu-id="a74b9-763">gx_scroll_width</span></span> | <span data-ttu-id="a74b9-764">Dikey kaydırma çubuğunun genişliği veya yatay kaydırma çubuğunun yüksekliği piksel cinsinden.</span><span class="sxs-lookup"><span data-stu-id="a74b9-764">Width of a vertical scrollbar or height of a horizontal scrollbar, in pixels.</span></span> |
| <span data-ttu-id="a74b9-765">gx_scroll_thumb_width</span><span class="sxs-lookup"><span data-stu-id="a74b9-765">gx_scroll_thumb_width</span></span> | <span data-ttu-id="a74b9-766">Asansör ve bitiş düğmelerinin piksel cinsinden genişliği.</span><span class="sxs-lookup"><span data-stu-id="a74b9-766">Width of the elevator and end buttons, in pixels.</span></span> |
| <span data-ttu-id="a74b9-767">gx_scroll_thumb_travel_max</span><span class="sxs-lookup"><span data-stu-id="a74b9-767">gx_scroll_thumb_travel_max</span></span> | <span data-ttu-id="a74b9-768">Kaydırma çubuğunun sonundan en fazla kaydırma düğmesi seyahat noktası arasındaki fark.</span><span class="sxs-lookup"><span data-stu-id="a74b9-768">Offset from the end of scroll bar to maximum thumb button travel point.</span></span> |
| <span data-ttu-id="a74b9-769">gx_scroll_fill_pixelmap</span><span class="sxs-lookup"><span data-stu-id="a74b9-769">gx_scroll_fill_pixelmap</span></span> | <span data-ttu-id="a74b9-770">Kaydırma arka planını doldurmanız için pixelmap kullanıldı.</span><span class="sxs-lookup"><span data-stu-id="a74b9-770">Pixelmap used to fill scroll background.</span></span> |
| <span data-ttu-id="a74b9-771">gx_scroll_thumb_pixelmap</span><span class="sxs-lookup"><span data-stu-id="a74b9-771">gx_scroll_thumb_pixelmap</span></span> | <span data-ttu-id="a74b9-772">Kaydırma parmak izi düğmesini çizmek için kullanılan pixelmap.</span><span class="sxs-lookup"><span data-stu-id="a74b9-772">Pixelmap used to draw scroll thumb button.</span></span> |
| <span data-ttu-id="a74b9-773">gx_scroll_up_pixelmap</span><span class="sxs-lookup"><span data-stu-id="a74b9-773">gx_scroll_up_pixelmap</span></span> | <span data-ttu-id="a74b9-774">Kaydırma düğmesini çizmek için kullanılan pixelmap.</span><span class="sxs-lookup"><span data-stu-id="a74b9-774">Pixelmap used to draw scroll up button.</span></span> |
| <span data-ttu-id="a74b9-775">gx_scroll_down_pixelmap</span><span class="sxs-lookup"><span data-stu-id="a74b9-775">gx_scroll_down_pixelmap</span></span> | <span data-ttu-id="a74b9-776">Kaydır aşağı kaydırma düğmesini çizmek için kullanılan pixelmap.</span><span class="sxs-lookup"><span data-stu-id="a74b9-776">Pixelmap used to draw scroll down button.</span></span> |
| <span data-ttu-id="a74b9-777">gx_scroll_fill_color</span><span class="sxs-lookup"><span data-stu-id="a74b9-777">gx_scroll_fill_color</span></span> | <span data-ttu-id="a74b9-778">Kaydırma çubuğu arka planını doldururken kullanılan rengin renk KIMLIĞI.</span><span class="sxs-lookup"><span data-stu-id="a74b9-778">Color ID of color used to fill scrollbar background.</span></span> |
| <span data-ttu-id="a74b9-779">gx_scroll_button_color</span><span class="sxs-lookup"><span data-stu-id="a74b9-779">gx_scroll_button_color</span></span> | <span data-ttu-id="a74b9-780">Kaydırma çubuğu düğmesini dolduracak şekilde kullanılan rengin renk KIMLIĞI.</span><span class="sxs-lookup"><span data-stu-id="a74b9-780">Color ID of color used to fill scrollbar thumb button.</span></span> |

<span data-ttu-id="a74b9-781">Yazı tipi, renk ve stiller için bu varsayılan ayarların yanı sıra, uygulama her bir pencere öğesi türü tarafından sağlanmış olan API 'YI kullanarak istediğiniz şekilde bir servis talebiyle ilgili parametrelerden herhangi birini belirtebilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-781">In addition to these default settings for fonts, color, and styles, the application may specify any of the parameters on a case by case basis as desired using API provided by each widget type.</span></span>

### <a name="skinning-and-themes"></a><span data-ttu-id="a74b9-782">Kaplama ve Temalar</span><span class="sxs-lookup"><span data-stu-id="a74b9-782">Skinning and Themes</span></span>

<span data-ttu-id="a74b9-783">Kaplama, GUıDX Pencere öğelerinin ve Windows 'un temel görünümlerini kolayca değiştirmesini sağlar, yani "Skin" ın tek bir yerde değiştirilmesi, ilişkili tüm pencere öğelerinin ve pencerelerin temel görünümünü değiştirir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-783">Skinning allows GUIX widgets and windows to easily change their base appearance, i.e., changing the “skin” in one place will change the base appearance of all associated widgets and windows.</span></span>

<span data-ttu-id="a74b9-784">GUX uygulamanızı yeniden kaplama için, GUıDX görüntüleme kaynak tablolarına yeni bir Color, font ve veya pixelmap tablosu sağlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-784">Re-skinning your GUIX application requires that you supply a new color, font and or pixelmap table to the GUIX Display resource tables.</span></span> <span data-ttu-id="a74b9-785">Tüm Gux pencere öğeleri, kaynak KIMLIĞINE göre rengine, bit eşlemlerine veya yazı tipine başvurduğundan, yeni bir kaynak tablosu sağlanması otomatik olarak tüm Gux Pencere öğelerinin, kendilerine istenen ekranda çizim yaparken yeni renklerinizi ve pixelmaps kullanmaya başlamasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-785">Since all GUIX widgets refer to their color, bitmap, or font by resource ID, providing a new resource table automatically causes all GUIX widgets to begin using your new colors and pixelmaps when they draw themselves to the desired display.</span></span>

<span data-ttu-id="a74b9-786">Etkileyici bir görünüm sağlamak için birlikte çalışmak üzere tasarlanan yeni bir yazı tipi, renk ve pixelmaps kümesi, *Tema* olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-786">A new set of fonts, colors, and pixelmaps that are designed to work together to provide an attractive appearance is called a *theme*.</span></span> <span data-ttu-id="a74b9-787">Bir tema, kaynak tablolarının bir kümesini ve her bir kaynak tablosunun boyutunu tanımlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-787">A theme defines a set of resource tables and the size of each resource table.</span></span> <span data-ttu-id="a74b9-788">Herhangi bir sayıda tema, GUıDX Studio uygulaması kullanılarak herhangi bir görüntü için tanımlanabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-788">Any number of themes can be defined for any display using the GUIX Studio application.</span></span> <span data-ttu-id="a74b9-789">Başlangıç teması dizinini, oluşturulan ekranda ilk temayı yükleyecek olan ***gx_studio_display_configure*** Gux Studio tarafından oluşturulan işleve geçirmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-789">You must pass the starting theme index to the GUIX Studio generated function ***gx_studio_display_configure***, which installs the initial theme into the created display.</span></span> <span data-ttu-id="a74b9-790">Herhangi bir ekran için etkin tema, ***gx_display_theme_install*** işlevi çağırarak herhangi bir zamanda değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-790">The active theme for any display can be changed at any time by calling the function ***gx_display_theme_install***.</span></span>

### <a name="root-window"></a><span data-ttu-id="a74b9-791">Kök pencere</span><span class="sxs-lookup"><span data-stu-id="a74b9-791">Root Window</span></span>

<span data-ttu-id="a74b9-792">Bir uygulama tarafından oluşturulan her görünebilir tuval için, uygulamanın Ayrıca bu tuval için bir kök pencere oluşturması gerekir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-792">For each visible canvas created by an application, the application must also create one Root Window for that canvas.</span></span> <span data-ttu-id="a74b9-793">Bu özel pencere, temel olarak tüm üst düzey uygulama pencereleri ve pencere öğeleri için bir kapsayıcı görevi görür.</span><span class="sxs-lookup"><span data-stu-id="a74b9-793">This special window basically acts as a container for all the top-level application windows and widgets.</span></span> <span data-ttu-id="a74b9-794">Kök pencere, tuval arka planını çizer ve kök pencere **GX_WINDOW** sınıftan türetildiğinden, kök pencerenin duvar kağıdı de olabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-794">The root window draws the canvas background, and since the root window is derived from the **GX_WINDOW** class the root window can also have wallpaper.</span></span> <span data-ttu-id="a74b9-795">Görüntü veya tuvaliniz arka plan rengini değiştirmek için, bu tuvale eklenmiş olan kök pencerenin Fill rengini değiştirmeniz yeterlidir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-795">To change the background color of your display or canvas, you simply change the fill color of the root window attached to that canvas.</span></span>

<span data-ttu-id="a74b9-796">Görüntülerinizi yapılandırmak için ***gx_studio_display_configure*** adlı Guıdx Studio generated işlevini kullanırsanız, bu başlatma işlevinin bir parçası olarak her bir ekran için tuval ve kök pencere oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-796">If you use the GUIX Studio generated function named ***gx_studio_display_configure*** to configure your displays, then the canvas and root window for each display are created for you as part of this initialization function.</span></span>

### <a name="anti-aliasing"></a><span data-ttu-id="a74b9-797">Kenar yumuşatma</span><span class="sxs-lookup"><span data-stu-id="a74b9-797">Anti-Aliasing</span></span> 

<span data-ttu-id="a74b9-798">Kenar yumuşatma, çizgileri, eğrileri ve yazı tiplerini düzgünleştirmek için kullanılan, GUıDX 'teki isteğe bağlı bir özelliktir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-798">Anti-Aliasing is an optional feature in GUIX that is used to smooth lines, curves, and fonts.</span></span> <span data-ttu-id="a74b9-799">Kenar yumuşatma yalnızca 16 BPP veya daha yüksek renk derinliğine sahip bir ekran sürücüsüyle çalışırken desteklenir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-799">Anti-aliasing is only supported when running with a display driver utilizing 16-bpp or higher color depth.</span></span>

<span data-ttu-id="a74b9-800">Etkin fırçayla **GX_BRUSH_ALIAS** flaş ayarlanarak, daha fazla diğer çizgi çizimi etkinleştirilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-800">Anti-aliased line drawing is enabled by setting the **GX_BRUSH_ALIAS** flash in the active brush.</span></span> <span data-ttu-id="a74b9-801">Bu, doğrudan çizilen çizgilerin yanı sıra çokgen veya dairenin kenarlığı olarak çizilen çizgiler için de geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-801">This applies to lines drawn directly as well as to lines drawn as the border of a polygon or circle.</span></span>

<span data-ttu-id="a74b9-802">Diğer addan koruma metin çizimi, GUIX studio uygulaması tarafından üretilen diğer addan koruma yazı tipi kullanılarak etkinleştirilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-802">Anti-aliased text drawing is enabled by using an anti-aliased font which is produced by the GUIX studio application.</span></span> <span data-ttu-id="a74b9-803">Yazı tipini oluşturmadan önce yazı tipinin antialiased veya ikili olarak mı oluşturul olacağını belirtirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a74b9-803">You specify whether a font should be generated as antialiased or binary when you create the font.</span></span>
<span data-ttu-id="a74b9-804">GUIX'te diğer adlara sahip olmayan yazı tipleri, her piksel için 16 saydamlık düzeyi kullanır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-804">Anti-aliased fonts in GUIX utilize 16 levels of transparency for each pixel.</span></span>

### <a name="clipping"></a><span data-ttu-id="a74b9-805">Kırpma</span><span class="sxs-lookup"><span data-stu-id="a74b9-805">Clipping</span></span> 

<span data-ttu-id="a74b9-806">Kırpma, GUIX görüntüleme bileşeni tarafından dahili olarak ve GUIX pencere öğeleri tarafından bakımı yapılan üst-alt mimariye göre pencere ve pencere öğesi katmanları tarafından de destekleniyor.</span><span class="sxs-lookup"><span data-stu-id="a74b9-806">Clipping is supported internally by the GUIX display component, and at the window and widget layers by the parent-child architecture maintained by GUIX widgets.</span></span> <span data-ttu-id="a74b9-807">Hiçbir pencere öğesi veya pencere öğesi hiçbir zaman pencere öğesi alanı dışına çizilmiyor ve bir pencere öğesi hiçbir zaman pencere öğesi üst öğenin alanı dışına çizilmiyor.</span><span class="sxs-lookup"><span data-stu-id="a74b9-807">No window or widget is ever allowed to draw outside of that widget’s area, and a widget is never allowed to draw outside of the area of that widget’s parent.</span></span>

<span data-ttu-id="a74b9-808">Bu ayrıca, pencere öğelerinin tuval belleğinin dışında bulunan piksel koordinatlarına çizmesini de önler ve bu da büyük olasılıkla bellek bozulmasına veya sistem hatasına yol açabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-808">This also prevents widgets from drawing at pixel coordinates that lay outside of the canvas memory which likely lead to memory corruption or a system failure.</span></span> <span data-ttu-id="a74b9-809">Pencere öğelerinin pencere öğesi alanı, pencere öğesi üst alanı veya tuval kapsamının dışında çizmesine izin verilmez.</span><span class="sxs-lookup"><span data-stu-id="a74b9-809">Widgets are not allowed to draw outside of the widget’s area, the widget’s parent area, or beyond the canvas extent.</span></span>

<span data-ttu-id="a74b9-810">Ayrıca, pencere öğeleri yalnızca daha önce kirli olarak işaretlenmiş alanlara çizebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a74b9-810">In addition, widgets can only draw to areas that have previously been marked as dirty.</span></span> <span data-ttu-id="a74b9-811">Bu, pencerenin yalnızca bir köşesinin ortaya çıkarması gibi bir pencerenin tamamının çizilenesini önler.</span><span class="sxs-lookup"><span data-stu-id="a74b9-811">This prevents an entire window being drawn, for example, when only a corner of the window has been revealed.</span></span> <span data-ttu-id="a74b9-812">Pencerenin yalnızca gerçekten yenilenmesi gereken kısmı kirli olarak işaretlenir ve bu nedenle pencere çizimi işlevi yalnızca kirli alanda pikselleri gerçekten yeniler.</span><span class="sxs-lookup"><span data-stu-id="a74b9-812">Only the portion of the window that actually needs to be refreshed is marked as dirty, and so the window drawing function only truly refreshes pixels in the dirty area.</span></span>

<span data-ttu-id="a74b9-813">GUIX görüntüleme bileşeni, sürücü düzeyinde çizim işlevlerini iptalmeden önce bu kırpma algoritmalarını zorlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-813">The GUIX dispaly component enforces these clipping algorithms before invoking the driver level drawing functions.</span></span>

### <a name="views"></a><span data-ttu-id="a74b9-814">Görünümler</span><span class="sxs-lookup"><span data-stu-id="a74b9-814">Views</span></span> 

<span data-ttu-id="a74b9-815">GUIX, her kök pencere ve kök pencerenin her alt penceresi için her zaman bir görünüm kümesi sağlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-815">GUIX always maintains a set of views for each root window and each child window of the root window.</span></span> <span data-ttu-id="a74b9-816">Görünümler, pencere konumu ve Z sırası değiştirildiğinde değiştirilen dinamik, çalışma zamanı belirlenen bir kırpma alanıdır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-816">Views are a dynamic, run-time determined clipping area that changes as window position and Z-order are modified.</span></span>
<span data-ttu-id="a74b9-817">GUIX, arka plandaki pencere veya pencere öğelerinin ön planda bir pencere veya pencere öğesi üzerine çizmesini önlemek için görünümleri kullanır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-817">GUIX uses views to prevent a window or widget in the background from drawing on top of a window or widget in the foreground.</span></span> <span data-ttu-id="a74b9-818">Görünümler Z düzeni disiplini gerektirir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-818">Views enforce Z-order discipline.</span></span> <span data-ttu-id="a74b9-819">Ayrıca görünümler, arka planda yer alan bir pencerenin tuvalin görülen herhangi bir alanına çizimini önleme açısından verimlilik açısından önemlidir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-819">In addition, views are important for efficiency in that they prevent a window in the background from drawing to any area of the canvas that cannot be seen.</span></span> <span data-ttu-id="a74b9-820">Bir pencere başka bir pencere tarafından tamamen kapsamışsa, bunu yapmaya çalışsa bile, kaplanmış pencerenin tuvale çizmesine izin verilmez.</span><span class="sxs-lookup"><span data-stu-id="a74b9-820">If a window is completely covered by another window, the covered window will not be allowed to draw to the canvas at all, even if it is attempting to do so.</span></span>

### <a name="display-driver-interface"></a><span data-ttu-id="a74b9-821">Sürücü Arabirimini Görüntüleme</span><span class="sxs-lookup"><span data-stu-id="a74b9-821">Display Driver Interface</span></span> 

<span data-ttu-id="a74b9-822">GUIX ekran sürücüleri, temel alınan fiziksel ekranla tüm etkileşimden sorumludur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-822">GUIX display drivers are responsible for all interaction with the underlying physical screen.</span></span> <span data-ttu-id="a74b9-823">Görüntü sürücülerinin üç temel işlevi vardır: başlatma, çizim ve çerçeve arabelleği görüntüsü.</span><span class="sxs-lookup"><span data-stu-id="a74b9-823">The display drivers have three basic functions: initialization, drawing, and frame buffer display.</span></span>
<span data-ttu-id="a74b9-824">Başlatma, fiziksel görüntüleme donanımının hazırlanmasından, GUIX'in fiziksel görüntüleme donanımının özelliklerini bilgilendirmeden ve GUIX'e hangi çizim işlevlerinin kullan gerektiğini bildirmekten sorumludur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-824">Initialization is responsible for preparing the physical display hardware, informing GUIX of the properties of the physical display hardware, and for informing GUIX which specific drawing functions should be used.</span></span> <span data-ttu-id="a74b9-825">Ana görüntü sürücüsü başlatma, ***GUIX*** gx_display_create çağrılır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-825">The main display driver initialization is called from the GUIX ***gx_display_create*** function.</span></span> <span data-ttu-id="a74b9-826">Ayrıca GUIX iş parçacığı, iş parçacığı bağlamından ikincil bir görüntü sürücüsü başlatmayı da çağıracak.</span><span class="sxs-lookup"><span data-stu-id="a74b9-826">In addition, the GUIX thread will also call a secondary display driver initialization from the thread context.</span></span> <span data-ttu-id="a74b9-827">Bu ikincil görüntü sürücüsü yalnızca başlatma işlemi sırasında RTOS hizmetleri gerektiriyorsa (örneğin,  cihaz kesintileri veya tx_thread_sleep başlatma işlemi arasındaki gecikme istekleri için gereklidir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-827">This secondary display driver is only needed if the driver requires RTOS services during its initialization, e.g., device interrupts or ***tx_thread_sleep*** requests for delay between steps in the initialization process.</span></span>

<span data-ttu-id="a74b9-828">Başlatma tamamlandıktan sonra, görüntüleme sürücüsü fiziksel görüntüleme donanımlarında yap yalnızca çizimden sorumludur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-828">Once initialization is complete, the display driver is responsible for any direct drawing that can be done in the physical display hardware.</span></span>
<span data-ttu-id="a74b9-829">Son olarak, görüntü sürücüsü çerçeve arabelleğinin görüntülenmesinden sorumludur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-829">Finally, the display driver is responsible for displaying the frame buffer.</span></span>

## <a name="guix-widget-component"></a><span data-ttu-id="a74b9-830">GUIX Pencere Öğesi Bileşeni</span><span class="sxs-lookup"><span data-stu-id="a74b9-830">GUIX Widget Component</span></span>

<span data-ttu-id="a74b9-831">GUIX pencere öğesi, görünür bir grafik öğesidir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-831">A GUIX widget is a visible graphical element.</span></span> <span data-ttu-id="a74b9-832">Süreerler ve matematik yardımcı programı işlevleri gibi görünür değildir GUIX bileşenleri vardır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-832">There are GUIX components which are not visible, such as timers and math utility functions.</span></span>
<span data-ttu-id="a74b9-833">Ancak tüm görünür bileşenler temel GUIX pencere öğesi bileşeninden türetilen.</span><span class="sxs-lookup"><span data-stu-id="a74b9-833">However all visible components are derived from the basic GUIX widget component.</span></span> <span data-ttu-id="a74b9-834">GUIX pencere öğesi, GUIX ekranın birincil yapı taşıdır. Diğer tüm grafik öğeler temel pencere öğesi işlevinden türetilen öğelerdir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-834">A GUIX widget is the primary building block of the GUIX display – all other graphic elements are derived from the base widget functionality.</span></span>

<span data-ttu-id="a74b9-835">GUIX pencere öğeleri, tam devralma desteğiyle nesne odaklı bir şekilde uygulanır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-835">GUIX widgets are implemented in an object oriented manner with full support of inheritance.</span></span> <span data-ttu-id="a74b9-836">Bu, mümkün olan en küçük bellek ve işlem gereksinimleriyle sonuçlandıran ANSI C kullanılarak gereksinimlerini karşılar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-836">This is accomplished using ANSI C, which results in the smallest possible memory and processing requirements.</span></span> <span data-ttu-id="a74b9-837">**temel** GX_WIDGET gibi başka bir pencere öğesinden türetilen GX_BUTTON gibi belirli bir pencere öğesinden söz etmek,  **GX_BUTTON** denetim yapısının GX_WIDGET'nin tüm üye değişkenlerini ve işlev işaretçilerini içerdiğini ve GX_BUTTON'a özgü bazı ek değişkenleri içerdiğini ifade **eder.**  </span><span class="sxs-lookup"><span data-stu-id="a74b9-837">When we speak of one particular widget, such as **GX_BUTTON**, being *derived from* another widget, such as the base **GX_WIDGET**, what we mean is that the **GX_BUTTON** control structure contains all of the member variables and function pointers of **GX_WIDGET**, with some additional variables that are specific to **GX_BUTTON**.</span></span> <span data-ttu-id="a74b9-838">GUIX, pencere öğelerinin katmanlarını bu şekilde biriktir, böylece daha karmaşık pencere öğeleri her zaman onlardan önce daha basit bir pencere öğesi temel almaktadır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-838">GUIX builds up layers of widgets in this fashion, so that more complex widgets are always based on a simpler widget before them.</span></span> <span data-ttu-id="a74b9-839">Bu hiyerarşik türetme modeli, pencere öğesi parametrelerini değiştirmek için kullanılan API'leri öğrenmeyi kolaylaştırır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-839">This hierarchical model of derivation makes it easier to learn the APIs used to modify widget parameters.</span></span> <span data-ttu-id="a74b9-840">Bir düğmenin rengini değiştirmek için, pencere öğesi rengini değiştirmek için aynı API'yi kullanırsınız, yani ***gx_widget_fill_color_set.***</span><span class="sxs-lookup"><span data-stu-id="a74b9-840">If you want to modify the color of a button, you use the same API you use to modify the color of a widget, namely ***gx_widget_fill_color_set***.</span></span>

<span data-ttu-id="a74b9-841">Görünür pencere öğelerinin organizasyonu, alt pencere öğelerinin üst öğelerine bağlantısı olan ağaç yapılandırılmış listeleri kullanılarak üst-alt öğe olarak korunur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-841">The organization of visible widgets is maintained in a parent-child manner using tree structured lists linking child widgets to their parents.</span></span> <span data-ttu-id="a74b9-842">Çocuk, üstlerinden, çizerek çizenin görünümler ve üzerinde çiz yaptıkları tuval gibi özellikleri devralabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-842">The children inherit characteristics from their parents such as the views into which they can draw and the canvas on which they draw.</span></span>
<span data-ttu-id="a74b9-843">Alt pencere öğeleri, yine üst öğeden çeşitli özellikleri devralan kendi alt pencere öğelerine sahip olabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-843">Child widgets may have their own child widgets, again inheriting various characteristics from the parent.</span></span> <span data-ttu-id="a74b9-844">Herhangi bir pencere öğesi özellikleri, çeşitli GUIX API çağrıları aracılığıyla açıkça yeniden tanımlanmamış olabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-844">The characteristics of any widget may be explicitly redefined via various GUIX API calls.</span></span>

### <a name="widget-creation"></a><span data-ttu-id="a74b9-845">Pencere Öğesi Oluşturma</span><span class="sxs-lookup"><span data-stu-id="a74b9-845">Widget Creation</span></span> 

<span data-ttu-id="a74b9-846">Bir pencere öğesi nesnesi başlatma sırasında veya uygulama iş parçacıklarının yürütülmesi sırasında herhangi bir zamanda oluşturulabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-846">A widget object can be created during initialization or anytime during the execution of application threads.</span></span> <span data-ttu-id="a74b9-847">Bir uygulama tarafından oluşturulacak pencere öğesi nesnelerinin sayısına bir sınır yoktur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-847">There is no limit on the number of widget objects that can be created by an application.</span></span> <span data-ttu-id="a74b9-848">Ayrıca, hedef donanımınız için bellek sınırları dahilinde herhangi bir pencere öğesi için sahip ola bir üst sınır yoktur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-848">There is also no limit on the number of children any widget may have, within the memory limits of your target hardware.</span></span>

<span data-ttu-id="a74b9-849">Her pencere öğesi türünün \* gx_button_create _ **veya** _\* gx_prompt_create \*\*_gibi kendi oluşturma işlevi_ vardır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-849">Each widget type has its own create function, such as ***gx_button_create** _ or _*_gx_prompt_create_\*\*.</span></span> <span data-ttu-id="a74b9-850">Bu işlevlerin ilk üç parametresi her zaman aynıdır; yani pencere öğesi denetim yapısına bir işaretçi, pencere öğesi adına bir dize işaretçisi ve pencere öğesi üst öğesi işaretçisi.</span><span class="sxs-lookup"><span data-stu-id="a74b9-850">The first three parameters to these functions are always the same, namely a pointer to the widget control structure, a string pointer to the widget name, and a pointer to the widget’s parent.</span></span> <span data-ttu-id="a74b9-851">Her create işlevi, ilgili pencere öğesi türünün gereksinimlerine bağlı olarak herhangi bir sayıda ek parametreye sahip olabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-851">Each create function may have any number of additional parameters depending on the requirements of that particular widget type.</span></span>

### <a name="widget-control-block"></a><span data-ttu-id="a74b9-852">Pencere Öğesi Denetim Bloğu</span><span class="sxs-lookup"><span data-stu-id="a74b9-852">Widget Control Block</span></span> 

<span data-ttu-id="a74b9-853">Her pencere öğesi nesnesinin özellikleri, denetim bloğunda **GX_WIDGET** ve **_gx_api.h içinde tanımlanır._**</span><span class="sxs-lookup"><span data-stu-id="a74b9-853">The characteristics of each widget object are found in its control block **GX_WIDGET** and are defined in **_gx_api.h_**.</span></span> <span data-ttu-id="a74b9-854">Bir pencere öğesi nesnesi için gereken bellek uygulama tarafından sağlanır ve bellekte herhangi bir yerde yer alıyor olabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-854">The memory required for a widget object is provided by the application and can be located anywhere in memory.</span></span> <span data-ttu-id="a74b9-855">Ancak, en yaygın olarak pencere öğesi nesne denetimi bloğu herhangi bir işlevin kapsamı dışında tanımlayarak genel bir yapı oluşturur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-855">However, it is most common to make the widget object control block a global structure by defining it outside the scope of any function.</span></span> <span data-ttu-id="a74b9-856">GUIX Studio kullanıyorsanız, pencere öğesi denetim bloklarınızı Studio tarafından oluşturulan belirtimler dosyanız içinde statik olarak ayırabilirsiniz veya bunlar uygulamanız tarafından dinamik olarak ayırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a74b9-856">If you are using GUIX Studio, your widget control blocks can be statically allocated within your Studio generated specifications file, or they can be dynamically allocated by your application.</span></span>

### <a name="dynamic-widget-control-block-allocation-and-de-allocation"></a><span data-ttu-id="a74b9-857">Dinamik Pencere Öğesi Denetimi Blok Ayırma ve Ayırmayı Geri Ayırma</span><span class="sxs-lookup"><span data-stu-id="a74b9-857">Dynamic Widget Control Block Allocation and De-allocation</span></span> 

<span data-ttu-id="a74b9-858">Dinamik denetim bloğu ayırma kullanıyorsanız, GUIX'in pencere öğesi denetim bloklarınız için gereken belleği ayırmak ve serbest kaldırmak için kullanabileceği iki işlev tanımlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-858">If you are using dynamic control block allocation, you will need to define two functions that GUIX will use to allocate and free the memory required for your widget control blocks.</span></span> <span data-ttu-id="a74b9-859">Bellek yönetimi işlevleriniz, gx_system_memory_allocator_set API işlevi aracılığıyla GUIX ***sistem bileşenine*** geçirildi.</span><span class="sxs-lookup"><span data-stu-id="a74b9-859">Your functions for memory management are passed to the GUIX system component via the ***gx_system_memory_allocator_set*** API function.</span></span> <span data-ttu-id="a74b9-860">Bu işlev GUIX'e iki işlev işaretçisi geçmenizi sağlar: birincisi bellek ayırma işlevinin işaretçisi, ikincisi ise bellek boş işlevinin işaretçisi.</span><span class="sxs-lookup"><span data-stu-id="a74b9-860">This function allows you to pass two function pointers into GUIX: the first is a pointer to a memory allocation function, and the second is a pointer to a memory free function.</span></span> <span data-ttu-id="a74b9-861">Çoğu zaman bu işlevleri ThreadX byte havuzlarını kullanarak uygulayabilirsiniz, ancak GUIX tasarımı, dinamik bellek yönetimini tercih edilen şekilde uygulamana olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-861">Most often, you will implement these functions using ThreadX byte pools, but the design of GUIX allows you to implement dynamic memory management in whatever way you prefer.</span></span>

<span data-ttu-id="a74b9-862">Dinamik pencere öğesi ayırma, Studio pencere öğesi özellikleri alanında "dinamik olarak ayrılmış" seçeneğini belirtirseniz, en çok Studio tarafından oluşturulan uygulama belirtimleri dosyanız içinde kullanılır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-862">Dynamic widget allocation is most often employed within your Studio generated application specifications file, when you select the “dynamically allocated” option in the Studio widget properties field.</span></span> <span data-ttu-id="a74b9-863">Ancak, dinamik denetim bloğu ayırmayı uygulama içinde de kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a74b9-863">However, you can also use dynamic control block allocation within your application.</span></span> <span data-ttu-id="a74b9-864">Uygulamanız içinde dinamik denetim bloğu ayırmayı kullanıyorsanız, pencere öğesi denetim bloğu ayırmak için \***gx_widget_allocate** _ API işlevini çağırmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-864">If you use dynamic control block allocation within your application, you should invoke the \***gx_widget_allocate** _ API function to allocate the widget control block.</span></span> <span data-ttu-id="a74b9-865">Ardından, pencere öğesini oluşturdukta, pencere öğesi oluşturma işlevine _ *GX_WIDGET_STYLE_DYNAMICALLY_ALLOCATED*\* stil bayrağını (diğer gerekli stil bayraklarıyla birlikte) iletirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a74b9-865">Next, when you create the widget, make certain you pass the _ *GX_WIDGET_STYLE_DYNAMICALLY_ALLOCATED*\* style flag (along with any other needed style flags) to the widget create function.</span></span> <span data-ttu-id="a74b9-866">Bu bayrak, pencere öğesi durum alanında pencere öğesi dinamik olarak ayrılmış olarak işaretlemek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-866">This flag is used to mark the widget as being dynamically allocated in the widget status field.</span></span> <span data-ttu-id="a74b9-867">Pencere öğesi daha sonra gx_widget_delete \*\*\*\* kullanılarak silindiğinde ve silindiğinde GUIX bu durum alanını kontrol eder ve bellek sızıntısı olmadığının ortaya çıktısını almak için bellek ayrımcı işlevinizi otomatik olarak çağıracaktır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-867">When and if the widget is later deleted using **_gx_widget_delete_**, GUIX will check this status field and automatically call your memory de-allocator function to insure there are no memory leaks.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="a74b9-868">Bellek kaybını önlemek için dinamik olarak ayrılmış bir denetim bloğu kullanılarak **oluşturulan bir pencere GX_WIDGET_STYLE_DYNAMICALLY_ALLOCATED** bayrağıyla oluşturularak.</span><span class="sxs-lookup"><span data-stu-id="a74b9-868">A widget created using a dynamically allocated control block must be created with the **GX_WIDGET_STYLE_DYNAMICALLY_ALLOCATED** style flag to prevent memory loss.</span></span>

### <a name="types"></a><span data-ttu-id="a74b9-869">Türler</span><span class="sxs-lookup"><span data-stu-id="a74b9-869">Types</span></span>

<span data-ttu-id="a74b9-870">GUIX, zengin ve tam işlevsel bir yerleşik pencere öğesi kümesi sağlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-870">GUIX provides a rich, fully functional set of built-in widgets.</span></span> <span data-ttu-id="a74b9-871">Daha önce belirtildiği gibi, tüm özel pencere öğeleri temel pencere öğesinden türetiliyor.</span><span class="sxs-lookup"><span data-stu-id="a74b9-871">As mentioned previously, all specialized widgets are derived from the base widget.</span></span> <span data-ttu-id="a74b9-872">GUIX'te yerleşik pencere öğelerinin listesi aşağıdadır:</span><span class="sxs-lookup"><span data-stu-id="a74b9-872">Following is a list of the built-in widgets in GUIX:</span></span>

<span data-ttu-id="a74b9-873">**GX_TYPE_WIDGET**</span><span class="sxs-lookup"><span data-stu-id="a74b9-873">**GX_TYPE_WIDGET**</span></span>

<span data-ttu-id="a74b9-874">**GX_TYPE_BUTTON**</span><span class="sxs-lookup"><span data-stu-id="a74b9-874">**GX_TYPE_BUTTON**</span></span>

<span data-ttu-id="a74b9-875">**GX_TYPE_TEXT_BUTTON**</span><span class="sxs-lookup"><span data-stu-id="a74b9-875">**GX_TYPE_TEXT_BUTTON**</span></span>

<span data-ttu-id="a74b9-876">**GX_TYPE_MULTI_LINE_TEXT_BUTTON**</span><span class="sxs-lookup"><span data-stu-id="a74b9-876">**GX_TYPE_MULTI_LINE_TEXT_BUTTON**</span></span>

<span data-ttu-id="a74b9-877">**GX_TYPE_RADIO_BUTTON**</span><span class="sxs-lookup"><span data-stu-id="a74b9-877">**GX_TYPE_RADIO_BUTTON**</span></span>

<span data-ttu-id="a74b9-878">**GX_TYPE_CHECKBOX**</span><span class="sxs-lookup"><span data-stu-id="a74b9-878">**GX_TYPE_CHECKBOX**</span></span>

<span data-ttu-id="a74b9-879">**GX_TYPE_PIXELMAP_BUTTON**</span><span class="sxs-lookup"><span data-stu-id="a74b9-879">**GX_TYPE_PIXELMAP_BUTTON**</span></span>

<span data-ttu-id="a74b9-880">**GX_TYPE_ICON_BUTTON**</span><span class="sxs-lookup"><span data-stu-id="a74b9-880">**GX_TYPE_ICON_BUTTON**</span></span>

<span data-ttu-id="a74b9-881">**GX_TYPE_ICON**</span><span class="sxs-lookup"><span data-stu-id="a74b9-881">**GX_TYPE_ICON**</span></span>

<span data-ttu-id="a74b9-882">**GX_TYPE_SPRITE**</span><span class="sxs-lookup"><span data-stu-id="a74b9-882">**GX_TYPE_SPRITE**</span></span>

<span data-ttu-id="a74b9-883">**GX_TYPE_SLIDER**</span><span class="sxs-lookup"><span data-stu-id="a74b9-883">**GX_TYPE_SLIDER**</span></span>

<span data-ttu-id="a74b9-884">**GX_TYPE_PIXELMAP_SLIDER**</span><span class="sxs-lookup"><span data-stu-id="a74b9-884">**GX_TYPE_PIXELMAP_SLIDER**</span></span>

<span data-ttu-id="a74b9-885">**GX_TYPE_VERTICAL_SCROLL**</span><span class="sxs-lookup"><span data-stu-id="a74b9-885">**GX_TYPE_VERTICAL_SCROLL**</span></span>

<span data-ttu-id="a74b9-886">**GX_TYPE_HORIZONTAL_SCROLL**</span><span class="sxs-lookup"><span data-stu-id="a74b9-886">**GX_TYPE_HORIZONTAL_SCROLL**</span></span>

<span data-ttu-id="a74b9-887">**GX_TYPE_PROGRESS_BAR**</span><span class="sxs-lookup"><span data-stu-id="a74b9-887">**GX_TYPE_PROGRESS_BAR**</span></span>

<span data-ttu-id="a74b9-888">**GX_TYPE_PROMPT**</span><span class="sxs-lookup"><span data-stu-id="a74b9-888">**GX_TYPE_PROMPT**</span></span>

<span data-ttu-id="a74b9-889">**GX_TYPE_NUMERIC_PROMPT**</span><span class="sxs-lookup"><span data-stu-id="a74b9-889">**GX_TYPE_NUMERIC_PROMPT**</span></span>

<span data-ttu-id="a74b9-890">**GX_TYPE_PIXELMAP_PROMPT**</span><span class="sxs-lookup"><span data-stu-id="a74b9-890">**GX_TYPE_PIXELMAP_PROMPT**</span></span>

<span data-ttu-id="a74b9-891">**GX_TYPE_NUMERIC_PIXELMAP_PROMPT**</span><span class="sxs-lookup"><span data-stu-id="a74b9-891">**GX_TYPE_NUMERIC_PIXELMAP_PROMPT**</span></span>

<span data-ttu-id="a74b9-892">**GX_TYPE_SINGLE_LINE_TEXT_INPUT**</span><span class="sxs-lookup"><span data-stu-id="a74b9-892">**GX_TYPE_SINGLE_LINE_TEXT_INPUT**</span></span>

<span data-ttu-id="a74b9-893">**GX_TYPE_MULTI_LINE_TEXT_VIEW**</span><span class="sxs-lookup"><span data-stu-id="a74b9-893">**GX_TYPE_MULTI_LINE_TEXT_VIEW**</span></span>

<span data-ttu-id="a74b9-894">**GX_TYPE_MULTI_LINE_TEXT_INPUT**</span><span class="sxs-lookup"><span data-stu-id="a74b9-894">**GX_TYPE_MULTI_LINE_TEXT_INPUT**</span></span>

<span data-ttu-id="a74b9-895">**GX_TYPE_WINDOW**</span><span class="sxs-lookup"><span data-stu-id="a74b9-895">**GX_TYPE_WINDOW**</span></span>

<span data-ttu-id="a74b9-896">**GX_TYPE_ROOT_WINDOW**</span><span class="sxs-lookup"><span data-stu-id="a74b9-896">**GX_TYPE_ROOT_WINDOW**</span></span>

<span data-ttu-id="a74b9-897">**GX_TYPE_VERTICAL_LIST**</span><span class="sxs-lookup"><span data-stu-id="a74b9-897">**GX_TYPE_VERTICAL_LIST**</span></span>

<span data-ttu-id="a74b9-898">**GX_TYPE_HORIZONTAL_LIST**</span><span class="sxs-lookup"><span data-stu-id="a74b9-898">**GX_TYPE_HORIZONTAL_LIST**</span></span>

<span data-ttu-id="a74b9-899">**GX_TYPE_POPUP_LIST**</span><span class="sxs-lookup"><span data-stu-id="a74b9-899">**GX_TYPE_POPUP_LIST**</span></span>

<span data-ttu-id="a74b9-900">**GX_TYPE_DROP_LIST**</span><span class="sxs-lookup"><span data-stu-id="a74b9-900">**GX_TYPE_DROP_LIST**</span></span>

<span data-ttu-id="a74b9-901">**GX_TYPE_LINE_CHART**</span><span class="sxs-lookup"><span data-stu-id="a74b9-901">**GX_TYPE_LINE_CHART**</span></span>

<span data-ttu-id="a74b9-902">**GX_TYPE_DIALOG**</span><span class="sxs-lookup"><span data-stu-id="a74b9-902">**GX_TYPE_DIALOG**</span></span>

<span data-ttu-id="a74b9-903">**GX_TYPE_KEYBOARD**</span><span class="sxs-lookup"><span data-stu-id="a74b9-903">**GX_TYPE_KEYBOARD**</span></span>

<span data-ttu-id="a74b9-904">**GX_TYPE_SCROLL_WHEEL**</span><span class="sxs-lookup"><span data-stu-id="a74b9-904">**GX_TYPE_SCROLL_WHEEL**</span></span>

<span data-ttu-id="a74b9-905">**GX_TYPE_TEXT_SCROLL_WHEEL**</span><span class="sxs-lookup"><span data-stu-id="a74b9-905">**GX_TYPE_TEXT_SCROLL_WHEEL**</span></span>

<span data-ttu-id="a74b9-906">**GX_TYPE_STRING_SCROLL_WHEEL**</span><span class="sxs-lookup"><span data-stu-id="a74b9-906">**GX_TYPE_STRING_SCROLL_WHEEL**</span></span>

<span data-ttu-id="a74b9-907">**GX_TYPE_NUMERIC_SCROLL_WHEEL**</span><span class="sxs-lookup"><span data-stu-id="a74b9-907">**GX_TYPE_NUMERIC_SCROLL_WHEEL**</span></span>

<span data-ttu-id="a74b9-908">**GX_TYPE_CIRCULAR_GAUGE**</span><span class="sxs-lookup"><span data-stu-id="a74b9-908">**GX_TYPE_CIRCULAR_GAUGE**</span></span>

<span data-ttu-id="a74b9-909">**GX_TYPE_RADIAL_PROGRESS_BAR**</span><span class="sxs-lookup"><span data-stu-id="a74b9-909">**GX_TYPE_RADIAL_PROGRESS_BAR**</span></span>

<span data-ttu-id="a74b9-910">**GX_TYPE_RADIAL_SLIDER**</span><span class="sxs-lookup"><span data-stu-id="a74b9-910">**GX_TYPE_RADIAL_SLIDER**</span></span>

<span data-ttu-id="a74b9-911">**GX_TYPE_MENU_LIST**</span><span class="sxs-lookup"><span data-stu-id="a74b9-911">**GX_TYPE_MENU_LIST**</span></span>

<span data-ttu-id="a74b9-912">**GX_TYPE_MENU**</span><span class="sxs-lookup"><span data-stu-id="a74b9-912">**GX_TYPE_MENU**</span></span>

<span data-ttu-id="a74b9-913">**GX_TYPE_ACCORDION_MENU**</span><span class="sxs-lookup"><span data-stu-id="a74b9-913">**GX_TYPE_ACCORDION_MENU**</span></span>

<span data-ttu-id="a74b9-914">**GX_TYPE_TREE_VIEW**</span><span class="sxs-lookup"><span data-stu-id="a74b9-914">**GX_TYPE_TREE_VIEW**</span></span>


### <a name="styles"></a><span data-ttu-id="a74b9-915">Stiller</span><span class="sxs-lookup"><span data-stu-id="a74b9-915">Styles</span></span>

<span data-ttu-id="a74b9-916">Pencere öğesi stilleri, kenarlık özellikleri (yükseltilmiş, ince, kalın veya hiç boarder) gibi özelliklerin yanı sıra daha önce listelenmiş belirli pencere öğesi türlerine yönelik özelliklerden oluşur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-916">Widget styles consist of things like border properties (raised, recessed, thin, thick, or no boarder at all) as well as properties for specific widget types, as listed previously.</span></span> <span data-ttu-id="a74b9-917">Pencere öğesi stili bayrakları, herhangi bir pencere öğesi görünümünü değiştirmek için en basit yöntemi sağlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-917">The widget style flags offer the simplest method for modifying the appearance of any widget.</span></span>
<span data-ttu-id="a74b9-918">İlk pencere öğesi stili her zaman pencere öğesi türüne özgü create işlevine geçirilen bir parametredir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-918">The initial widget style is always a parameter passed to the widget type specific create function.</span></span>

### <a name="colors"></a><span data-ttu-id="a74b9-919">Renkler</span><span class="sxs-lookup"><span data-stu-id="a74b9-919">Colors</span></span> 

<span data-ttu-id="a74b9-920">Pencere öğeleri, sistem renk tablosunda tanımlanan renkleri kullanarak kendilerini çizer.</span><span class="sxs-lookup"><span data-stu-id="a74b9-920">Widgets draw themselves using colors defined in the system color table.</span></span>
<span data-ttu-id="a74b9-921">Renk kimlikleri tuval arka planı, varsayılan pencere öğesi dolgu rengi, düğme dolgu rengi, metin pencere öğesi dolgu rengi, pencere dolgu rengi ve diğer birkaç varsayılan renk değeri için tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-921">Color IDs are defined for canvas background, default widget fill color, button fill color, text widget fill color, window fill color, and several other default color values.</span></span> <span data-ttu-id="a74b9-922">Ayrıca, **GX_WINDOW** pencere istemcisi doldurulurken bit eşlem veya duvar kağıdı görüntülemeyi destekler.</span><span class="sxs-lookup"><span data-stu-id="a74b9-922">In addition, **GX_WINDOW** objects support displaying a bitmap or wallpaper as the window client is filled.</span></span>

<span data-ttu-id="a74b9-923">Varsayılan renk düzenini değiştirmenin en basit yöntemi GUIX Studio'yu kullanmak ve gereksinimlerinizi karşılayacak bir renk düzeni oluşturmak veya tanımlamaktır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-923">The simplest method of changing the default color scheme is to use GUIX Studio and create or define a color scheme that meets your requirements.</span></span>
<span data-ttu-id="a74b9-924">Renk düzeninizi el ile tanımlamak için farklı değerlerden GX_COLOR api işlevini gx_system_color_table_set de tanımlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a74b9-924">You can also define your color scheme manually by creating an array of GX_COLOR values and invoking the gx_system_color_table_set API function.</span></span>

### <a name="event-notification"></a><span data-ttu-id="a74b9-925">Olay Bildirimi</span><span class="sxs-lookup"><span data-stu-id="a74b9-925">Event Notification</span></span> 

<span data-ttu-id="a74b9-926">GUIX olayları, kullanıcı girişi ve iç sistem durumu değişiklikleri pencere öğelerine bildirmeye yönelik belirli bir eylemi ve bildirimleri gerçekleştirmek üzere bir veya daha fazla pencere öğesine yapılan isteklerdir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-926">GUIX events are requests made to one or more widgets to perform a particular action and notifications to notify widgets of user input and internal system status changes.</span></span> <span data-ttu-id="a74b9-927">Örneğin, bir pencere öğesi odağında, **GX_EVENT_FOCUS_GAINED** ***API*** hizmeti aracılığıyla pencere gx_system_event_send gönderilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-927">For example, when a widget gains focus, the **GX_EVENT_FOCUS_GAINED** is sent to the widget via the ***gx_system_event_send*** API service.</span></span>

<span data-ttu-id="a74b9-928">Olaylar GUIX olay kuyruğu üzerinden geçirildiğini ve her olayın veri yapısının GX_EVENT **olduğunu.**</span><span class="sxs-lookup"><span data-stu-id="a74b9-928">Events are passed through the GUIX event queue, and each event is an instance of the **GX_EVENT** data structure.</span></span> <span data-ttu-id="a74b9-929">GX_EVENT  veri yapısı ***gx_api.h*** içinde tanımlanır, ancak yapının en önemli alanları **gx_event_type**, **gx_event_sender**, **gx_event_target** ve **gx_event_payload' dır.**</span><span class="sxs-lookup"><span data-stu-id="a74b9-929">The **GX_EVENT** data structure is defined in ***gx_api.h***, however the most important fields of the structure are the **gx_event_type**, **gx_event_sender**, **gx_event_target**, and **gx_event_payload**.</span></span>

<span data-ttu-id="a74b9-930">Gx_event_type  alanı, belirli bir olay sınıfını tanımlamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-930">The **gx_event_type** field is used to identify the particular event class.</span></span> <span data-ttu-id="a74b9-931">Olay türü, bunun bir olay mı yoksa GX_EVENT_PEN_DOWN **olay** mı **olduğunu** GX_EVENT_TIMER gösterir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-931">The event type indicates if this is, for example, a **GX_EVENT_PEN_DOWN** event or a **GX_EVENT_TIMER** event.</span></span> <span data-ttu-id="a74b9-932">Bu **gx_event_payload,** çeşitli veri alanlarının bir birliğidir ve her olay türü için geçerli değildir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-932">The **gx_event_payload** is a union of various data fields, and they are not all valid for every event type.</span></span>
<span data-ttu-id="a74b9-933">Diğer olay veri alanlarını incelemeden önce olay türü alanını kullanırsiniz.</span><span class="sxs-lookup"><span data-stu-id="a74b9-933">You use the event type field first, before examining the other event data fields.</span></span>

<span data-ttu-id="a74b9-934">Olay **gx_event_sender,** olay bir alt pencere öğesi bildirimi ise olayı oluşturan pencere öğesi kimliğini içerir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-934">The **gx_event_sender** field contains the ID of the widget that generated the event if the event is a child-widget notification.</span></span>

<span data-ttu-id="a74b9-935">Gx_event_target  alanı, kullanıcı tanımlı olayları belirli bir pencereye veya pencere öğesine yönlendirmek için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-935">The **gx_event_target** field can be used to route user-defined events to a particular window or widget.</span></span> <span data-ttu-id="a74b9-936">Belirli bir pencereye olay göndermek için pencereye benzersiz bir Kimlik değeri (pozitif bir şekilde belirlenecek şekilde) vermeli ve olay 00.000.000'de pencere kimliği değerini **gx_event_target** gerekir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-936">If you want to send an event to a particular window, you should give the window a unique Id value (so that it can be positively identified), and when building the event place the window Id value in the **gx_event_target** field.</span></span> <span data-ttu-id="a74b9-937">Hedef kimliği bilmiyorsanız veya olayın yalnızca giriş odağına sahip pencere öğesine yönlendir gx_event_target **emin** olun.</span><span class="sxs-lookup"><span data-stu-id="a74b9-937">If you don’t know the target Id or if you just want the event to be routed to the widget that has input focus, make sure to set the **gx_event_target** field to 0.</span></span>

<span data-ttu-id="a74b9-938">Son **olarak, gx_event_payload** alanı çeşitli veri türlerinin bir tarakıdır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-938">Finally, the **gx_event_payload** field is a union of various data types.</span></span> <span data-ttu-id="a74b9-939">Olay **GX_EVENT_PEN_DOWN** **GX_EVENT_PEN_UP** için, **gx_event_pointdata** alanı kalem konumunun x,y piksel koordinatı içerir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-939">For **GX_EVENT_PEN_DOWN** and **GX_EVENT_PEN_UP** events, the **gx_event_pointdata** field contains the x,y pixel coordinate the pen position.</span></span> <span data-ttu-id="a74b9-940">Zamanlayıcı olayları için **gx_event_timer_id** alanı süresi dolan zamanlayıcının kimliğini içerir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-940">For timer events, the **gx_event_timer_id** field contains the ID of the expired timer.</span></span> <span data-ttu-id="a74b9-941">Diğer yük veri alanları diğer olay türleri için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-941">Other payload data fields are utilized for other event types.</span></span> <span data-ttu-id="a74b9-942">Önceden tanımlanmış olay türlerinin ve yük alanlarının tam listesi Ek [E - GUIX](appendix-e.md)Olay Açıklamaları içinde tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-942">The complete list of pre-defined event types and their payload fields is defined in [Appendix E - GUIX Event Descriptions](appendix-e.md).</span></span>

<span data-ttu-id="a74b9-943">Uygulama ayrıca sabit değerden sonra sayısal olarak başlayan kendi özel olaylarını **GX_FIRST_APP_EVENT.**</span><span class="sxs-lookup"><span data-stu-id="a74b9-943">The application can also add its own custom events, starting numerically after the constant **GX_FIRST_APP_EVENT**.</span></span> <span data-ttu-id="a74b9-944">Bu sabitten sonra gelen tüm olay numaraları uygulamanın kullanımı için ayrılmıştır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-944">All event numbers after this constant are reserved for the application’s use.</span></span> <span data-ttu-id="a74b9-945">Elbette, uygulamanın pencere öğesi olay işleyicisi bu tür uygulama olayları için işlemeye sahip olmalı.</span><span class="sxs-lookup"><span data-stu-id="a74b9-945">Of course, the application’s widget event handler must have processing for such application events.</span></span>

### <a name="event-processing"></a><span data-ttu-id="a74b9-946">Olay İşleme</span><span class="sxs-lookup"><span data-stu-id="a74b9-946">Event Processing</span></span> 

<span data-ttu-id="a74b9-947">her pencere öğesi için, her bir pencere öğesi için varsayılan bir pencere öğesi olay işleme işlevi vardır ve ***gx_<türü>_event_process.***</span><span class="sxs-lookup"><span data-stu-id="a74b9-947">There is a default widget event processing function for each and every widget, named ***gx_<widget-type>_event_process***.</span></span> <span data-ttu-id="a74b9-948">Çoğu durumda, uygulamanın herhangi bir pencere öğesinde olay işleme konusunda endişelenmesi gerek değildir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-948">In most cases, the application won’t need to worry about the event handling of any given widget.</span></span> <span data-ttu-id="a74b9-949">Ancak, uygulamanın özel veya ek olay işleme gerektirdiği durumlarda, uygulama guiX API'si aracılığıyla varsayılan işleme işlevini kendi işleviyle geçersiz ***gx_widget_event_process_set.***</span><span class="sxs-lookup"><span data-stu-id="a74b9-949">However, in situations where the application requires custom or supplemental event processing, the application may override the default processing function with its own via the GUIX API ***gx_widget_event_process_set***.</span></span> <span data-ttu-id="a74b9-950">Bu işlev varsayılan olay işleme işlevini API'de belirtilen olay işlevi işleme işleviyle geçersiz kılar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-950">This function overrides the default event processing function with the event function processing function specified in the API.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="a74b9-951">Uygulama olay işleme işlevleri, varsayılan işlemenin yalnızca varsayılan çağrılarını doğrudan çağırarak (işlemeyi yinelemeden) ***gx_widget_event_process*** faydalanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a74b9-951">Application event processing functions can take advantage (i.e., not duplicate the processing) of the default processing by simply calling the default ***gx_widget_event_process*** processing directly.</span></span>

<span data-ttu-id="a74b9-952">Olay işleme özel olarak iç GUIX sistem iş parçacığı bağlamından çağrılır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-952">Event processing is called exclusively from the context of the internal GUIX system thread.</span></span> <span data-ttu-id="a74b9-953">Bu şekilde, olay işlemeyi işlemeye göre yığın gereksinimleri yalnızca GUIX iş parçacığı için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-953">In this way, the stack requirements to process the event handling only applies to the GUIX thread.</span></span>

### <a name="implementing-custom-event-processing-example"></a><span data-ttu-id="a74b9-954">Özel Olay İşleme Uygulama (örnek)</span><span class="sxs-lookup"><span data-stu-id="a74b9-954">Implementing Custom Event Processing (example)</span></span> 

<span data-ttu-id="a74b9-955">GUIX sisteminde herhangi bir pencere öğesi veya pencere için kendi olay işleme işlevinizi sebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a74b9-955">You can provide your own event processing function for any widget or window in the GUIX system.</span></span> <span data-ttu-id="a74b9-956">Kendi özel pencere öğesi türlerinizi oluşturuyorsanız, normalde pencere öğesi oluşturma işlevine özel olay işleyicinizi yükleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a74b9-956">If you are creating your own custom widget type, you will normally install your custom event handler in the widget creation function.</span></span> <span data-ttu-id="a74b9-957">Yalnızca mevcut bir pencere öğesi veya pencerenin çalışmasını genişletıyor veya değiştirerek, pencere öğesi veya pencere oluşturulduktan sonra gx_widget_event_process_set API işlevini çağırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a74b9-957">If you are just extending or modifying the operation of an existing widget or window, you can call the gx_widget_event_process_set API function after the widget or window has been created.</span></span> <span data-ttu-id="a74b9-958">Alt denetimleriniz tarafından oluşturulan olayları işleme amacıyla üst düzey pencerelerde (Ekranlar olarak da adlandırılan) neredeyse her zaman kendi olay işlemenizi sağlayacaktır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-958">You will almost always provide your own event handling for your top-level windows (also called Screens) in order to process events generated by your child controls.</span></span> <span data-ttu-id="a74b9-959">Bir ekranın alt denetimleri tarafından oluşturulan olayı işleme, GUIX uygulamanıza işlev eklemenin ana yolu olur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-959">Processing event generated by the child controls of a screen is the main way you add functionality to your GUIX application.</span></span>

<span data-ttu-id="a74b9-960">Örneğin, "main_menu" adlı bir üst düzey ekran tanımlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a74b9-960">As an example, suppose you define a top-level screen named “main_menu”.</span></span>
<span data-ttu-id="a74b9-961">Bu ekran GUIX Studio kullanılarak tanımlanabilir veya bu ekranı uygulama kodunda oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a74b9-961">This screen might be defined using GUIX Studio, or you might create this screen in your application code.</span></span> <span data-ttu-id="a74b9-962">Ekranı GUIX Studio'da tanımlarsanız, bu ekranın Studio özellikleri alanına olay işleyicinizin adını yazmanız gerekir ve Studio tarafından oluşturulan belirtimler kodu olay işleyicinizi otomatik olarak yüklenir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-962">If you define the screen within GUIX Studio, you simply type the name of your event handler in the Studio properties field for that screen, and the Studio generated specifications code will automatically install your event handler.</span></span> <span data-ttu-id="a74b9-963">Bu durumda, özel olay işleyicisini main_menu_event_handler ***ve*** aşağıdaki gibi kodla kodlamız gerekir:</span><span class="sxs-lookup"><span data-stu-id="a74b9-963">In this case, we will call the custom event handler ***main_menu_event_handler*** and it should be coded like this:</span></span>

```C
int main_menu_item; /* example: variable to keep track of selected item */

UINT main_menu_event_handler(GX_WINDOW *main_screen, GX_EVENT *event_ptr)
{
    UINT status = GX_SUCCESS;

    switch(event_ptr->gx_event_type)
    {
    /* this is an example for catching events from a child button */
    case GX_SIGNAL(IDB_CHILD_BUTTON, GX_EVENT_CLICKED):
        /* insert your button handler code here */
        break;

    case GX_EVENT_SHOW:
        /* add functionality to the show event handler */
        /* first, do default processing */
        status = gx_window_event_process(main_screen, event_ptr); /* note 1 */

        /* now add my own processing */
        main_menu_item = 0;
        break;

    default:
        /* pass all other events to base processing function */
        status = gx_window_event_process(main_screen, event_ptr); /* note 1 */
        break;
    }
    return status;
}
```

<span data-ttu-id="a74b9-964">Yukarıdaki örnekte, **GX_EVENT_SHOW** (bir durum değişikliğini bildirmek için dahili olarak oluşturulan olaylar) gibi sistem olayları için, normal işlemenin gerçekleşmesini sağlarken uygulamanın bu olayları temel pencere öğesi olay işleme işlevine geçmesi gerektiğini fark etmek önemlidir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-964">In the example above, it is important to notice that for system events like **GX_EVENT_SHOW** (events generated internally to notify a widget of a status change), the application must pass those events to the base widget event processing function to insure that the normal processing occurs.</span></span> <span data-ttu-id="a74b9-965">Uygulama daha sonra istediğiniz gibi ek mantık ekleyebilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-965">The application can then add additional logic as desired.</span></span> <span data-ttu-id="a74b9-966">Uygulama tarafından işlen tüm olaylar (yukarıdaki varsayılan durum) temel olay işleme işlevine de geçir gerekir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-966">All events that are not handled by the application (the default case above) should also be passed to the base event processing function.</span></span> <span data-ttu-id="a74b9-967">Bu örnek, GX_WINDOW tabanlı bir üst **düzey ekran** için olduğu için varsayılan olay işleme işlevi gx_window_event_process.</span><span class="sxs-lookup"><span data-stu-id="a74b9-967">Since this example was for a top-level screen based on **GX_WINDOW**, the default event processing function is gx_window_event_process.</span></span>

### <a name="drawing-function"></a><span data-ttu-id="a74b9-968">Drawing İşlevi</span><span class="sxs-lookup"><span data-stu-id="a74b9-968">Drawing Function</span></span> 

<span data-ttu-id="a74b9-969">Tüm pencere öğesi çizimi olay işlemeden ayrı olarak gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-969">All widget drawing is performed separately from the event handling.</span></span> <span data-ttu-id="a74b9-970">Çizim genellikle CPU döngüleri açısından pahalı olduğundan bu daha verimlidir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-970">This is more efficient because drawing is usually expensive in terms of CPU cycles.</span></span> <span data-ttu-id="a74b9-971">Ertelenen bir çizim algoritması uygulanarak, tüm bekleyen olaylar ve ilişkili görüntüleme değişiklikleri herhangi bir çizim tamamlanmadan tamamlanır ve böylece boşa harcanan çizim ortadan kaldırılamaz.</span><span class="sxs-lookup"><span data-stu-id="a74b9-971">By implementing a deferred drawing algorithm, all of the outstanding events and associated display changes can be completed before any drawing is done, thus eliminating wasted drawing.</span></span> <span data-ttu-id="a74b9-972">Olay işlemeye benzer şekilde, çoğu pencere öğesi için pencere öğesi türü gx_<adlı varsayılan bir pencere öğesi çizim ***işlevi vardır>_draw*** burada xxx pencere öğesi t type'tır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-972">Similar to event processing, there is a default widget drawing function for most widgets, named ***gx_<widget-type>_draw***, where xxx is the widget type.</span></span> <span data-ttu-id="a74b9-973">Çoğu durumda, uygulamanın herhangi bir pencere öğesi için çizim işlevi konusunda endişelenmesi gerek değildir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-973">In most cases, the application won’t need to worry about the drawing function of any given widget.</span></span> <span data-ttu-id="a74b9-974">Ancak, uygulamanın özel veya ek çizim gerektirdiği durumlarda uygulama, guiX API'si aracılığıyla varsayılan çizim işlevini kendi gx_widget_draw_set.</span><span class="sxs-lookup"><span data-stu-id="a74b9-974">However, in situations where the application requires custom or supplemental drawing, the application may override the default drawing function with its own via the GUIX API ***gx_widget_draw_set***.</span></span> <span data-ttu-id="a74b9-975">Bu işlev, uygulamanın herhangi bir pencere öğesi için kendi özelleştirilmiş çizim işlevini sağlamasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-975">This function allows the application to provide its own customized drawing function for any widget.</span></span> <span data-ttu-id="a74b9-976">Bu da uygulamanın yeni pencere öğesi türlerinin tamamını tanımlamasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-976">This further allows the application to define entire new widget types.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="a74b9-977">Uygulama çizimi işlevleri, yalnızca geçersiz kılınan çizim işlevinden çağırarak varsayılan çizimin avantajından (kodlamayı yinelemeden) faydalanabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-977">Application drawing functions can take advantage (i.e., not duplicate the coding) of the default drawing by simply calling it directly from the overridden drawing function.</span></span>

<span data-ttu-id="a74b9-978">Pencere öğesi çizimi özel olarak iç GUIX sistem iş parçacığı bağlamından çağrılır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-978">Widget drawing is called exclusively from the context of the internal GUIX system thread.</span></span> <span data-ttu-id="a74b9-979">Bu şekilde, çizimi gerçekleştirmek için zamanlama ve yığın gereksinimleri yalnızca GUIX iş parçacığı için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-979">In this way, the timing and stack requirements to perform the drawing only apply to the GUIX thread.</span></span>

### <a name="implementing-custom-drawing-example"></a><span data-ttu-id="a74b9-980">Özel Çizim Uygulama (örnek)</span><span class="sxs-lookup"><span data-stu-id="a74b9-980">Implementing Custom Drawing (example)</span></span> 

<span data-ttu-id="a74b9-981">Herhangi bir pencere öğesi için çizim işlevine, uygulama denetim bloğuna üye olan dolaylı işlev GX_WIDGET başvurur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-981">The drawing function for any widget is referenced through an indirect function pointer which is a member of the GX_WIDGET control block.</span></span> <span data-ttu-id="a74b9-982">Pencere öğesinizi tanımlamak için GUIX Studio kullanıyorsanız, pencere öğesi özelliklerinin "Çizim İşlevi" parametresine işlevinizin adını yazarak kendi işlev işaretçinizi yükleyebilirsiniz ve Studio, pencere öğesi oluşturulduğunda işlev işaretçinizi sizin için yükler.</span><span class="sxs-lookup"><span data-stu-id="a74b9-982">If you use GUIX Studio to define your widget, you can install your own function pointer simply by typing the name of your function in the “Drawing Function” parameter of the widget properties, and Studio will install your function pointer for you when the widget is created.</span></span> <span data-ttu-id="a74b9-983">Uygulama kodunda pencere öğesi oluşturursanız, pencere öğesi ***oluşturulduktan sonra gx_widget_draw_set*** çizim işlevinizi yüklemek için gx_widget_draw_set API işlevini kullansanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-983">If you create the widget in your application code, you must use the ***gx_widget_draw_set*** API function to install your custom drawing function after the widget has been created.</span></span>

<span data-ttu-id="a74b9-984">Bu örnekte, bir düğmenin görünümünü özelleştirmek istediğinizi varsayalım.</span><span class="sxs-lookup"><span data-stu-id="a74b9-984">For this example, let’s assume that you want to customize the appearance of a button.</span></span> <span data-ttu-id="a74b9-985">Düğme, GX_TEXT_BUTTON gibi görünüyor ancak düğmeye basıldığında düğmenin sağ orta kısmına küçük bir yeşil "LED_ON" bit eşlemi ve düğmeye basıldığında küçük bir "LED_OFF" bit eşlemi çizacağız.</span><span class="sxs-lookup"><span data-stu-id="a74b9-985">The button will look very much like a **GX_TEXT_BUTTON**, but we will add drawing a small green “LED_ON” bitmap in the middle-right portion of the button when the button is pressed, and small “LED_OFF” bitmap when the button is not pressed.</span></span> <span data-ttu-id="a74b9-986">Aşağıdaki çizimlere benzer bir düğme oluşturmak istiyorum.</span><span class="sxs-lookup"><span data-stu-id="a74b9-986">We want to create a button that looks like the illustrations below.</span></span>

![On için yeşil düğmenin ekran görüntüsü.](./media/guix/image4.jpg) <span data-ttu-id="a74b9-988">özel düğme "on"</span><span class="sxs-lookup"><span data-stu-id="a74b9-988">custom button “on”</span></span>

![Kapalı için kırmızı düğmenin ekran görüntüsü.](./media/guix/image5.jpg) <span data-ttu-id="a74b9-990">özel düğme "kapalı"</span><span class="sxs-lookup"><span data-stu-id="a74b9-990">custom button “off”</span></span>

<span data-ttu-id="a74b9-991">Bu örnekte aşağıdakine benzer bir düğme çizim işlevi yazabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a74b9-991">In this case, we would write a button drawing function that looks something like the following.</span></span>

```C
UINT my_button_draw(GX_TEXT_BUTTON *button)
{
    GX_PIXELMAP *map;
    ULONG button_style;
    INT xpos;
    INT ypos;

    /* first, do the normal text button drawing */
    gx_text_button_draw(button);

    /* now add our extra pixelmap */

    gx_widget_style_get(button, &button_style);

    if (button_style & GX_STYLE_BUTTON_PUSHED)
    {
        /* use the ON pixelmap */
        gx_context_pixelmap_get(GX_PIXELMAP_ID_LED_ON, &map);
    }
    else
    {
        /* use the OFF pixelmap */
        gx_context_pixelmap_get(GX_PIXELMAP_ID_LED_OFF, &map);
    }
    if (map)
    {
        /* draw it 20 pixels in from right edge */
        xpos = button->gx_widget_size.gx_rectangle_right;
        xpos -= map->gx_pixelmap_width + 20;

        /* and draw 10 pixels from the top edge */
        ypos = button->gx_widget_size.gx_rectangle_top + 10;

        /* draw the extra pixelmap on top of the button */
        gx_canvas_pixelmap_draw(xpos, ypos, map);
    }
}
```

## <a name="guix-drawing-context-component"></a><span data-ttu-id="a74b9-992">GUIX Çizim Bağlamı Bileşeni</span><span class="sxs-lookup"><span data-stu-id="a74b9-992">GUIX Drawing Context Component</span></span> 

<span data-ttu-id="a74b9-993">GuiX her tuval yenileme işlemini gerçekleştiriyor olduğu için çizim bağlamı çalışma zamanında dinamik olarak oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-993">The drawing context is created dynamically, at runtime, as GUIX performs each canvas refresh operation.</span></span> <span data-ttu-id="a74b9-994">Çizim bağlamı, geçerli çizim işlemlerini gerçekleştirmek için kullanılan tuvali, ekran sürücüsünü ve fırçayı bağlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-994">The drawing context ties together the canvas, screen driver, and brush being used to perform the current drawing operations.</span></span>

<span data-ttu-id="a74b9-995">Çizim bağlamı, GX_DRAW_CONTEXT **tanımlanır.**</span><span class="sxs-lookup"><span data-stu-id="a74b9-995">The drawing context is defined by the **GX_DRAW_CONTEXT** structure.</span></span>
<span data-ttu-id="a74b9-996">Bu yapı, geçerli çizim işlemi için kırpmayı ve görünümü tanımlayan, geçerli tuvali tanımlayan ve kullanılan geçerli ekran sürücüsünü tanımlayan değişkenleri içerir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-996">This structure contains variables that define the clipping and view of the current drawing operation, define the current canvas, and define the current screen driver in use.</span></span> <span data-ttu-id="a74b9-997">Bu **GX_DRAW_CONTEXT,** çizim için kullanılan fırçayı da tutar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-997">The **GX_DRAW_CONTEXT** structure also holds the brush being used for drawing.</span></span> <span data-ttu-id="a74b9-998">Draw bağlam fırça, doğrudan özel çizim işlevlerinde birlikte çalışabilirsiniz üyesidir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-998">The draw context brush is the member that you will work directly with in your custom drawing functions.</span></span> <span data-ttu-id="a74b9-999">Fırça yapısı aşağıdaki kodda gösterildiği gibi tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-999">The brush structure is defined as shown in the code below.</span></span>

```C
typedef struct GX_BRUSH_STRUCT
{
    GX_PIXELMAP *gx_brush_pixelmap;
    GX_FONT     *gx_brush_font;
    ULONG        gx_brush_line_pattern;
    ULONG        gx_brush_pattern_mask;
    GX_COLOR     gx_brush_fill_color;  
    GX_COLOR     gx_brush_line_color;  
    UINT         gx_brush_style;
    GX_VALUE     gx_brush_width;
    UCHAR        gx_brush_alpha;  
} GX_BRUSH;
```

<span data-ttu-id="a74b9-1000">Bu **gx_brush_pixelmap** dikdörtgen ve çokgen dolguları için kullanmak üzere bir piksel haritası tanımlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1000">The **gx_brush_pixelmap** field defines a pixelmap to use for rectangle and polygon fills.</span></span> <span data-ttu-id="a74b9-1001">Bu üye, gx_brush_style **stili** dahil **GX_BRUSH_PIXELMAP** kullanılmaz.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1001">This member is not used unless the **gx_brush_style** is includes the **GX_BRUSH_PIXELMAP** style.</span></span>

<span data-ttu-id="a74b9-1002">Bu **gx_brush_font,** metin çizimi için kullanılan yazı tipini tanımlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1002">The **gx_brush_font** member defines the font used for text drawing.</span></span>
<span data-ttu-id="a74b9-1003">Bu **gx_brush_line_pattern,** kesikli çizgiler için kullanılan deseni tanımlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1003">The **gx_brush_line_pattern** member defines the pattern used for dashed lines.</span></span>
<span data-ttu-id="a74b9-1004">Bu **gx_brush_style,** fırça özniteliklerini tam olarak tanımlamak için BIRLIKTE VEYA olan bir stil bayrakları kümesidir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1004">The **gx_brush_style** member is a set of style flags that can be OR’d together to fully define the brush attributes.</span></span> <span data-ttu-id="a74b9-1005">Kullanılabilir fırça stili bayrakları aşağıdakileri içerir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1005">The available brush style flags include the following.</span></span>

<span data-ttu-id="a74b9-1006">**GX_BRUSH_OUTLINE**</span><span class="sxs-lookup"><span data-stu-id="a74b9-1006">**GX_BRUSH_OUTLINE**</span></span>  
<span data-ttu-id="a74b9-1007">**GX_BRUSH_SOLID_FILL**</span><span class="sxs-lookup"><span data-stu-id="a74b9-1007">**GX_BRUSH_SOLID_FILL**</span></span>  
<span data-ttu-id="a74b9-1008">**GX_BRUSH_PIXELMAP_FILL**</span><span class="sxs-lookup"><span data-stu-id="a74b9-1008">**GX_BRUSH_PIXELMAP_FILL**</span></span>  
<span data-ttu-id="a74b9-1009">**GX_BRUSH_ALIAS**</span><span class="sxs-lookup"><span data-stu-id="a74b9-1009">**GX_BRUSH_ALIAS**</span></span>  
<span data-ttu-id="a74b9-1010">**GX_BRUSH_UNDERLINE**</span><span class="sxs-lookup"><span data-stu-id="a74b9-1010">**GX_BRUSH_UNDERLINE**</span></span>  
<span data-ttu-id="a74b9-1011">**GX_BRUSH_ROUND**</span><span class="sxs-lookup"><span data-stu-id="a74b9-1011">**GX_BRUSH_ROUND**</span></span>

<span data-ttu-id="a74b9-1012">Bu **gx_brush_width,** çizgi çizimi için ile satırı veya ana hatlı şekil çizimi için ana hat genişliğini tanımlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1012">The **gx_brush_width** member defines the line with for line drawing, or the outline width for outlined shape drawing.</span></span>

<span data-ttu-id="a74b9-1013">Bu **gx_brush_line_color,** çizgi çizimi ve metin çizimi için ön plan rengini tanımlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1013">The **gx_brush_line_color** member defines the foreground color for line drawing and for text drawing.</span></span>

<span data-ttu-id="a74b9-1014">Bu **gx_brush_fill_color,** şekil doldurma için kullanılan düz dolgu rengini tanımlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1014">The **gx_brush_fill_color** member defines the solid fill color used for shape filling.</span></span> <span data-ttu-id="a74b9-1015">GUIX bağlam bileşeni, etkin bağlamda geçerli fırçayı değiştirmeyi çok kolay hale etmek için tasarlanmış bir dizi API sağlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1015">The GUIX context component provides a set of APIs designed to make it very easy to modify the current brush within the active context.</span></span> <span data-ttu-id="a74b9-1016">Bu API'ler **gx_context_brush_define**, **gx_context_line_color_set**, **gx_context_fill_color_set**, **gx_context_font_set** ve diğerleridir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1016">These APIs include **gx_context_brush_define**, **gx_context_line_color_set**, **gx_context_fill_color_set**, **gx_context_font_set**, and many others.</span></span>

<span data-ttu-id="a74b9-1017">Üst nesnenin çizim bağlamı, nesnelerin alt öğesi tarafından devralınır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1017">The draw context of a parent object is inherited by the objects children.</span></span> <span data-ttu-id="a74b9-1018">Aslında üst çizim bağlamının bir kopyası, çizim işlevleri çağrıldığında alt nesneler tarafından devralınır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1018">Actually, a clone of the parent drawing context is inherited by the child objects when their drawing functions are invoked.</span></span> <span data-ttu-id="a74b9-1019">Alt öğe, üst çizimi etkilemeden bağlamı değiştirebilir, ancak istenirse üst öğeden fırça rengi ve stili gibi bilgileri devralabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1019">The child can modify the context without affecting the parent drawing, but it can also inherit information from the parent such as brush color and style if desired.</span></span>

## <a name="guix-window-component"></a><span data-ttu-id="a74b9-1020">GUIX Pencere Bileşeni</span><span class="sxs-lookup"><span data-stu-id="a74b9-1020">GUIX Window Component</span></span> 

<span data-ttu-id="a74b9-1021">GuiX'te tüm pencere işlemeden pencere bileşeni sorumludur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1021">The window component is responsible for all window processing in GUIX.</span></span> <span data-ttu-id="a74b9-1022">GUIX penceresi temelde bir veya daha fazla alt pencere öğesi içeren ayrı bir görüntüleme alanıdır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1022">A GUIX window is fundamentally a distinct display area that may contain one or more child widgets.</span></span> <span data-ttu-id="a74b9-1023">GUIX'te pencere aslında temel pencere öğesi nesnesinin özel bir biçimidir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1023">In GUIX, the window is actually just a special form of the fundamental widget object.</span></span>

<span data-ttu-id="a74b9-1024">GUIX pencereleri, devralmanın tam desteğiyle nesne odaklı bir şekilde uygulanır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1024">GUIX windows are implemented in an object oriented manner with full support of inheritance.</span></span> <span data-ttu-id="a74b9-1025">Bu, mümkün olan en küçük bellek ve işlem gereksinimleriyle sonuçlandıran ANSI C kullanılarak gereksinimlerini karşılar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1025">This is accomplished using ANSI C, which results in the smallest possible memory and processing requirements.</span></span>

<span data-ttu-id="a74b9-1026">GUIX pencereleri öncelikli olarak yatay ve dikey kaydırma desteği ekleyerek GUIX pencere öğesi işlevselliğini genişleter.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1026">GUIX windows extend the functionality of the GUIX widget primarily by adding support for horizontal and vertical scrolling.</span></span> <span data-ttu-id="a74b9-1027">GUIX penceresi nesneleri, kaydırma çubuklarını otomatik olarak oluşturabilir ve görüntüler ve kaydırma çubuğu girişine yanıt verir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1027">GUIX window objects can automatically create and display scroll bars and respond to scroll bar input.</span></span> <span data-ttu-id="a74b9-1028">Taşınabilir pencereler, pencerenin kalem girişi olaylarına göre taşınmasına veya sürüklenmesine olanak sağlayan yerleşik olay işlemeye de sahiptir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1028">Movable windows also have built in event handling to allow the window to be moved or dragged based on pen input events.</span></span>
<span data-ttu-id="a74b9-1029">Son olarak GUIX penceresi, pencereyi Z sırasına kadar hareket ettirerek giriş odağı almaya yanıt verir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1029">Finally, GUIX window responds to receiving input focus by moving the window to the front of the window Z-order.</span></span>

<span data-ttu-id="a74b9-1030">GUIX penceresi, pencere kenarlıkları ve kaydırma çubuğu gibi istemci olmayan nesneler kullanılabilir alandan kaldırıldıktan sonra pencerenin iç kısmı olan istemci alanı kavramını sürdürür.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1030">GUIX window maintains the concept of *client area*, which is the inner portion of the window once the window borders and non-client objects such as scrollbars are removed from the available area.</span></span> <span data-ttu-id="a74b9-1031">İstemci alanı alt pencere öğeleri pencere istemci alanına kırpılırken kaydırma çubukları gibi istemci olmayan alt öğeleri istemci alanı dışına çizmesine izin verilir, ancak yine de pencere dış boyutlarına kırpılır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1031">Client area child widgets are clipped to the window client area, while non-client children such as scroll bars are allowed to draw outside of the client area, but are still clipped to the window outer dimensions.</span></span>

<span data-ttu-id="a74b9-1032">Windows, alt öğenin özelliklerini üst öğeden devralınan bir üst-alt öğe olarak korunur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1032">Windows are maintained in a parent-child manner, where the children inherit characteristics from their parent.</span></span> <span data-ttu-id="a74b9-1033">Alt pencerelerin kendi alt pencereleri olabilir ve yine üst pencereden çeşitli özellikleri devralır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1033">Children windows may have their own child windows, again inheriting various characteristics from the parent.</span></span> <span data-ttu-id="a74b9-1034">Herhangi bir pencerenin özellikleri, çeşitli GUIX API çağrıları aracılığıyla açıkça yeniden tanımlandı olabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1034">The characteristics of any window may be explicitly redefined via various GUIX API calls.</span></span>

### <a name="window-creation"></a><span data-ttu-id="a74b9-1035">Pencere Oluşturma</span><span class="sxs-lookup"><span data-stu-id="a74b9-1035">Window Creation</span></span> 

<span data-ttu-id="a74b9-1036">Başlatma sırasında veya uygulama iş parçacıklarının yürütülmesi sırasında herhangi bir zamanda bir pencere nesnesi oluşturulabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1036">A window object can be created during initialization or anytime during the execution of application threads.</span></span> <span data-ttu-id="a74b9-1037">Bir uygulama tarafından oluşturulacak pencere nesnelerinin sayısına bir sınır yoktur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1037">There is no limit on the number of window objects that can be created by an application.</span></span> <span data-ttu-id="a74b9-1038">Ayrıca, herhangi bir pencerenin sahip olduğu çocuk sayısıyla ilgili bir sınır da yoktur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1038">There is also no limit on the number of children any window may have.</span></span>

### <a name="window-control-block"></a><span data-ttu-id="a74b9-1039">Pencere Denetim Bloğu</span><span class="sxs-lookup"><span data-stu-id="a74b9-1039">Window Control Block</span></span> 

<span data-ttu-id="a74b9-1040">Her pencere nesnesinin özellikleri, denetim bloğu  GX_WINDOW bulunur ve **_gx_api.h içinde tanımlanır._**</span><span class="sxs-lookup"><span data-stu-id="a74b9-1040">The characteristics of each window object are found in its control block **GX_WINDOW** and are defined in **_gx_api.h_**.</span></span> <span data-ttu-id="a74b9-1041">Bir pencere nesnesi için gereken bellek uygulama tarafından sağlanır ve bellekte herhangi bir yerde yer alıyor olabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1041">The memory required for a window object is provided by the application and can be located anywhere in memory.</span></span> <span data-ttu-id="a74b9-1042">Ancak, pencere nesnesi denetim bloğu herhangi bir işlevin kapsamı dışında tanımlayarak genel bir yapı yapmak en yaygındır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1042">However, it is most common to make the window object control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="root-window"></a><span data-ttu-id="a74b9-1043">Kök Pencere</span><span class="sxs-lookup"><span data-stu-id="a74b9-1043">Root Window</span></span> 

<span data-ttu-id="a74b9-1044">GUIX, her tuval için kök pencere olarak adlandırılan bir pencere gerektirir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1044">GUIX requires what is called a root window for each canvas.</span></span> <span data-ttu-id="a74b9-1045">Kök pencere kenarlıksızdır ve ekli olduğu tuvalle aynı boyutlara sahiptir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1045">The root window is borderless and has the same dimensions as the canvas to which it is attached.</span></span> <span data-ttu-id="a74b9-1046">Öncelikli olarak tüm birinci düzey pencere öğeleri ve pencereler için kapsayıcı olarak kullanılır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1046">It is used primarily as a container for all first-level widgets and windows.</span></span> <span data-ttu-id="a74b9-1047">Kök pencere genellikle ekran ve tuval oluşturulduktan kısa bir ***süre gx_window_root_create*** API işlevi aracılığıyla uygulama tarafından oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1047">The root window is typically created by the application via the API function ***gx_window_root_create***, shortly after the creation of the screen and canvas.</span></span> <span data-ttu-id="a74b9-1048">Studio tarafından oluşturulan işlevi gx_studio_display_configure, kök pencerenin adresi bu işleve son parametre olarak geçirilen konumda döndürülebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1048">If you use the Studio generated function gx_studio_display_configure, the address of the root window can be returned in the location passed as the last parameter to this function.</span></span>

<span data-ttu-id="a74b9-1049">Kök pencere varsayılan olarak taşınamaz olur ve en basit durumda kök pencere tuvalin boyutudur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1049">A root window defaults to being un-moveable, and in the simplest case the root window is the size of the canvas.</span></span> <span data-ttu-id="a74b9-1050">Kök pencere, görünen arka plan rengini değiştirmek veya arka plan duvar kağıdını görüntülemek için kök pencereye bir renk veya duvar kağıdı atarsınız.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1050">The root window in effect draws the display background, so to change the display background color or to display background wallpaper you would assign a color or wallpaper to the root window.</span></span>

<span data-ttu-id="a74b9-1051">Bir kök pencere taşınabilir durumda ise, tuvalin alt pencere gibi konumunu değiştirerek değil tuvalin kendisini hareket ettirerek taşır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1051">If a root window is moveable, it moves not by changing its position on the canvas as a child window would do, but by moving the canvas itself.</span></span>
<span data-ttu-id="a74b9-1052">Bu özellik, GUIX kök penceresinin donanım uzaklığı yazmazları ile birden çok çerçeve arabelleği destekleyen donanımdan faydalanmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1052">This feature allows the GUIX root window to leverage hardware that supports multiple frame buffers with hardware offset registers.</span></span>

### <a name="background"></a><span data-ttu-id="a74b9-1053">Arka Plan</span><span class="sxs-lookup"><span data-stu-id="a74b9-1053">Background</span></span> 

<span data-ttu-id="a74b9-1054">Pencere arka planları düz renkler veya bit eşlem görüntüleridir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1054">Window backgrounds are either solid colors or bitmap images.</span></span> <span data-ttu-id="a74b9-1055">Sistem düzeyinde, ilk pencere kümesi için varsayılan değeri sağlayan varsayılan bir pencere arka planı vardır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1055">There is a default window background at the system level which provides the default for the initial set of windows.</span></span> <span data-ttu-id="a74b9-1056">Elbette, herhangi bir pencere arka planı GUIX API'si aracılığıyla değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1056">Of course, any window background can be changed via the GUIX API.</span></span>

<span data-ttu-id="a74b9-1057">Bir pencerenin düz renk arka planını değiştirmek için Gx_widget_fill_color_set ***API'sini*** kullanın.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1057">To change the solid color background of a window, use the ***gx_widget_fill_color_set*** API.</span></span> <span data-ttu-id="a74b9-1058">Pencereye arka plan duvar kağıdı atamak için Gx_window_wallpaper_set ***API'sini*** kullanın.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1058">To assign a background wallpaper to a window, use the ***gx_window_wallpaper_set*** API.</span></span>

### <a name="scrolling"></a><span data-ttu-id="a74b9-1059">Kaydırma</span><span class="sxs-lookup"><span data-stu-id="a74b9-1059">Scrolling</span></span> 

<span data-ttu-id="a74b9-1060">GUIX, alt pencereyi görüntülemek için gereken alan pencerenin geçerli boyutunu (yatay ve/veya dikey) aştıklarında standart pencere kaydırmayı destekler.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1060">GUIX supports standard window scrolling when area required to display the window children exceeds the current size of the window – horizontally and/or vertically.</span></span> <span data-ttu-id="a74b9-1061">Kaydırmayı etkinleştirmek için uygulamanın istenen kaydırma çubuklarını oluşturması ve pencereye eklemesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1061">To enable scrolling, the application must create the desired scroll bars and attach them to the window.</span></span>

<span data-ttu-id="a74b9-1062">GUIX pencere bileşeni, pencere istemci alanı boyutuna ve tüm alt pencere öğelerinin kapsamına göre varsayılan bir kaydırma uygulaması sağlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1062">The GUIX window component provides a default scrolling implementation based on the size of the window client area and the extent of the all child widgets.</span></span> <span data-ttu-id="a74b9-1063">Uygulamalar ayrıca belirli bir pencere için uygulama işlevini geçersiz karak kendi gx_window_scroll_info_get ***uygulamalarını*** ve yorumlarını da sağlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1063">Applications can also provide their own scrolling implementation and interpretation by overriding the ***gx_window_scroll_info_get*** function for a particular window.</span></span>

### <a name="event-notification"></a><span data-ttu-id="a74b9-1064">Olay Bildirimi</span><span class="sxs-lookup"><span data-stu-id="a74b9-1064">Event Notification</span></span> 

<span data-ttu-id="a74b9-1065">Varsayılan pencere olay işleme işlevi, birincil olarak GX_WIDGET ve boyutlandırma olaylarının işlenmesinde olay işlemeden farklıdır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1065">The default window event processing function differs from the GX_WIDGET event processing primarily in the handling of scrolling and sizing events.</span></span> <span data-ttu-id="a74b9-1066">GX_WINDOW kaydırma ve boyutlandırma olayları için tek tek işleyiciler sağladınız.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1066">GX_WINDOW provided defalt handlers for scrolling and sizing events.</span></span>

<span data-ttu-id="a74b9-1067">Uygulama ayrıca sabit değerden sonra sayısal olarak başlayan kendi özel olaylarını **GX_FIRST_APP_EVENT.**</span><span class="sxs-lookup"><span data-stu-id="a74b9-1067">The application can also add its own custom events, starting numerically after the constant **GX_FIRST_APP_EVENT**.</span></span> <span data-ttu-id="a74b9-1068">Bu sabitten sonra gelen tüm olay numaraları uygulamanın kullanımı için ayrılmıştır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1068">All event numbers after this constant are reserved for the application’s use.</span></span> <span data-ttu-id="a74b9-1069">Elbette, uygulamanın pencere olay işleyicisi bu tür uygulama olayları için işlemeye sahip olmalı.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1069">Of course, the application’s window event handler must have processing for such application events.</span></span>

### <a name="event-processing"></a><span data-ttu-id="a74b9-1070">Olay İşleme</span><span class="sxs-lookup"><span data-stu-id="a74b9-1070">Event Processing</span></span> 

<span data-ttu-id="a74b9-1071">Diğer tüm pencere öğesi türlerinde olduğu gibi, her pencere için gx_window_event_process adlı bir ***varsayılan pencere olay işleme işlevi vardır.***</span><span class="sxs-lookup"><span data-stu-id="a74b9-1071">Just like all other widget types, there is a default window event processing function for every window, named ***gx_window_event_process***.</span></span> <span data-ttu-id="a74b9-1072">Bu olay işleme işlevini genellikle kendi olay işleyiciniz ile, kendi oluştursanız pencerelerde geçersiz kılar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1072">You will usually override this event handling function with your own event handler in the windows that you create.</span></span> <span data-ttu-id="a74b9-1073">Olaylara bu şekilde yanıt verir ve pencere alt denetimleri tarafından oluşturulan olaylara göre eyleme geçebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1073">This is how you will respond to events and take action based on events generated by the window child controls.</span></span>

<span data-ttu-id="a74b9-1074">Olay işleyicisine ek olarak varsayılan ***olay*** işlemenin gerçekleşmesine izin vermek üzere bu olay işleyicisini geçersiz kılarsanız GUIX sistem olayları için temel gx_window_event_process işlevini çağırmayı unutmayın.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1074">It is important to remember to invoke the base ***gx_window_event_process*** function for GUIX system events if you override that event handler, to allow the default event handling to occur in addition to whatever action you are adding to the event handler.</span></span> <span data-ttu-id="a74b9-1075">Örneğin, GX_EVENT_SHOW olayı için özel  bir işleyici sağlarsanız ve bu olayı gx_window_event_process'a geçemezsiniz, pencereniz hiçbir zaman görünür olmaz.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1075">For example if you provide a custom handler for the **GX_EVENT_SHOW** event, and do not pass this event to ***gx_window_event_process***, your window will never become visible.</span></span>
<span data-ttu-id="a74b9-1076">Bir pencereye özel olay işleyicisi sağlamak için olay ***gx_widget_event_process_set*** adresini tanımlamak üzere gx_widget_event_process_set işlevini kullanın.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1076">To provide a custom event handler for a window, use the ***gx_widget_event_process_set*** function to define the address of your event handler.</span></span> <span data-ttu-id="a74b9-1077">Bu işlev varsayılan olay işleme işlevini API'de belirtilen olay işlevi işleme işleviyle geçersiz kılar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1077">This function overrides the default event processing function with the event function processing function specified in the API.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="a74b9-1078">Uygulama olay işleme işlevleri, varsayılan işlemden yalnızca varsayılan değeri doğrudan çağırarak (işlemeyi yinelemeden) ***gx_window_event_process*** olabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1078">Application event processing functions can take advantage (i.e., not duplicate the processing) of the default processing by simply calling the default ***gx_window_event_process*** directly.</span></span>

<span data-ttu-id="a74b9-1079">Olay işleme özel olarak iç GUIX sistem iş parçacığı bağlamından çağrılır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1079">Event processing is called exclusively from the context of the internal GUIX system thread.</span></span> <span data-ttu-id="a74b9-1080">Bu şekilde, olay işlemeyi işlemeye göre yığın gereksinimleri yalnızca GUIX iş parçacığı için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1080">In this way, the stack requirements to process the event handling only applies to the GUIX thread.</span></span>

## <a name="guix-image-reader-component"></a><span data-ttu-id="a74b9-1081">GUIX Görüntü Okuyucu Bileşeni</span><span class="sxs-lookup"><span data-stu-id="a74b9-1081">GUIX Image Reader Component</span></span> 

<span data-ttu-id="a74b9-1082">Görüntü okuyucu bileşeni ham sıkıştırılmış görüntüleri GUIX piksel haritası biçiminde sıkıştırmak için yardımcı programlar ve API işlevleri sağlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1082">The image reader component provides utilities and API functions to decompress raw compressed images to GUIX pixelmap format.</span></span> <span data-ttu-id="a74b9-1083">JPEG ve PNG biçimli ham görüntü verileri, gelecek sürümler için ayrılmış ek biçimlerle birlikte de desteklemektedir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1083">JPEG and PNG format raw image data are supported, with additional formats reserved for future releases.</span></span>

<span data-ttu-id="a74b9-1084">GUIX uygulamalarının büyük çoğunluğunda GUIX Görüntü Okuyucusu bileşeninin gerekli olmadığını unutmayın.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1084">Note that for the vast majority of GUIX applications, the GUIX Image Reader component is not required.</span></span> <span data-ttu-id="a74b9-1085">Çoğu uygulama, JPEG ve PNG biçimli grafik varlıklarını GUIX uyumlu grafik varlıklarına dönüştürmek için GUIX Studio **GX_PIXELMAP** kullanır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1085">Most applications rely on the GUIX Studio application to convert JPEG and PNG format graphics assets into GUIX compatible **GX_PIXELMAP** resources.</span></span> <span data-ttu-id="a74b9-1086">GUIX görüntü okuyucusu bileşeni, ham grafik varlıkları yalnızca çalışma zamanında bilindiği zaman veya sistem depolama kısıtlamaları kaynakların farklı biçimde **depolanmasına engel GX_PIXELMAP** kullanılır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1086">The GUIX image reader component is utilized when the raw graphics assets are known only at runtime, or when the system storage constraints prevent storing resources in **GX_PIXELMAP** format.</span></span> <span data-ttu-id="a74b9-1087">JPEG ve PNG biçimli görüntü  verileri genellikle GX_PIXELMAP biçimine göre daha küçük olur, ancak bu görüntü türlerinin sıkıştırmayı ve renk alanı dönüştürmesini dinamik olarak gerçekleştirmeyle ilişkili önemli bir çalışma zamanı yükü vardır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1087">JPEG and PNG format image data is generally more compact than **GX_PIXELMAP** format, however there is considerable runtime overhead associated with performing decompression and color space conversion of these image types dynamically.</span></span>

<span data-ttu-id="a74b9-1088">Ham biçimLI JPEG veya PNG görüntüleri gx_canvas_pixelmap_draw API işlevine geçirilebiliyorsa GUIX, JPEG veya PNG verilerini dinamik olarak sıkıştırmasını ve çekmesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1088">If raw format JPEG or PNG images are passed to the gx_canvas_pixelmap_draw API function, GUIX dynamically decompresses and draws the JPEG or PNG data.</span></span> <span data-ttu-id="a74b9-1089">Bunun çalışma zamanı çizim hızı üzerinde önemli bir olumsuz etkisi olduğunu ve donanım destekli JPEG veya PNG sıkıştırmayı destekleyen bir donanım hedefi kullanmadıkça HAM biçimli görüntü verilerini gx_canvas_pixelmap_draw işlevine geçirmenin öneril olmadığını unutmayın.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1089">Note that this will have a significant negative impact on runtime drawing speed, and passing RAW format image data to the gx_canvas_pixelmap_draw function is not recommended unless you are using a hardware target that supports hardware assisted JPEG or PNG decompression.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="a74b9-1090">Ham JPEG veya PNG biçimli görüntülerin gx_canvas_pixelmap_draw ÇOĞU hedef donanım için önemli bir çalışma zamanı yüküne neden olur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1090">Passing raw JPEG or PNG formatted images to the gx_canvas_pixelmap_draw API incurs significant runtime overhead for most target hardware.</span></span>

<span data-ttu-id="a74b9-1091">Alternatif olarak, ham JPEG ve PNG verileri, Görüntü Okuyucusu bileşeni GX_PIXELMAP çalışma zamanında farklı bir biçime dönüştürülebiliyor.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1091">As an alternative, raw JPEG and PNG data may be converted to GX_PIXELMAP format at runtime using the Image Reader component.</span></span>
<span data-ttu-id="a74b9-1092">Bu şekilde üretilen piksel haritaları, Studio tarafından üretilen ve kaynak dosyanız içinde yer alan piksel haritaları gibi kullanılabilir ve çizilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1092">Pixelmaps produced in this way can be used and drawn just like pixelmaps produced by Studio and contained within your resource file.</span></span> <span data-ttu-id="a74b9-1093">Bu, görüntünün her çizilirken bu işlemleri gerçekleştirmek yerine, uygulamanın görüntü sıkıştırıcı, dithering ve renk alanı dönüştürme işlemini bir kez (genellikle program başlatma sırasında) gerçekleştirmenize olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1093">This allows your application to perform the image decompression, dithering, and color space conversion one time (usually during program startup) rather than performing these operations each time the image is drawn.</span></span>

<span data-ttu-id="a74b9-1094">Görüntü Okuyucusu bileşen işlevleri şunlardır:</span><span class="sxs-lookup"><span data-stu-id="a74b9-1094">The Image Reader component functions include:</span></span>

<span data-ttu-id="a74b9-1095">***gx_image_reader_create***</span><span class="sxs-lookup"><span data-stu-id="a74b9-1095">***gx_image_reader_create***</span></span>  
<span data-ttu-id="a74b9-1096">***gx_image_reader_palette_set***</span><span class="sxs-lookup"><span data-stu-id="a74b9-1096">***gx_image_reader_palette_set***</span></span>  
<span data-ttu-id="a74b9-1097">***gx_image_reader_start***</span><span class="sxs-lookup"><span data-stu-id="a74b9-1097">***gx_image_reader_start***</span></span>

## <a name="guix-animation-component"></a><span data-ttu-id="a74b9-1098">GUIX Animasyon Bileşeni</span><span class="sxs-lookup"><span data-stu-id="a74b9-1098">GUIX Animation Component</span></span> 

<span data-ttu-id="a74b9-1099">GUIX Animasyon bileşeni, ekran ve pencere öğesi geçiş otomasyonlarını otomatikleştirmek için kullanılan işlev ve hizmetler kümesidir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1099">The GUIX Animation component is a set of functions and services used to automate screen and widget transition automations.</span></span> <span data-ttu-id="a74b9-1100">GUIX Animasyon bileşeni, herhangi bir pencere öğesi türünün soğutunu, soluk sildiğini ve hareket ya da slayt türü animasyonlarını destekler.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1100">The GUIX Animation component supports fading in, fading out, and movement or slide type animations of any widget type.</span></span>

<span data-ttu-id="a74b9-1101">Soldurma türü animasyonlar, soğutan pencere öğeleri iç alfa değerinin **(GX_BRUSH_ALPHA_SUPPORT** etkinse) değişiklik göstererek veya herhangi bir pencere öğesi koleksiyonunu arka planla karıştırıldıkları zaman ayrı bir bellek tuvale çizerek destek olabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1101">Fade type animations can be supported either by varying the fading widget(s) internal alpha value (if **GX_BRUSH_ALPHA_SUPPORT** is enabled), or by drawing any collection of widgets to a separate memory canvas when is then blended with the background.</span></span> <span data-ttu-id="a74b9-1102">Birden çok donanım grafik katmanını destekleyen donanım hedefleri için, düz soğutma etkilerine yönelik destek, genellikle çok az çekirdek CPU bant genişliği gereken bu tuval karıştırma yaklaşımı kullanılarak en iyi şekilde gereksinimlerini karşılar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1102">For hardware targets that support multiple hardware graphics layers, support for smooth fading effects is best accomplished using this canvas blending approach, often with very little core CPU bandwidth required.</span></span> <span data-ttu-id="a74b9-1103">Birden çok grafik katmanını desteklemeen donanım hedefleri için GUIX fırça alfa değerini kullanarak karıştırma, 16 bpp ve daha yüksek renk derinliğinde çalıştırıldıklarında değerini destekler.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1103">For hardware targets that do not support multiple graphics layers, blending using the GUIX brush alpha value is supported when running at 16 bpp and higher color depths.</span></span>

<span data-ttu-id="a74b9-1104">Bir animasyonun ayrı bir çizim tuvali kullanması gerekirse GUIX Animasyon bileşeni bu amaçla API gx_animation_canvas_define hizmetini sağlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1104">If an animation should use a separate drawing canvas, the GUIX Animation component provides the API service gx_animation_canvas_define for this purpose.</span></span> <span data-ttu-id="a74b9-1105">Diğer animasyon türleri ayrı bir tuval gerektirmez, ancak varsa bunu kullanır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1105">Other animation types do not require a separate canvas, but they will utilize it if it is available.</span></span> <span data-ttu-id="a74b9-1106">Bu, birden çok donanım yüzeyi için temel donanım desteğinin mümkün olan en iyi şekilde kullanımını sağlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1106">This makes the best possible use of any underlying hardware support for multiple hardware surfaces.</span></span>

<span data-ttu-id="a74b9-1107">Animasyonu denetleyen değişkenler iki denetim bloğu tarafından tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1107">The variables controlling an animation are defined by two control blocks.</span></span> <span data-ttu-id="a74b9-1108">İlk olarak **GX_ANIMATION** denetleyicisini tanımlayan denetim bloğu.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1108">First, the **GX_ANIMATION** control block which defines the animation controller.</span></span> <span data-ttu-id="a74b9-1109">Animasyon denetleyicisi, tanımladığınız animasyon dizisini yürüten sürücü altyapısıdır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1109">The animation controller is the driving engine that executes the animation sequence you define.</span></span> <span data-ttu-id="a74b9-1110">Tek bir animasyon denetleyicisi birçok farklı animasyon dizisini çalıştırmak için birçok kez yeniden kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1110">A single animation controller can be re-used many times to run many different animation sequences.</span></span> <span data-ttu-id="a74b9-1111">Birden çok animasyon dizisini aynı anda çalıştırmanızı gerekirse, birden çok animasyon **GX_ANIMATION** oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1111">If you need to run multiple animation sequences simultaneously, you can create multiple **GX_ANIMATION** animation controllers.</span></span>

<span data-ttu-id="a74b9-1112">GUIX sistem bileşeni, **ve** animasyon gerektiğinde uygulama tarafından istenebilecek ve animasyon sırası tamamlandığında otomatik olarak sistem havuzuna döndürülen GX_ANIMATION denetim yapılarının yeniden kullanılabilir bir bloğu sağlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1112">The GUIX system component can provide a re-usable block of **GX_ANIMATION** control structures, which can be requested by the application when and animation is needed and are automatically returned to the system pool when the animation sequence is completed.</span></span> <span data-ttu-id="a74b9-1113">Bu, uygulamayı uygulanan her animasyon için **GX_ANIMATION** statik olarak bir uygulama yapısı tanımlamadan serbest bırakmaktadır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1113">This frees the application from statically defining a **GX_ANIMATION** structure for every animation that might be implemented.</span></span> <span data-ttu-id="a74b9-1114">Bu GX_ANIMATION havuzu  boyutu, varsayılan değer **6** olan GX_ANIMATION_POOL_SIZE sabiti tarafından tanımlanır ve bu da varsayılan olarak sistem havuzundan varsayılan olarak 6 eş zamanlı animasyon ayırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1114">The size of this pool of **GX_ANIMATION** structures is defined by the constant **GX_ANIMATION_POOL_SIZE**, which defaults to 6, meaning that by default 6 simultaneous animations can be allocated from the system pool.</span></span> <span data-ttu-id="a74b9-1115">Bu sabit elbette gx_user.h üst bilgi dosyasında yeniden tanımlanabilir, daha eş zamanlı animasyonlar gerekir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1115">This constant can of course be re-defined in the gx_user.h header file is more simultaneous animations are required.</span></span> <span data-ttu-id="a74b9-1116">Bu **GX_ANIMATION_POOL_SIZE** sıfır olarak ayarlanırsa GUIX sistem bileşeni bir animasyon havuzu veya ilgili hizmetler sağlamaz.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1116">If **GX_ANIMATION_POOL_SIZE** is set to zero, then the GUIX system component does not provide an animation pool or related services.</span></span>

<span data-ttu-id="a74b9-1117">Animasyon tanımlamak için kullanılan ikinci denetim bloğu veya yapısı, **GX_ANIMATION_INFO** yapısıdır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1117">The second control block or structure used to define an animation is the **GX_ANIMATION_INFO** structure.</span></span> <span data-ttu-id="a74b9-1118">Bu yapı, belirli bir animasyon dizisini tanımlamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1118">This structure is used to define one particular animation sequence.</span></span> <span data-ttu-id="a74b9-1119">Api hizmetini kullanarak bir animasyon dizisi başlatmak için bu bilgi yapısını animasyon gx_animation_start iletirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1119">You pass this information structure to your animation controller to initiate an animation sequence using the gx_animation_start API service.</span></span> <span data-ttu-id="a74b9-1120">Aşağıdaki **GX_ANIMATION_INFO** aşağıdaki alanları içerir:</span><span class="sxs-lookup"><span data-stu-id="a74b9-1120">The **GX_ANIMATION_INFO** structure contains the following fields:</span></span>

```C
typedef struct GX_ANIMATION_INFO_STRUCT
{
    GX_WIDGET *gx_animation_target;
    GX_WIDGET *gx_animation_parent;
    GX_WIDGET *gx_animation_screen_list;
    USHORT gx_animation_style;
    USHORT gx_animation_id;
    USHORT gx_animation_start_delay;
    USHORT gx_animation_frame_interval;
    GX_POINT gx_animation_start_position;
    GX_POINT gx_animation_end_position;
    GX_UBYTE gx_animation_start_alpha;
    GX_UBYTE gx_animation_end_alpha;
    GX_UBYTE gx_animation_steps;
} GX_ANIMATION_INFO;
```

<span data-ttu-id="a74b9-1121">Bu **gx_animation_target** animasyon denetleyicisinin üzerinde davranacak hedef pencere öğesi tanımlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1121">The **gx_animation_target** member defines the target widget that the animation controller will act upon.</span></span>

<span data-ttu-id="a74b9-1122">Bu **gx_animation_parent,** animasyon dizisi tamamlandığında hedef pencere öğesi ekli olacak üst pencere öğesi (varsa) tanımlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1122">The **gx_animation_parent** member defines the parent widget, if any, to which the target widget will be attached when the animation sequence is complete.</span></span> <span data-ttu-id="a74b9-1123">Bu gx_animation_parent, animasyon tamamlandığında oluşturulan GX_ANIMATION_COMPLETE olay da alıcıdır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1123">The gx_animation_parent is also the recipient of the GX_ANIMATION_COMPLETE event that is generated when an animation is completed.</span></span>

<span data-ttu-id="a74b9-1124">Bu **gx_animation_screen_list,** kalem girişi odaklı ekran slayt animasyonları için bir pencere öğesi listesi tanımlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1124">The **gx_animation_screen_list** member defines a widget list for pen-input-driven screen slide animations.</span></span> <span data-ttu-id="a74b9-1125">Widge listesi, GX_NULL işaretçisi ile sonlandırılmalı ve listede yer alan her pencere öğesi, gx_animation_parent.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1125">The widge list should be terminated with GX_NULL pointer, and each widget in the list should have the same x,y dimensions as the gx_animation_parent.</span></span>

<span data-ttu-id="a74b9-1126">Bu **gx_animation_style** gerçekleştirilecek animasyon türünü ve ilişkili seçenekleri tanımlayan bir bit maskesidir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1126">The **gx_animation_style** is a bitmask defining the type of animation to be performed and associated options.</span></span> <span data-ttu-id="a74b9-1127">Animasyon stili bayrakları aşağıdakileri içerir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1127">The animation style flags include the following.</span></span>

| <span data-ttu-id="a74b9-1128">Animasyon &nbsp; Stili &nbsp; Bayrağı</span><span class="sxs-lookup"><span data-stu-id="a74b9-1128">Animation&nbsp;Style&nbsp;Flag</span></span> | <span data-ttu-id="a74b9-1129">Açıklama</span><span class="sxs-lookup"><span data-stu-id="a74b9-1129">Description</span></span> |
| --- | --- |
| <span data-ttu-id="a74b9-1130">GX_ANIMATION_TRANSLATE</span><span class="sxs-lookup"><span data-stu-id="a74b9-1130">GX_ANIMATION_TRANSLATE</span></span> | <span data-ttu-id="a74b9-1131">Slayt veya soldurma türü animasyonu ister.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1131">Request a slide or fade type animation.</span></span> |
| <span data-ttu-id="a74b9-1132">GX_ANIMATION_SCREEN_DRAG</span><span class="sxs-lookup"><span data-stu-id="a74b9-1132">GX_ANIMATION_SCREEN_DRAG</span></span> | <span data-ttu-id="a74b9-1133">Kalem girişi odaklı ekran sürükleme animasyonu isteği.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1133">Request a pen-input driven screen drag animation.</span></span> |

<span data-ttu-id="a74b9-1134">Aşağıdaki bayraklar, farklı tür **animasyonlarıyla SCREEN_DRAG** kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1134">The following flags can be used in combination with **SCREEN_DRAG** type animations.</span></span>

| <span data-ttu-id="a74b9-1135">Ekran &nbsp; Sürükleme &nbsp; Bayrakları</span><span class="sxs-lookup"><span data-stu-id="a74b9-1135">Screen&nbsp;Drag&nbsp;Flags</span></span> | <span data-ttu-id="a74b9-1136">Açıklama</span><span class="sxs-lookup"><span data-stu-id="a74b9-1136">Description</span></span> |
| --- | --- |
| <span data-ttu-id="a74b9-1137">GX_ANIMATION_WRAP</span><span class="sxs-lookup"><span data-stu-id="a74b9-1137">GX_ANIMATION_WRAP</span></span> | <span data-ttu-id="a74b9-1138">Ekran listesinin baştan sona kaydırarak başlaması gerekir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1138">The screen list should wrap from end back to start.</span></span> |
| <span data-ttu-id="a74b9-1139">GX_ANIMATION_HORIZONTAL</span><span class="sxs-lookup"><span data-stu-id="a74b9-1139">GX_ANIMATION_HORIZONTAL</span></span> | <span data-ttu-id="a74b9-1140">Yatay yönde izin verilen ekran sürükleme.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1140">Screen drag allowed in horizontal direction.</span></span>  |
| <span data-ttu-id="a74b9-1141">GX_ANIMATION_VERTICAL</span><span class="sxs-lookup"><span data-stu-id="a74b9-1141">GX_ANIMATION_VERTICAL</span></span> | <span data-ttu-id="a74b9-1142">Dikey yönde izin verilen ekran sürükleme.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1142">Screen drag allowed in vertical direction.</span></span> |

<span data-ttu-id="a74b9-1143">Aşağıdaki bayrak, çevrilmiş animasyonlarla birlikte kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1143">The following flag can be used in combination with translate animations.</span></span>

| <span data-ttu-id="a74b9-1144">Animasyon &nbsp; Bayraklarını &nbsp; Çevirme</span><span class="sxs-lookup"><span data-stu-id="a74b9-1144">Translate&nbsp;Animations&nbsp;Flags</span></span> | <span data-ttu-id="a74b9-1145">Açıklama</span><span class="sxs-lookup"><span data-stu-id="a74b9-1145">Description</span></span> |
| --- | --- |
| <span data-ttu-id="a74b9-1146">GX_ANIMATION_DETACH</span><span class="sxs-lookup"><span data-stu-id="a74b9-1146">GX_ANIMATION_DETACH</span></span> | <span data-ttu-id="a74b9-1147">Animasyon tamamlandığında animasyon hedefini animasyon üst öğesinden ayır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1147">Detach the animation target from the animation parent when the animation is completed.</span></span> <span data-ttu-id="a74b9-1148">Hedef dinamik olarak ayrılmış ve GUIX Studio tarafından oluşturulan otomatik olay işleme tarafından oluşturulmuşsa, hedef ayrılmış durumdan sonra silinir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1148">If the target was dynamically allocated and created by the GUIX Studio generated automated event handling, the target will be deleted after it is detached.</span></span> |
| <span data-ttu-id="a74b9-1149">GX_ANIMATION_TRANSLATE</span><span class="sxs-lookup"><span data-stu-id="a74b9-1149">GX_ANIMATION_TRANSLATE</span></span> | <span data-ttu-id="a74b9-1150">Animasyon türleri zamanlayıcı odaklı animasyonlardır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1150">Animation types are timer driven animations.</span></span> <span data-ttu-id="a74b9-1151">Uygulama, hedef pencere öğesi için başlangıç ve bitiş konumu ile başlangıç ve bitiş alfa değerini tanımlar ve animasyon yöneticisi animasyonu yürütmeye yönelik itici güç olarak görev yapacak bir zamanlayıcı oluşturur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1151">The application defines the starting and ending position and starting and ending alpha value for the target widget, and the animation manager creates a timer to serve and as the driving force to execute the animation.</span></span>
| <span data-ttu-id="a74b9-1152">GX_ANIMATION_SCREEN_DRAG</span><span class="sxs-lookup"><span data-stu-id="a74b9-1152">GX_ANIMATION_SCREEN_DRAG</span></span> | <span data-ttu-id="a74b9-1153">Bu animasyon türünün **kalem** girişi olayları tarafından yönlendirilmli olduğu TRANSLATE animasyonlarından farklıdır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1153">Differs from the **TRANSLATE** animations in that this animation type is driven by pen input events.</span></span> <span data-ttu-id="a74b9-1154">Bu animasyon türü, kullanıcı giriş dokunmatik ekranında bir kalem veya kalem sürüklerken hedef pencere öğesi çekmesi için dokunmatik ekran girişiyle birlikte izler.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1154">This animation type tracks along with the touch screen input to swipe the target widget as the user drags a pen or stylus across the input touch screen.</span></span> <span data-ttu-id="a74b9-1155">Bu animasyon türünü kullanmak için, uygulamanın bu animasyonu etkinleştirmek için **_gx_animation_drag_enable_** API'sini çağıran bir api olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1155">To utilize this type of animation, the application should call the **_gx_animation_drag_enable_** API to enable this animation.</span></span> |

<span data-ttu-id="a74b9-1156">Gx_animation_id  değeri, event.gx_event_sender olayın GX_ANIMATION_COMPLETE **geçirebilirsiniz.**</span><span class="sxs-lookup"><span data-stu-id="a74b9-1156">The **gx_animation_id** value is passed back to the animation parent in the event.gx_event_sender field of the **GX_ANIMATION_COMPLETE** event.</span></span> <span data-ttu-id="a74b9-1157">Bu değer, birkaç alt animasyondan hangilerinin tamamlanma bildiriyor olduğunu belirlemek için animasyon üst öğesi tarafından kullanılır.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1157">This value is used by the animation parent to determine which of possibly several child animations is reporting completion.</span></span> <span data-ttu-id="a74b9-1158">Bu değer 0 olabilir ve kimlik değeri 0 olan  bir animasyon hiçbir zaman ANIMATION_COMPLETE oluşturmaz.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1158">This value can be 0, and an animation with ID value 0 will not generate an **ANIMATION_COMPLETE** event at all.</span></span>

<span data-ttu-id="a74b9-1159">Bu **gx_animation_start_delay,** animasyonu yürütmeden önce _ çağrılmadan önce çağrılmak istendikten sonra gx_animation_start süreölçer işaretlerinin sayısını belirten bir GUIX \***değerdir. _gx_animation_start çağrısının ardından animasyonu hemen başlatmak için değer 0\*_gx_animation_start._**</span><span class="sxs-lookup"><span data-stu-id="a74b9-1159">The **gx_animation_start_delay** value is a GUIX tick count indicating the number of timer ticks to delay after **_gx_animation_start_*_ is called before actually executing the animation. The value can be 0 to start the animation immediately upon calling _*_gx_animation_start_**.</span></span>

<span data-ttu-id="a74b9-1160">Bu **gx_animation_frame_interval,** animasyon dizisinin her karesi arasında gecikmeye neden olacak GUIX zamanlayıcısı saat işaretlerinin sayısını (temel işletim sistemi onay oranının katları) tanımlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1160">The **gx_animation_frame_interval** field defines the number of GUIX timer ticks (a multiple of the underlying OS tick rate) to delay between each frame of the animation sequence.</span></span> <span data-ttu-id="a74b9-1161">En düşük değer 1'tir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1161">The minimum value is 1.</span></span>

<span data-ttu-id="a74b9-1162">Bu **gx_animation_start_position,** çeviri animasyonları için hedef pencere öğesi için sol üst başlangıç noktasını tanımlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1162">The **gx_animation_start_position** defines the top-left starting point for the target widget for translation animations.</span></span>

<span data-ttu-id="a74b9-1163">Bu **gx_animation_end_position,** çeviri türü animasyonları için hedef pencere öğesi için sol üst uç konumunu tanımlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1163">The **gx_animation_end_position** defines the top-left ending position for the target widget for translation type animations.</span></span>

<span data-ttu-id="a74b9-1164">Bu **gx_animation_start_alpha,** çeviri türü animasyonları için başlangıç tuval alfa değerini tanımlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1164">The **gx_animation_start_alpha** field defines the starting canvas alpha value for translation type animations.</span></span>

<span data-ttu-id="a74b9-1165">Bu **gx_animation_end_alpha,** çeviri türü animasyonları için son tuval alfa değerini tanımlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1165">The **gx_animation_end_alpha** field defines the ending canvas alpha value for translation type animations.</span></span>

<span data-ttu-id="a74b9-1166">Gx_animation_steps  alanı, denetleyicinin çeviri animasyonları için kaç adım veya kare yürütmesi gerektiğini tanımlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1166">The **gx_animation_steps** field defines how many steps or frames the controller should execute for translation animations.</span></span> <span data-ttu-id="a74b9-1167">Daha fazla sayıda adım daha düzgün bir slayt ve/veya soldurma görünümü üretir, ancak daha fazla sistem bant genişliği gerektirir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1167">A larger number of steps produces a smoother slide and/or fade appearance, but also requires greater system bandwidth.</span></span>

<span data-ttu-id="a74b9-1168">Uygulamanıza animasyon etkileri uygulamak için öncelikle gx_animation_create ***çağırarak*** animasyon denetleyicinizi başlatmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1168">To implement animation effects in your application, you must first call ***gx_animation_create*** to initialize your animation controller.</span></span> <span data-ttu-id="a74b9-1169">Animasyonun ikincil tuvali kullanacaksa bu tuvali başlatmak için gx_animation_canvas_define.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1169">If your animation will be using a secondary canvas, initialize this canvas by calling gx_animation_canvas_define.</span></span> <span data-ttu-id="a74b9-1170">Ardından, gerçekleştirilecek belirli **GX_ANIMATION_INFO** türünü ve diğer animasyon parametrelerini tanımlamak için uygulama yapısını başlatmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1170">Next, you should initialize the **GX_ANIMATION_INFO** structure to define the specific type of animation to be performed and the other animation parameters.</span></span> <span data-ttu-id="a74b9-1171">Son olarak, gx_animation_start dizisini tetiklemek için bu çağrıyı kullanın.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1171">Finally, call gx_animation_start to trigger the animation sequence.</span></span>

<span data-ttu-id="a74b9-1172">Animasyon denetleyicisi bir animasyon dizisini tamamlayan  GX_ANIMATION_COMPLETE pencere öğesine bir olay gönderir ve animasyon tuvali için istenen temizleme işleminin o anda yapılmasına olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1172">When the animation controller completes an animation sequence, it sends an **GX_ANIMATION_COMPLETE** event to the parent widget, allowing the any desired cleanup of the animation canvas to be done at that time.</span></span>

## <a name="guix-utility-component"></a><span data-ttu-id="a74b9-1173">GUIX Yardımcı Programı Bileşeni</span><span class="sxs-lookup"><span data-stu-id="a74b9-1173">GUIX Utility Component</span></span> 

<span data-ttu-id="a74b9-1174">Yardımcı program bileşeni GUIX'te tüm yaygın yardımcı program işlevlerden sorumludur.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1174">The utility component is responsible for all common utility functions in GUIX.</span></span> <span data-ttu-id="a74b9-1175">Bunlar yararlı yardımcı programlar olan ve uygulamanın herhangi bir yerinden veya iç GUIX kodundan çağrılabilir yaygın işlevlerdir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1175">These are common functions that are useful utilities and can be invoked from anywhere in the application or the internal GUIX code.</span></span> <span data-ttu-id="a74b9-1176">Yardımcı program bileşeni işlevleri aşağıdakileri içerir.</span><span class="sxs-lookup"><span data-stu-id="a74b9-1176">The utility component functions include the following.</span></span>

<span data-ttu-id="a74b9-1177">***gx_utility_canvas_to_bmp***</span><span class="sxs-lookup"><span data-stu-id="a74b9-1177">***gx_utility_canvas_to_bmp***</span></span>

<span data-ttu-id="a74b9-1178">***gx_utility_circle_point_get***</span><span class="sxs-lookup"><span data-stu-id="a74b9-1178">***gx_utility_circle_point_get***</span></span>

<span data-ttu-id="a74b9-1179">***gx_utility_alphamap_create***</span><span class="sxs-lookup"><span data-stu-id="a74b9-1179">***gx_utility_alphamap_create***</span></span>

<span data-ttu-id="a74b9-1180">***gx_utility_gradient_create***</span><span class="sxs-lookup"><span data-stu-id="a74b9-1180">***gx_utility_gradient_create***</span></span>

<span data-ttu-id="a74b9-1181">***gx_utility_gradient_delete***</span><span class="sxs-lookup"><span data-stu-id="a74b9-1181">***gx_utility_gradient_delete***</span></span>

<span data-ttu-id="a74b9-1182">***gx_utlity_ltoa***</span><span class="sxs-lookup"><span data-stu-id="a74b9-1182">***gx_utlity_ltoa***</span></span>

<span data-ttu-id="a74b9-1183">***gx_utility_math_acos***</span><span class="sxs-lookup"><span data-stu-id="a74b9-1183">***gx_utility_math_acos***</span></span>

<span data-ttu-id="a74b9-1184">***gx_utility_math_asin***</span><span class="sxs-lookup"><span data-stu-id="a74b9-1184">***gx_utility_math_asin***</span></span>

<span data-ttu-id="a74b9-1185">***gx_utility_math_cos***</span><span class="sxs-lookup"><span data-stu-id="a74b9-1185">***gx_utility_math_cos***</span></span>

<span data-ttu-id="a74b9-1186">***gx_utility_math_sin***</span><span class="sxs-lookup"><span data-stu-id="a74b9-1186">***gx_utility_math_sin***</span></span>

<span data-ttu-id="a74b9-1187">***gx_utility_math_sqrt***</span><span class="sxs-lookup"><span data-stu-id="a74b9-1187">***gx_utility_math_sqrt***</span></span>

<span data-ttu-id="a74b9-1188">***gx_utility_pixelmap_resize***</span><span class="sxs-lookup"><span data-stu-id="a74b9-1188">***gx_utility_pixelmap_resize***</span></span>

<span data-ttu-id="a74b9-1189">***gx_utility_pixelmap_rotate***</span><span class="sxs-lookup"><span data-stu-id="a74b9-1189">***gx_utility_pixelmap_rotate***</span></span>

<span data-ttu-id="a74b9-1190">***gx_utility_pixelmap_simple_rotate***</span><span class="sxs-lookup"><span data-stu-id="a74b9-1190">***gx_utility_pixelmap_simple_rotate***</span></span>

<span data-ttu-id="a74b9-1191">***gx_utility_rectangle_center***</span><span class="sxs-lookup"><span data-stu-id="a74b9-1191">***gx_utility_rectangle_center***</span></span>

<span data-ttu-id="a74b9-1192">***gx_utility_rectangle_center_find***</span><span class="sxs-lookup"><span data-stu-id="a74b9-1192">***gx_utility_rectangle_center_find***</span></span>

<span data-ttu-id="a74b9-1193">***gx_utility_rectangle_combine***</span><span class="sxs-lookup"><span data-stu-id="a74b9-1193">***gx_utility_rectangle_combine***</span></span>

<span data-ttu-id="a74b9-1194">***gx_utility_rectangle_compare***</span><span class="sxs-lookup"><span data-stu-id="a74b9-1194">***gx_utility_rectangle_compare***</span></span>

<span data-ttu-id="a74b9-1195">***gx_utility_rectangle_define***</span><span class="sxs-lookup"><span data-stu-id="a74b9-1195">***gx_utility_rectangle_define***</span></span>

<span data-ttu-id="a74b9-1196">***gx_utility_rectangle_overlap_detect***</span><span class="sxs-lookup"><span data-stu-id="a74b9-1196">***gx_utility_rectangle_overlap_detect***</span></span>

<span data-ttu-id="a74b9-1197">***gx_utility_rectangle_point_detect***</span><span class="sxs-lookup"><span data-stu-id="a74b9-1197">***gx_utility_rectangle_point_detect***</span></span>

<span data-ttu-id="a74b9-1198">***gx_utility_rectangle_resize***</span><span class="sxs-lookup"><span data-stu-id="a74b9-1198">***gx_utility_rectangle_resize***</span></span>

<span data-ttu-id="a74b9-1199">***gx_utility_rectangle_shift***</span><span class="sxs-lookup"><span data-stu-id="a74b9-1199">***gx_utility_rectangle_shift***</span></span>

<span data-ttu-id="a74b9-1200">***gx_utility_string_to_alphamap***</span><span class="sxs-lookup"><span data-stu-id="a74b9-1200">***gx_utility_string_to_alphamap***</span></span>
