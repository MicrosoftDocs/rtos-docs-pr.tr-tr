---
title: Bölüm 3-Gux 'e Işlevsel genel bakış
description: Bu bölüm, yüksek performanslı Gux Kullanıcı arabirimi ürününe işlevsel bir genel bakış içerir.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 2057b86e6f44912fe8ca349cdf0ad2cc10f5c4cd
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/22/2021
ms.locfileid: "104827202"
---
# <a name="chapter-3---functional-overview-of-guix"></a><span data-ttu-id="e6efc-103">Bölüm 3-Gux 'e Işlevsel genel bakış</span><span class="sxs-lookup"><span data-stu-id="e6efc-103">Chapter 3 - Functional Overview of GUIX</span></span>

<span data-ttu-id="e6efc-104">Bu bölüm, yüksek performanslı Gux Kullanıcı arabirimi ürününe işlevsel bir genel bakış içerir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-104">This chapter contains a functional overview of the high-performance GUIX user interface product.</span></span> 

## <a name="execution-overview"></a><span data-ttu-id="e6efc-105">Yürütmeye genel bakış</span><span class="sxs-lookup"><span data-stu-id="e6efc-105">Execution Overview</span></span>

<span data-ttu-id="e6efc-106">GUIX, olay odaklı bir programlama modeli uygular.</span><span class="sxs-lookup"><span data-stu-id="e6efc-106">GUIX implements an event driven programming model.</span></span> <span data-ttu-id="e6efc-107">Bu, Gux çerçevesinin, Gux olay kuyruğuna gönderilen olayların alınmasından öncelikli olarak yönettiği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-107">This means that the GUIX framework is primarily driven by the receipt of events pushed into the GUIX event queue.</span></span> <span data-ttu-id="e6efc-108">Bu olayların işlenmesi, GUıDX sistem başlatması sırasında oluşturulan bir ThreadX iş parçacığı olan Gux iş parçacığı bağlamında gerçekleşir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-108">The processing of these events takes place in the context of the GUIX thread, which is a ThreadX thread created during GUIX system initialization.</span></span>

<span data-ttu-id="e6efc-109">GUX uygulamaları, Windows ve alt pencere öğeleri oluşturmak için Gux API işlevlerini çağırarak kullanıcı arabirimini tanımlar ve her pencere veya pencere öğesi türünün renklerini, stillerini, yazı tiplerini ve çeşitli diğer özniteliklerini tanımlamak için kullanılan ek API işlevlerini çağırarak bu pencere öğelerinin görünümünü özelleştirin.</span><span class="sxs-lookup"><span data-stu-id="e6efc-109">GUIX applications define the user interface by calling GUIX API functions to create windows and child widgets, and customize the appearance of these widgets by calling additional API functions used to define colors, styles, fonts, and various other attributes of each window or widget type.</span></span> <span data-ttu-id="e6efc-110">Kullanıcı arabirimi ekranlarınızın görünümünü oluşturmak için Gux Studio kullanıyorsanız, ekran oluşturma işlemi için Gux API işlevlerini çağırma işlevinin çoğu, Gux Studio uygulaması tarafından sizin için yapılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-110">If you are using GUIX Studio to create the appearance of your user-interface screens, much of this work of calling GUIX API functions to create your display is done for you by the GUIX Studio application.</span></span>

<span data-ttu-id="e6efc-111">GUX uygulamaları, Gux olay kuyruğundan alınan olayları işleyerek sistem kullanıcısı ve dış iş mantığı ile etkileşim kurar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-111">GUIX applications interact with the system user and with external business logic by handling events retrieved from the GUIX event queue.</span></span>
<span data-ttu-id="e6efc-112">Bu olaylar genellikle Gux pencere öğeleri tarafından üretilir, ancak dış iş parçacıkları tarafından da oluşturulabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-112">These events are usually produced by GUIX widgets, but they can also be created by external threads.</span></span> <span data-ttu-id="e6efc-113">Tipik bir Gux düğmesi gönderildiğinde, bu düğme düğmenin üst penceresine bir olay gönderir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-113">When a typical GUIX button is pushed, that button sends an event to the button’s parent window.</span></span> <span data-ttu-id="e6efc-114">Uygulama programınız düğme anında iletme olayı için bir işleyici sağlayarak bu düğmeye gönderim üzerinde işlem yapacak.</span><span class="sxs-lookup"><span data-stu-id="e6efc-114">Your application program will act on that button push by providing a handler for the button push event.</span></span>

<span data-ttu-id="e6efc-115">Ek Gux iş parçacıkları genellikle giriş sürücüleri gibi şeyler için oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-115">Additional GUIX threads are often created for things such as input drivers.</span></span> <span data-ttu-id="e6efc-116">Tipik bir dokunmatik ekran giriş sürücüsü, ana Gux iş parçacığı dışında tek başına bir iş parçacığı olarak yürütülür.</span><span class="sxs-lookup"><span data-stu-id="e6efc-116">A typical touch screen input driver is executed as a standalone thread external to the main GUIX thread.</span></span> <span data-ttu-id="e6efc-117">Dokunmatik giriş sürücüsü, Gux olay kuyruğuna olayları göndererek Gux iş parçacığına dokunma bilgileri gönderir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-117">The touch input driver sends touch information into the GUIX thread by sending events into the GUIX event queue.</span></span>

<span data-ttu-id="e6efc-118">Animasyonlar gibi birçok kullanıcı arabirimi işlemi için doğru zamanlama bilgileri gerektiğinden, GUıDX Ayrıca basit ve kullanımı kolay bir Zamanlayıcı arabirimi de uygular.</span><span class="sxs-lookup"><span data-stu-id="e6efc-118">Since many user-interface operations such as animations require accurate timing information, GUIX also implements a simple and easy to use timer interface.</span></span> <span data-ttu-id="e6efc-119">Bu süreölçer arabirimi, ThreadX Zamanlayıcı hizmeti üzerine kurulmuştur ve sistem başlangıcında otomatik olarak yapılandırılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-119">This timer interface is built upon the ThreadX timer service, and is configured automatically at system startup.</span></span>

<span data-ttu-id="e6efc-120">GUX yazılımının büyük çoğunluğu herhangi bir donanım bağımlılıklarından bağımsızdır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-120">The vast majority of the GUIX software is independent of any hardware dependencies.</span></span> <span data-ttu-id="e6efc-121">Çerçeve, donanıma özgü giriş sürücüleri ve donanıma özgü grafik sürücüleri gerektirir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-121">The framework does require hardware-specific input drivers and hardware-specific graphics drivers.</span></span> <span data-ttu-id="e6efc-122">Bu donanıma özgü sürücülerin uygulanma ayrıntıları Bölüm 5 ' e ertelenir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-122">The details of how these hardware specific drivers are implemented are deferred to chapter 5.</span></span>

## <a name="initialization"></a><span data-ttu-id="e6efc-123">Başlatma</span><span class="sxs-lookup"><span data-stu-id="e6efc-123">Initialization</span></span> 

<span data-ttu-id="e6efc-124">Service ***gx_system_initialize*** DIĞER BIR Gux hizmeti çağrılmadan önce çağrılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-124">The service ***gx_system_initialize*** must be called before any other GUIX service is called.</span></span> <span data-ttu-id="e6efc-125">GUX sistem başlatması, ThreadX ***tx_application_define*** yordamından (başlatma bağlamından) veya uygulama iş parçacıklarından çağrılabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-125">GUIX system initialization can be called from the ThreadX ***tx_application_define*** routine (initialization context) or from application threads.</span></span> <span data-ttu-id="e6efc-126">***Gx_system_initialize*** işlevi, Gux olay kuyruğu oluşturur, guıdx süreölçer hizmetini başlatır, ana Gux sistem iş parçacığını oluşturur ve uygulamanızın yürütülmesi sırasında Gux tarafından tutulan çeşitli veri yapılarını başlatır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-126">The ***gx_system_initialize*** function creates the GUIX event queue, initializes the GUIX timer facility, creates the main GUIX system thread, and initializes various data structures maintained by GUIX during the execution of your application.</span></span>

<span data-ttu-id="e6efc-127">***Gx_system_initialize*** çağrıldıktan sonra, uygulama ekranlar, canvaler, pencereler, pencere öğeleri ve tüm Gux nesnelerinin özelliklerini özelleştirmek için hazırlayın.</span><span class="sxs-lookup"><span data-stu-id="e6efc-127">After ***gx_system_initialize*** returns, the application is ready to create displays, canvases, windows, widgets, and customize the properties of all GUIX objects.</span></span> <span data-ttu-id="e6efc-128">GUX nesne oluşturma API 'sinin büyük bölümü ***tx_application_define*** veya uygulama iş parçacıklarından çağrılabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-128">Much of the GUIX object creation API can be called from ***tx_application_define*** or from application threads.</span></span>

## <a name="application-interface-calls"></a><span data-ttu-id="e6efc-129">Uygulama arabirimi çağrıları</span><span class="sxs-lookup"><span data-stu-id="e6efc-129">Application Interface Calls</span></span> 

<span data-ttu-id="e6efc-130">Uygulamadan yapılan çağrılar büyük ölçüde ***tx_application_define*** (başlatma bağlamından) veya uygulama iş parçacıklarından yapılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-130">Calls from the application are largely made from ***tx_application_define*** (initialization context) or from application threads.</span></span> <span data-ttu-id="e6efc-131">Hangi bağlamın çağrılabilecek olduğunu belirlemek için, Bölüm 4 ' te açıklanan her bir Gux API 'sinin "Izin verilen" bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="e6efc-131">Please see the “Allowed From” section of each GUIX API described in Chapter 4 to determine what context it may be called from.</span></span>

<span data-ttu-id="e6efc-132">Çoğu bölümde, yoğun etkinliklerin işlenmesi, tüm olay işleme ve pencere öğesi/pencere çizimi dahil olmak üzere iç Gux iş parçacığına ertelenir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-132">For the most part, processing intensive activities are deferred to the internal GUIX thread, including all event processing and widget/window drawing.</span></span>

<span data-ttu-id="e6efc-133">GUX API işlevleri dilediğiniz zaman herhangi bir iş parçacığından çağrılabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-133">The GUIX API functions can be called from any thread at any time.</span></span>
<span data-ttu-id="e6efc-134">Ancak, zaman açısından kritik iş mantığınızı Kullanıcı arabirimi mantığınızdan ayırmak için genellikle daha iyi mimari olarak değerlendirilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-134">However it is usually considered to be better architecture to separate your time-critical business logic from your user interface logic.</span></span> <span data-ttu-id="e6efc-135">Kullanıcı arabirimi çizim işlemleri bazen görüntü boyutunuza ve CPU performansına bağlı olarak uzun süre sürebileceği için, normalde bir çizim işleminin tamamlanması beklenirken zaman açısından kritik iş parçacıklarının gecikilmesine sahip olmak istemezsiniz.</span><span class="sxs-lookup"><span data-stu-id="e6efc-135">Since the user interface drawing operations can sometimes take a long time depending on your display size and CPU performance, you normally would not want to have time-critical threads delayed waiting for a drawing operation to complete.</span></span>

## <a name="internal-guix-thread"></a><span data-ttu-id="e6efc-136">İç Gux Iş parçacığı</span><span class="sxs-lookup"><span data-stu-id="e6efc-136">Internal GUIX Thread</span></span> 

<span data-ttu-id="e6efc-137">Belirtildiği gibi, GUıDX 'in GUI işlemesini toplu olarak gerçekleştiren bir iç iş parçacığı vardır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-137">As mentioned, GUIX has an internal thread that performs the bulk of the GUI processing.</span></span> <span data-ttu-id="e6efc-138">Bu iş parçacığı, uygulama yazılımı tarafından, \***gx_system_initialize** _ ve arkasından _ *_gx_system_start_* \* çağırarak oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-138">This thread is created by the application software by calling ***gx_system_initialize** _ followed by _*_gx_system_start_\*\*.</span></span>

<span data-ttu-id="e6efc-139">İç Gux iş parçacığının önceliği tarafından belirlenir `#define GX_SYSTEM_THREAD_PRIORITY` .</span><span class="sxs-lookup"><span data-stu-id="e6efc-139">The priority of the internal GUIX thread is determined by the `#define GX_SYSTEM_THREAD_PRIORITY`.</span></span> <span data-ttu-id="e6efc-140">Bu değer varsayılan olarak 16 ' dır (orta öncelik), ancak bu değer gx_port. h veya gx_user. h üstbilgi dosyasında belirtilerek, varsayılan değeri geçersiz kılarak değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-140">This value defaults to 16 (middle priority) but can be modified by specifying this value in the gx_port.h or gx_user.h header file, overriding the default value.</span></span>

<span data-ttu-id="e6efc-141">GUX iş parçacığı zaman dilimi benzer şekilde tarafından tanımlanır ve varsayılan olarak `#define GX_SYSTEM_THREAD_TIMESLICE` 10 MS değeridir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-141">The GUIX thread time slice is similarly defined by the `#define GX_SYSTEM_THREAD_TIMESLICE`, which defaults to the value 10 ms.</span></span>

<span data-ttu-id="e6efc-142">Sistem iş parçacığının yığın kişisi, `#define GX_THREAD_STACK_SIZE` ***gx_port. h*** üstbilgi dosyasında bulunan öğesine göre belirlenir, ancak bu değer gx_user. h üst bilgi dosyanızda belirtilerek de geçersiz kılınabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-142">The stack sie of the system thread is determined by the `#define GX_THREAD_STACK_SIZE`, which is found in the ***gx_port.h*** header file, but can also be overridden by specifying this value in your gx_user.h header file.</span></span>

<span data-ttu-id="e6efc-143">İç Gux iş parçacığı yürütme döngüsü üç eylemden oluşur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-143">The internal GUIX thread execution loop is composed of three actions.</span></span>
<span data-ttu-id="e6efc-144">İlk olarak, guıdx olay kuyruğundan olayları alır ve bu olayları Gux Windows ve pencere öğeleri tarafından işlenmek üzere gönderir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-144">First, GUIX retrieves events from the GUIX event queue and dispatches those events for processing by the GUIX windows and widgets.</span></span> <span data-ttu-id="e6efc-145">Olaylar genellikle, düzenli zamanlayıcılar, dokunmatik ekran veya tuş takımı gibi giriş aygıtları ve Kullanıcı girişini işlediklerinde Gux Pencere öğelerinin kendileri tarafından Gux olay kuyruğuna gönderilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-145">Events are typically pushed into the GUIX event queue by periodic timers, input devices such as a touch screen or keypad, and by GUIX widgets themselves as they process user input.</span></span> <span data-ttu-id="e6efc-146">Ardından, tüm olaylar işlendikten sonra, GUıDX bir ekran yenilemenin gerekli olup olmadığını belirler ve bu durumda, bu pencerelerin ve bu pencere öğelerinin çizim işlevlerini çağırarak kirli olarak işaretlenen bir işlem için gerekli işlemleri gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-146">Next, after all events have been processed, GUIX determines if a screen refresh is needed, and if so performs the processing necessary to update the display graphics data, mainly by calling the drawing functions of those windows and widgets which have been marked as dirty.</span></span> <span data-ttu-id="e6efc-147">Son olarak, GUıDX, yeni bir giriş olayı veya olay geldikçe Gux iş parçacığını askıya alır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-147">Finally, GUIX suspends the GUIX thread until a new input event or events arrive.</span></span>

## <a name="event-processing"></a><span data-ttu-id="e6efc-148">Olay Işleme</span><span class="sxs-lookup"><span data-stu-id="e6efc-148">Event Processing</span></span> 

<span data-ttu-id="e6efc-149">Dokunmatik veya kalem girişi olayları, dokunmatik veya kalem giriş piksel konumu altında en üstteki pencere veya pencere öğesi belirlenerek ve bu pencere/pencere öğesinin olay işleme işlevini çağırarak işlenir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-149">Touch or pen input events are processed by determining the top-most window or widget beneath the touch or pen input pixel position and calling that window/widget’s event processing function.</span></span> <span data-ttu-id="e6efc-150">Pencere öğesi kalem giriş olaylarını anladığı takdirde, bu pencere öğesi türü için uygun şekilde olayı işler.</span><span class="sxs-lookup"><span data-stu-id="e6efc-150">If the widget understands pen input events, it will process the event as appropriate for that widget type.</span></span> <span data-ttu-id="e6efc-151">Aksi takdirde en üstteki pencere öğesi, işlem için pencere öğesinin üst öğesine dokunma veya kalem girişi olayını iletir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-151">If not, the top-most widget will pass the touch or pen input event to the widget's parent for processing.</span></span> <span data-ttu-id="e6efc-152">Bu olayı geçirme işlemi, olay işlenene veya olay kök pencereye gelene kadar devam eder; bu durumda olay atılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-152">This passing of the event up the chain continues until either the event is handled or the event arrives at the root window, in which case the event is discarded.</span></span>

<span data-ttu-id="e6efc-153">Tuş takımı olayları, giriş odaklı pencereye/pencere öğesine gönderilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-153">Keypad events are sent to the window/widget that has input focus.</span></span> <span data-ttu-id="e6efc-154">Giriş odağı durumu, Gux gx_system bileşeni tarafından korunur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-154">Input focus status is maintained by the GUIX gx_system component.</span></span>

<span data-ttu-id="e6efc-155">Zamanlayıcı olayları her zaman işleme için zamanlayıcıya sahip olan pencere veya pencere öğesine dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-155">Timer events are always dispatched to the window or widget that owns the timer for processing.</span></span>

<span data-ttu-id="e6efc-156">Düğme tıklama olayları veya kaydırıcı değer değişiklik olayları gibi dahili olarak oluşturulan olaylar her zaman olayı oluşturan pencere öğesinin üst öğesine gönderilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-156">Internally generated events, such as button click events or slider value change events, are always sent to the parent of the widget generating the event.</span></span> <span data-ttu-id="e6efc-157">Üst öğe olayı işlemez ise, dokunma veya kalem girişi olaylarına benzer şekilde zinciri iletilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-157">If the parent does not process the event, it is passed up the chain similar to touch or pen input events.</span></span>

## <a name="drawing"></a><span data-ttu-id="e6efc-158">Çizim</span><span class="sxs-lookup"><span data-stu-id="e6efc-158">Drawing</span></span> 

<span data-ttu-id="e6efc-159">Tüm olay işleme tamamlandıktan sonra, GUıDX iç iş parçacığı herhangi bir görüntüleme güncelleştirmesinin gerekli olup olmadığını ve uygun pencere/pencere öğesi çizim işlevlerinin çağrıldığını belirler.</span><span class="sxs-lookup"><span data-stu-id="e6efc-159">Once all the event processing is complete, the GUIX internal thread determines if any display update is needed and if so the appropriate window/widget drawing functions are called.</span></span> <span data-ttu-id="e6efc-160">Çizim tamamlandığında, Gux iç iş parçacığı bir sonraki Gux olayının işlenmesi için olay sırasında bekler.</span><span class="sxs-lookup"><span data-stu-id="e6efc-160">When drawing is complete, the GUIX internal thread simply waits on its event queue for the next GUIX event to process.</span></span>

<span data-ttu-id="e6efc-161">GUX, her pencere öğesi ve tuval için yeniden çizilmesi gereken alan olan *kirli alan* kavramını uygular.</span><span class="sxs-lookup"><span data-stu-id="e6efc-161">GUIX implements the concept of *dirty areas*, which are areas that need to be re-drawn, for each widget and canvas.</span></span> <span data-ttu-id="e6efc-162">Pencere öğesi yalnızca daha önce kirli olarak işaretlenmiş alanlara çizim yapabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-162">A widget can only draw to areas that have previously been marked as dirty.</span></span> <span data-ttu-id="e6efc-163">Bir pencere öğesi çizim işlevi çağrıldığında, tüm çizim işlemleri dahili olarak önceden tanımlanmış kirli dikdörtgene kırpılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-163">When a widget drawing function is called, all drawing operations are internally clipped to the previously defined dirty rectangle.</span></span>
<span data-ttu-id="e6efc-164">Bu alanın dışında çizim denemeleri yok sayılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-164">Attempts to draw outside of this area are ignored.</span></span>

<span data-ttu-id="e6efc-165">Pencere öğeleri ve pencereler, ***GX_SYSTEM_DIRTY_MARK*** API işlevini çağırarak kendilerini kirli olarak işaretler.</span><span class="sxs-lookup"><span data-stu-id="e6efc-165">Widgets and windows mark themselves as dirty by calling the API function ***gx_system_dirty_mark***.</span></span> <span data-ttu-id="e6efc-166">Bu işlev, yeniden çizilmesini gerektiren tüm pencere öğesini veya pencereyi işaretler.</span><span class="sxs-lookup"><span data-stu-id="e6efc-166">This function marks the entire widget or window as needing to be redrawn.</span></span> <span data-ttu-id="e6efc-167">İkinci bir işlev ***gx_system_dirty_partial_add***, yalnızca pencerenin veya pencere öğesinin bir kısmını kirli olarak işaretlemek için alternatif olarak çağrılabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-167">A second function, ***gx_system_dirty_partial_add***, can be invoked as an alternative to mark only a portion of a window or widget as dirty.</span></span>

<span data-ttu-id="e6efc-168">Bu pencere öğelerini kirli olarak işaretleme ve sonra yalnızca tüm giriş olayları işlendiğinde bu pencere öğelerinin yeniden çizilmesine yönelik bu model *ertelenmiş çizim* olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-168">This model of marking widgets as dirty and then redrawing those widgets only when all input events have been processed is referred to as *deferred drawing*.</span></span> <span data-ttu-id="e6efc-169">GUX ertelenmiş çizim algoritması ve kirli liste bakımı, çizim verimliliğini artırmak için tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-169">The GUIX deferred drawing algorithm and dirty list maintenance is designed to improve drawing efficiency.</span></span> <span data-ttu-id="e6efc-170">Çizim işlemleri genellikle pahalı olduğundan, Gux gereksiz çizimi engellemek için zordur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-170">Since drawing operations are typically expensive, GUIX works hard to prevent unnecessary drawing.</span></span>

<span data-ttu-id="e6efc-171">Çizim, bir Gux *tuvaline* yapılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-171">Drawing is done to a GUIX *canvas*.</span></span> <span data-ttu-id="e6efc-172">Tuval, grafik verilerini tutmak için ayrılan bir bellek alanıdır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-172">A canvas is a memory area reserved to hold graphics data.</span></span> <span data-ttu-id="e6efc-173">Bir tuval, sistem mimarisine ve bellek kısıtlamalarına bağlı olarak doğrudan donanım çerçeve arabelleğine bağlanabilir veya olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-173">A canvas may or may not be directly linked to the hardware frame buffer, depending on the system architecture and memory constraints.</span></span> <span data-ttu-id="e6efc-174">Herhangi bir çizim gerçekleşebilmeniz için önce, ***gx_canvas_drawing_initiate*** API işlevini çağırarak çizim için bir tuvalin açılması gerekir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-174">Before any drawing can occur, a canvas must first be opened for drawing by calling the ***gx_canvas_drawing_initiate*** API function.</span></span> <span data-ttu-id="e6efc-175">Bu API, çizim için bir tuval hazırlar ve geçerli *Çizim bağlamını* kurdu.</span><span class="sxs-lookup"><span data-stu-id="e6efc-175">This API prepares a canvas for drawing and established the current *drawing context*.</span></span> <span data-ttu-id="e6efc-176">GUIX bir sistem tuvali yenilemesi gerçekleştirdiğinde, tuval çizim için açılır ve pencere öğesi düzeyi çizim API 'Leri çağrılmadan önce oluşturulan çizim bağlamı açılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-176">When GUIX performs a system canvas refresh, the canvas is opened for drawing and the drawing context established before the widget-level drawing APIs are invoked.</span></span> <span data-ttu-id="e6efc-177">Bu nedenle Pencere öğelerinin pencere öğesi çizim işlevindeki bir tuvalde çizim başlatması gerekmez.</span><span class="sxs-lookup"><span data-stu-id="e6efc-177">Therefore widgets do not need to initiate drawing on a canvas within the widget drawing function.</span></span>

<span data-ttu-id="e6efc-178">Ancak, bir uygulama, standart Gux ertelenmiş çizim algoritmasının akışı dışında bir tuvalde hemen çizim gerçekleştirmeye çalışırsa, uygulamanın diğer çizim API işlevlerini çağırmadan önce ***gx_canvas_drawing_initiate*** doğrudan çağırması ve hemen çizim tamamlandıktan sonra ***gx_canvas_drawing_complete*** çağırması gerekir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-178">However, if an application desires to perform immediate drawing to a canvas, outside the flow of the standard GUIX deferred drawing algorithm, the application must directly invoke the ***gx_canvas_drawing_initiate*** prior to calling any other drawing API functions, and must call ***gx_canvas_drawing_complete*** once the immediate drawing has been completed.</span></span>

## <a name="user-input"></a><span data-ttu-id="e6efc-179">Kullanıcı girişi</span><span class="sxs-lookup"><span data-stu-id="e6efc-179">User Input</span></span> 

<span data-ttu-id="e6efc-180">GUX, önceden tanımlanmış olay türleriyle dokunmatik ekran, fare ve klavye cihazlarını destekler.</span><span class="sxs-lookup"><span data-stu-id="e6efc-180">GUIX supports touch screen, mouse, and keyboard devices with predefined event types.</span></span> <span data-ttu-id="e6efc-181">Ek giriş cihazları, özel olay türleri tanımlayarak veya özel giriş cihazını önceden tanımlanmış olay türleriyle eşleyerek kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-181">Additional input devices can be utilized by defining custom event types, or by mapping the custom input device to the predefined event types.</span></span>

<span data-ttu-id="e6efc-182">Bu cihazlarla ilişkili eylemler, iç Gux iş parçacığı tarafından işlenen olaylara çevrilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-182">Actions associated with these devices are translated into events that are processed by the internal GUIX thread.</span></span> <span data-ttu-id="e6efc-183">Dokunmatik ekranı desteklemek için yazılan sürücü düzeyi yazılımlar, kalem-aşağı, kalem ve kalem sürükleme işlemleri için Gux olay kuyruğu olaylarına hazırlanmalı ve göndermelidir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-183">Driver level software written to support a touch screen must prepare and send to the GUIX event queue events for pen-down, pen-up, and pen-drag operations.</span></span> <span data-ttu-id="e6efc-184">Benzer şekilde, bir tuş takımı giriş sürücüsü, anahtar basma ve anahtar yayın girişi için olaylar üretmelidir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-184">Similarly a keypad input driver must generate events for key press and key release input.</span></span>

## <a name="modal-dialog-execution"></a><span data-ttu-id="e6efc-185">Kalıcı Iletişim kutusu yürütme</span><span class="sxs-lookup"><span data-stu-id="e6efc-185">Modal Dialog Execution</span></span> 

<span data-ttu-id="e6efc-186">Kalıcı iletişim kutusu yürütmesi, başka bir Gux Windows veya pencere öğesi Kullanıcı girişi alabilmesi için bir şekilde kapatılması gereken kullanıcıya bir pencere sunmaya başvurur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-186">Modal dialog execution refers to presenting a window to the user that must be closed in some way before any other GUIX windows or widgets can receive user input.</span></span> <span data-ttu-id="e6efc-187">İletişim kutusu penceresi görüntülenirken, dokunma veya fare giriş olaylarının x, y konumundan bağımsız olarak, kalıcı iletişim kutuları tüm kullanıcı girişlerini yakalar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-187">Modal dialogs capture all user input while the dialog window is displayed, regardless of the x,y position of touch or mouse input events.</span></span>

<span data-ttu-id="e6efc-188">Kalıcı iletişim kutuları, öncelikle ***gx_window_create*** çağırarak ve ardından Gux apı işlevi gx_window_execute çağırarak pencere normal şekilde oluşturularak uygulama yazılımı tarafından tetiklenir ***.***</span><span class="sxs-lookup"><span data-stu-id="e6efc-188">Modal dialogs are triggered by the application software by first creating the window in the normal way by calling ***gx_window_create***, and then calling the GUIX API function ***gx_window_execute.***</span></span>

<span data-ttu-id="e6efc-189">***Gx_window_execute*** işlevi çağrıldığında, guıdx yerel bir olay işleme döngüsü girer.</span><span class="sxs-lookup"><span data-stu-id="e6efc-189">When the ***gx_window_execute*** function is called, GUIX enters a local event processing loop.</span></span> <span data-ttu-id="e6efc-190">***Gx_window_execute*** işlevi, Kullanıcı girişi ya da ***gx_window_close*** çağırarak, iletişim kutusu penceresi kapatılıncaya kadar çağırana geri dönmez.</span><span class="sxs-lookup"><span data-stu-id="e6efc-190">The ***gx_window_execute*** function does not return to the caller until the dialog window is closed, either by user input or by calling ***gx_window_close***.</span></span> <span data-ttu-id="e6efc-191">Bu nedenle, ***gx_window_execute*** işlevini Gux iç iş parçacığından başka hiçbir iş parçacığından çağırmamak çok önemlidir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-191">For this reason, it is very important never to call the ***gx_window_execute*** function from any thread other than the GUIX internal thread.</span></span>

## <a name="periodic-processing"></a><span data-ttu-id="e6efc-192">Düzenli Işleme</span><span class="sxs-lookup"><span data-stu-id="e6efc-192">Periodic Processing</span></span> 

<span data-ttu-id="e6efc-193">Ekran efektlerini, Sprite animasyonunu ve uygulama düzenli istekleri için desteği sağlamak üzere, GUıDX bir ThreadX zamanlayıcısını kullanır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-193">In order to provide display effects, sprite animation, and support for application periodic requests, GUIX uses one ThreadX timer.</span></span> <span data-ttu-id="e6efc-194">Bu tek Zamanlayıcı, tüm Gux saat ile ilgili ihtiyaçları sağlamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-194">This single timer is used to drive all GUIX time-related needs.</span></span> <span data-ttu-id="e6efc-195">Varsayılan olarak, Gux iç Zamanlayıcı işlemenin sıklığı, gx_port. h veya gx_user. h üst bilgisinde daha önce tanımlanmadığı müddetçe, **_gx_api. h_** içinde tanımlanan sabit **GX_SYSTEM_TIMER_MS** aracılığıyla 20ms olarak ayarlanır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-195">By default, the frequency for the GUIX internal timer processing is set to 20ms via the constant **GX_SYSTEM_TIMER_MS**, which is defined in **_gx_api.h_**, unless the constant is previously defined in gx_port.h or gx_user.h header.</span></span> <span data-ttu-id="e6efc-196">Varsayılan sıklık, Gux kitaplığını oluştururken veya ***gx_user. h***' de açıkça yeniden tanımlayarak, uygulama tarafından bir derleme seçeneği aracılığıyla değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-196">The default frequency may be changed by the application via a compilation option when building the GUIX library or by explicitly redefining it in ***gx_user.h***.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="e6efc-197">GUX Zamanlayıcı sıklığının RTOS Zamanlayıcı işaretleri içinde ifade edildiği ve sabit **GX_SYSTEM_TIMER_TICKS** tarafından tanımlandığını unutmayın.</span><span class="sxs-lookup"><span data-stu-id="e6efc-197">Note that the GUIX timer frequency is expressed in RTOS timer ticks, and is defined by the constant **GX_SYSTEM_TIMER_TICKS**.</span></span> <span data-ttu-id="e6efc-198">**GX_SYSTEM_TIMER_TICKS** değeri **GX_SYSTEM_TIMER_MS** ve **TX_TIMER_TICKS_PER_SECOND** kullanılarak hesaplanır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-198">The value of **GX_SYSTEM_TIMER_TICKS** is calculated using **GX_SYSTEM_TIMER_MS** and **TX_TIMER_TICKS_PER_SECOND**.</span></span> <span data-ttu-id="e6efc-199">Kullanıcı, Gux Zamanlayıcı sıklığını ve çözünürlüğünü ayarlamak için ***gx_port. h** _ veya _ *_gx_user. h_** içindeki bu değerlerden herhangi birini yeniden tanımlayabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-199">The user can re-define any of these values in the ***gx_port.h** _ or _ *_gx_user.h_** to adjust the GUIX timer frequency and resolution.</span></span>

## <a name="display-driver"></a><span data-ttu-id="e6efc-200">Görüntü sürücüsü</span><span class="sxs-lookup"><span data-stu-id="e6efc-200">Display Driver</span></span> 

<span data-ttu-id="e6efc-201">Ekran sürücüleri, çekirdek Gux koduna bir çizim işlevleri kümesi sağlamaktan sorumludur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-201">Display drivers are responsible for providing a set of drawing functions to the core GUIX code.</span></span> <span data-ttu-id="e6efc-202">Bu çizim işlevlerinin her birinin uygulanması sürücü tarafından belirlenir ve uygulamanın donanım hızlandırma desteğinden faydalanması mümkün olduğunda.</span><span class="sxs-lookup"><span data-stu-id="e6efc-202">The implementation of each of these drawing functions is determined by the driver, and when possible the implementation will leverage hardware acceleration support.</span></span> <span data-ttu-id="e6efc-203">Genel olarak çizim işlevi, fiziksel çerçeve arabelleği olabilecek bir bellek arabelleğine piksel verileri yazarak çalışır veya sürücü mimarisine bağlı olarak ikincil bir arabellek olabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-203">In general the drawing function works by writing pixel data to a memory buffer, which may be the physical frame buffer or it may be a secondary buffer depending on the driver architecture.</span></span> <span data-ttu-id="e6efc-204">Birçok sürücü iki çerçeve arabelleği kullanarak çift arabelleğe alma uygular ve bu arabellekler arabellek geçiş işlevi çağrılarak çalışır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-204">Many drivers implement double buffering using two frame buffers, and these buffers are toggled by invoking the buffer toggle function.</span></span> <span data-ttu-id="e6efc-205">GUX bu işlevleri uygun zamanlarda dahili olarak çağırır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-205">GUIX calls these functions internally at the appropriate times.</span></span> <span data-ttu-id="e6efc-206">Bellek kısıtlı sistemler için çizim işlevleri yalnızca tek bir bellek çerçeve arabelleğine yazabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-206">For memory constrained systems, the drawing functions may only write to a single memory frame buffer.</span></span>

<span data-ttu-id="e6efc-207">GUX her bir alt düzey çizim işlevinin varsayılan yazılım uygulamalarını her bir destek renk derinliğine ve biçimine sağlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-207">GUIX provides default software implementations of each low-level drawing function at every support color depth and format.</span></span> <span data-ttu-id="e6efc-208">Bu işlevler, **GX_DISPLAY** yapısı içinde tutulan işlev işaretçileri aracılığıyla çağrılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-208">These functions are invoked via function pointers maintained within the **GX_DISPLAY** structure.</span></span> <span data-ttu-id="e6efc-209">Donanıma özgü sürücüler oluşturulduğunda, genellikle bu işlev işaretçilerinden bazılarının hedef donanıma özgü işlevlerle birlikte üzerine yazılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-209">When hardware-specific drivers are created, they typically will overwrite some number of these function pointers with functions that are specific to the target hardware.</span></span>

<span data-ttu-id="e6efc-210">Tipik bir donanım görüntüleme sürücüsü, önce gerekli renk derinliği ve biçimi için varsayılan GUıDX görüntüleme sürücüsü oluşturularak uygulanır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-210">A typical hardware display driver is implemented by first creating the default GUIX display driver for the required color depth and format.</span></span>
<span data-ttu-id="e6efc-211">Daha sonra Donanım Sürücüsü, belirli donanım uygulamaları için optimize edilmiş veya özelleştirilmek zorunda olan işlevlerin yerini alır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-211">Then the hardware driver will replace those functions that need to be optimized or customized for the particular hardware implementation.</span></span>

<span data-ttu-id="e6efc-212">GUX desteği piksel rengi biçimi 1-BPP tek renkli 32-BPP a:r: g:b biçiminde değişiyor.</span><span class="sxs-lookup"><span data-stu-id="e6efc-212">GUIX support pixel color formats ranging from 1-bpp monochrome to 32-bpp a:r:g:b format.</span></span> <span data-ttu-id="e6efc-213">GUX, r:g: b ile b:g: r bayt sıralaması, paketlenmiş piksel ve sözcük hizalanmış piksel formatları ve alfa kanalları gibi her geniş renk derinliği kategorisi içinde birçok çeşitlemeyi de destekler.</span><span class="sxs-lookup"><span data-stu-id="e6efc-213">GUIX also supports many variations within each broad color-depth category, such as r:g:b versus b:g:r byte order, packed pixel versus word-aligned pixel formats, and alpha channels.</span></span> <span data-ttu-id="e6efc-214">Şu anda 25 farklı renk biçimi destekleniyor, ancak donanım satıcıları yeni Çeşitlemeler sundukça bu liste büyür.</span><span class="sxs-lookup"><span data-stu-id="e6efc-214">There are currently 25 distinct color formats supported, but this list grows as hardware vendors deliver new variations.</span></span>

## <a name="display-memory-architectures"></a><span data-ttu-id="e6efc-215">Bellek mimarilerini görüntüleme</span><span class="sxs-lookup"><span data-stu-id="e6efc-215">Display Memory Architectures</span></span>

<span data-ttu-id="e6efc-216">Çeşitli donanım hedefleri ve ekranlar, hedefin bellek kısıtlamalarına ve uygulamanın işlev gereksinimlerine bağlı olarak çeşitli farklı görüntü belleği mimarilerinden yararlanır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-216">Various hardware targets and displays utilize a variety of different display memory architectures, depending on the memory constraints of the target and the functionality requirements of the application.</span></span> <span data-ttu-id="e6efc-217">Yaygın bellek mimarilerinden bazılarını, her birinin kısa bir açıklamasıyla özetler.</span><span class="sxs-lookup"><span data-stu-id="e6efc-217">We will outline some of the common memory architectures here with a brief description of each.</span></span>

<span data-ttu-id="e6efc-218">Model 1) çerçeve arabelleği yok, dış GRAM 'da tutulan grafik verileri:</span><span class="sxs-lookup"><span data-stu-id="e6efc-218">Model 1) No frame buffer, graphics data held in external GRAM:</span></span>

![Çerçeve arabelleği yok, dış GRAM 'da tutulan grafik verileri](./media/guix/user-guide/no-frame-buffer.png)

<span data-ttu-id="e6efc-220">Yukarıdaki modelde, CPU 'ya yerel bellekte bir çerçeve arabelleği için bellek yok.</span><span class="sxs-lookup"><span data-stu-id="e6efc-220">In the model above, no memory for a frame buffer exists in memory local to the CPU.</span></span> <span data-ttu-id="e6efc-221">Tüm grafik verileri, görüntünün kendisiyle birleştirilmiş bir dış GRAM 'da depolanır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-221">All graphics data is stored in an external GRAM which is incorporated into the display itself.</span></span> <span data-ttu-id="e6efc-222">Dış GRAM arabirimi paralel veya seri olabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-222">The interface to the external GRAM can be parallel or serial.</span></span> <span data-ttu-id="e6efc-223">Bu tür bir mimari çok düşük maliyettir; ancak grafik verileri güncelleştirilirken istenmeyen bir etkisi olabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-223">This type of architecture is very low cost; however it can exhibit unwanted tearing effect when the graphics data is updated.</span></span>

<span data-ttu-id="e6efc-224">Model 2) bir yerel çerçeve arabelleği:</span><span class="sxs-lookup"><span data-stu-id="e6efc-224">Model 2) One local frame buffer:</span></span>

![Bir yerel çerçeve arabelleği](./media/guix/user-guide/one-local-frame-buffer.png)

<span data-ttu-id="e6efc-226">Bu modelde, Grafik verilerinin belleği, CPU 'ya doğrudan erişilebilen Rastgele erişimli bir bellekten ayrılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-226">In this model, memory for the graphics data is allocated from a random-access memory that is directly accessible the CPU.</span></span> <span data-ttu-id="e6efc-227">Grafik verilerini (zamanlama sinyalleriyle birlikte) yerel bellekten görüntülemeye tekrar tekrar iletmek için adanmış donanım mevcut olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-227">Dedicated hardware must be present to repeatedly transmit the graphics data (along with timing signals) from the local memory to the display.</span></span> <span data-ttu-id="e6efc-228">Bu model, grafik belleğinin, CPU tarafından kullanılabilen yerel SRAM veya DRAM 'nin bir bloğu olduğu model 1 ' den farklıdır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-228">This model differs from model 1 in that the graphics memory is a block of the local SRAM or DRAM available to the CPU.</span></span> <span data-ttu-id="e6efc-229">Bu, yığın ve program değişkenlerinin canlı olduğu bellekle aynı olabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-229">This may be the same memory in which stack and program variables live.</span></span>

<span data-ttu-id="e6efc-230">Model 3) yerel çerçeve arabelleği + dış GRAM:</span><span class="sxs-lookup"><span data-stu-id="e6efc-230">Model 3) Local frame buffer + external GRAM:</span></span>

![Yerel çerçeve arabelleği + dış GRAM](./media/guix/user-guide/local-frame-buffer-external-gram.png)

<span data-ttu-id="e6efc-232">Model 3, ilk iki öğesinin bir birleşimidir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-232">Model 3 is a combination of the first two.</span></span> <span data-ttu-id="e6efc-233">Bu modelde, bir çerçeve arabelleğini tutmak için yeterli yerel bellek vardır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-233">In this model, sufficient local memory exists to hold one frame buffer.</span></span> <span data-ttu-id="e6efc-234">Ayrıca, görüntü cihazı bir dış GRAM sağlar ve GRAM 'da sağlanan verileri kullanarak kendisini otomatik olarak yeniler.</span><span class="sxs-lookup"><span data-stu-id="e6efc-234">In addition, the display device provides an external GRAM and automatically refreshes itself using the data provided in the GRAM.</span></span> <span data-ttu-id="e6efc-235">Bu mimari, gelişmiş güncelleştirme verimliliğinden faydalanır çünkü yerel çerçeve arabelleğinin değiştirilen bölümünü tek bir blok aktarımından dış GRAM 'ya aktarabiliyoruz, genellikle ekleme DMA kanallarını kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-235">This architecture benefits from improved update efficiency because we can transfer the modified portion of the local frame buffer to the external GRAM in one block transfer, often utilizing onboard DMA channels.</span></span> <span data-ttu-id="e6efc-236">Bu model Ayrıca, yalnızca tamamlanmış grafik içerikleri dış GRAM 'a kopyalandığı için ilk iki modelden de bulunabilecek olan araçları ve titreşimi ortadan kaldırır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-236">This model also eliminates the tearing and flicker that can be present in either of the first two models, because only completed graphics contents is copied to the external GRAM.</span></span>

<span data-ttu-id="e6efc-237">Model 4) ping-pong çerçeve arabellekleri:</span><span class="sxs-lookup"><span data-stu-id="e6efc-237">Model 4) Ping-pong frame buffers:</span></span>

![Ping-pong çerçeve arabellekleri](./media/guix/user-guide/ping-pong-frame-buffers.png)

<span data-ttu-id="e6efc-239">Model 4 ' te, iki yerel çerçeve arabelleği sağlamak için yeterli bellek vardır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-239">In model 4, sufficient memory is present to provide two local frame buffers.</span></span> <span data-ttu-id="e6efc-240">Bu durumda, GUıDX, bir çerçeve arabelleğini etkin çerçeve arabelleği ve diğeri ise çalışma çerçevesi arabelleği olarak değerlendirir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-240">In this case, GUIX treats one frame buffer as the active frame buffer, and the other as the working frame buffer.</span></span> <span data-ttu-id="e6efc-241">Bir görüntüleme güncelleştirmesi veya çizim işlemi devam ederken, çalışma arabelleğinde gerçekleşir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-241">When a display update or drawing operation is in progress, it takes place in the working buffer.</span></span> <span data-ttu-id="e6efc-242">Çizim işlemi tamamlandığında, arabellekler çalışır ve çalışma arabelleği etkin arabellek olur ve etkin arabellek çalışma arabelleği olur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-242">When the drawing operation completes, the buffers are toggled, and the working buffer becomes the active buffer and the active buffer becomes the working buffer.</span></span> <span data-ttu-id="e6efc-243">Bu model, Ayrıca, tek bir arabelleğe alınmış sistemde gözlemlenebilir ekran titreşimini ve yük korumasını ortadan kaldırır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-243">This model also eliminates screen flicker and tearing that can be observed in a single buffered system.</span></span>

<span data-ttu-id="e6efc-244">Model 5) tuval birleştirme ile Pong arabellekleri:</span><span class="sxs-lookup"><span data-stu-id="e6efc-244">Model 5) Ping-pong buffers with canvas compositing:</span></span>

![Tuval birleştirme özellikli ping-pong arabellekleri](./media/guix/user-guide/ping-pong-buffers-canvas-composting.png)

<span data-ttu-id="e6efc-246">Model 5 ' te, kullanılabilir belleğin sınırlarına kadar herhangi bir sayıda canvaya oluşturulabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-246">In model 5, any number of canvases can be created, up to the limits of available memory.</span></span> <span data-ttu-id="e6efc-247">Tuvaller, tuval bileşimini oluşturmak için uygulama tarafından tanımlanan şekilde kaplama veya karışacaktır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-247">The canvases can be overlaid or blended together as defined by the application to create the canvas composite.</span></span> <span data-ttu-id="e6efc-248">Bir ekran yenileme işleminden sonra yeni bir bileşik oluşturulduğunda, etkin ve çalışan bileşik arabellekler standart ping-pong arabellek mimarisine benzer bir işlem halinde yapılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-248">When a new composite is created after a screen refresh operation, the active and working composite buffers are toggled in an operation identical to the standard ping-pong buffer architecture.</span></span> <span data-ttu-id="e6efc-249">Model 5 ' i, son çıkış bileşik ' e karışarak ekran belirme ve karıştırma işlemlerini gerçekleştirme yeteneği ekler.</span><span class="sxs-lookup"><span data-stu-id="e6efc-249">Model 5 adds the ability to perform screen fade and blending operations by blending the canvases into the final output composite.</span></span>

<span data-ttu-id="e6efc-250">Model 6) dış GRAM ile tuval birleştirme:</span><span class="sxs-lookup"><span data-stu-id="e6efc-250">Model 6) Canvas compositing with external GRAM:</span></span>

![Dış GRAM ile tuval birleştirme](./media/guix/user-guide/canvas-compositing-external-gram.png)

<span data-ttu-id="e6efc-252">Model 6, 5 ' teki hafif bir çeşittir ve yalnızca bir bileşik arabelleğin gerekli olduğu ve bileşik arabelleğin dış GRAM 'ya aktarılmasının.</span><span class="sxs-lookup"><span data-stu-id="e6efc-252">Model 6 is a slight variation on Model 5, in which only one composite buffer is required and the composite buffer is then transferred to external GRAM.</span></span> <span data-ttu-id="e6efc-253">Bu model, tam ekran karıştırma ve yer paylaşımlarını da destekler.</span><span class="sxs-lookup"><span data-stu-id="e6efc-253">This model also supports full screen blending and overlays.</span></span>

## <a name="string-encoding"></a><span data-ttu-id="e6efc-254">Dize kodlama</span><span class="sxs-lookup"><span data-stu-id="e6efc-254">String Encoding</span></span> 

<span data-ttu-id="e6efc-255">GUX varsayılan olarak UTF8 biçim dize kodlamasını destekler.</span><span class="sxs-lookup"><span data-stu-id="e6efc-255">GUIX by default supports UTF8 format string encoding.</span></span> <span data-ttu-id="e6efc-256">***Gx_user. h*** üstbilgi dosyasında **GX_DISABLE_UTF8_SUPPORT** tanımlayarak UTF8 dize kodlaması desteği devre dışı bırakılabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-256">Support for UTF8 string encoding can be disabled by defining **GX_DISABLE_UTF8_SUPPORT** in the ***gx_user.h*** header file.</span></span> <span data-ttu-id="e6efc-257">UTF8 kodlaması devre dışıysa, GUıDX yalnızca standart 8 bit ASCII ve Latin-1 kod sayfası karakter kodlamasını kullanır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-257">If UTF8 encoding is disabled, GUIX will internally use only standard 8-bit ASCII plus Latin-1 code page character encoding.</span></span> <span data-ttu-id="e6efc-258">UTF8 dize kodlamasının devre dışı bırakılması, biraz daha küçük bir Gux kitaplığı ayak izine ve dize işleme ve metin çizim işlevlerinin biraz daha hızlı bir şekilde yürütülmesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-258">Disabling UTF8 string encoding results in a slightly smaller GUIX library footprint and slightly faster runtime execution of string handling and text drawing functions.</span></span>

<span data-ttu-id="e6efc-259">UTF8 dize kodlaması aşağıdaki nitelikleri içerir:</span><span class="sxs-lookup"><span data-stu-id="e6efc-259">UTF8 string encoding has the following traits:</span></span>

  - <span data-ttu-id="e6efc-260">ASCII dizeleri standart 7 bit ASCII kodlamasından daha fazla depolama alanı almaz.</span><span class="sxs-lookup"><span data-stu-id="e6efc-260">ASCII strings take no more storage space than standard 7-bit ASCII encoding.</span></span>

  - <span data-ttu-id="e6efc-261">Çoğu ANSI-C dize işlevleri, hiçbir değişiklik yapılmadan UTF8 dize kodlaması ile çalışır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-261">Most ANSI-C string functions work with UTF8 string encoding without modification.</span></span>

<span data-ttu-id="e6efc-262">Kanji karakter kümeleri de dahil olmak üzere dünyanın tüm etkin karakter kümeleri, UTF8 dize kodlaması ile gösterilebilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-262">All active character sets in the world, including Kanji character sets, can be represented using UTF8 string encoding.</span></span>

### <a name="static-and-dynamic-strings"></a><span data-ttu-id="e6efc-263">Statik ve dinamik dizeler</span><span class="sxs-lookup"><span data-stu-id="e6efc-263">Static and Dynamic Strings</span></span> 

<span data-ttu-id="e6efc-264">Metin görüntülemeyi destekleyen GUıDX pencere öğelerinizi atanan dizeler, normalde aşağıda açıklanan Gux dize tablosunun bir parçası olarak sabit depolamaya yerleştirilmiş olan statik olarak tanımlanmış dize sabitleri ve \***sprintf** _ veya _ *_gx_utility_ltoa_* \* gibi hizmetler kullanılarak çalışma zamanında oluşturulan dizeler olan dinamik olarak tanımlanmış dizeler olabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-264">The strings assigned to your GUIX widgets which support text display can be statically defined string constants, which are normally placed in constant storage as part of the GUIX String table described below, and dynamically defined strings, which are strings generated at runtime using services such as ***sprintf** _ or _*_gx_utility_ltoa_\*\*.</span></span>

<span data-ttu-id="e6efc-265">Dinamik dizeler örnekleri, bir Gux istem pencere öğesi içinde sayı olarak veya kullanıcının konum ve biçim tercihlerine göre dinamik olarak biçimlendirilen bir "saat/tarih" dizesi olarak görüntülenmiş bir değer içerebilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-265">Examples of dynamic strings might include a value displayed as a number within a GUIX prompt widget, or a “time / date” string which is dynamically formatted based on the user’s location and format preferences.</span></span> <span data-ttu-id="e6efc-266">Çalışma zamanında **GX_PROMPT** veya **GX_TEXT_BUTTON pencere öğeleri** gibi Guix pencere sayfalarına atanacak dizeler oluşturursanız, bu çalışma zamanı tarafından oluşturulan dizeler için depolamayı statik olarak ayırmayı seçmeniz gerekir (ör.</span><span class="sxs-lookup"><span data-stu-id="e6efc-266">If you create strings at runtime which will be assigned to GUIX widgets such as **GX_PROMPT** or **GX_TEXT_BUTTON widgets**, you must choose to either statically allocate the storage for these runtime generated strings (i.e</span></span>
<span data-ttu-id="e6efc-267">Genel karakter dizileri) veya dinamik bir bellek ayırıcı işlevi tanımlayabilir ve yükleyebilir ve bu pencere öğelerinin atanan metin dizelerinin özel bir kopyasını oluşturmasına yönlendiren **GX_STYLE_TEXT_COPY** stilini kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e6efc-267">global character arrays), or you can define and install a dynamic memory allocator function and use the **GX_STYLE_TEXT_COPY** style, which instructs those widgets to create a private copy of text strings assigned.</span></span>

<span data-ttu-id="e6efc-268">Dinamik olarak oluşturulan bir dizeyi tutmak ve sonra bu dizeyi **GX_STYLE_TEXT_COPY** stiline sahip olmayan bir pencere öğesine atamak için, otomatik karakter dizisi gibi geçici depolamayı kullanmanın bir programlama hatasıdır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-268">It is a programming error to use temporary storage, such as an automatic character array, to hold a dynamically generated string and then assign this string to a widget that does not have the **GX_STYLE_TEXT_COPY** style.</span></span> <span data-ttu-id="e6efc-269">Bu stil etkin olmadığında pencere öğesi yalnızca sağlanan dize işaretçisini kopyalar ve dize verileri statik olarak ayrılmalıdır veya pencere öğesi dize işaretçisi, beklenmeyen sonuçlar üreten çöp verilerinde büyük olasılıkla bitecektir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-269">When this style is not enabled, the widget simply copies the provided string pointer, and the string data must be statically allocated or the widget string pointer will likely end up pointing at garbage data producing unpredictable results.</span></span>

### <a name="passing-gx_string-arguments"></a><span data-ttu-id="e6efc-270">GX_STRING bağımsız değişkenlerini geçirme</span><span class="sxs-lookup"><span data-stu-id="e6efc-270">Passing GX_STRING arguments</span></span> 

<span data-ttu-id="e6efc-271">GX_STRING parametresini kabul eden Gux API işlevleri, **GX_STRING. gx_string_ptr** alanı tarafından işaret edilen dizenin uzunluğunun **GX_STRING. gx_string_length** alanının değeriyle eşleştiğini her zaman doğrular.</span><span class="sxs-lookup"><span data-stu-id="e6efc-271">The GUIX API functions which accept a GX_STRING parameter always verify that the length of the string pointed to by the **GX_STRING.gx_string_ptr** field match the value of the **GX_STRING.gx_string_length** field.</span></span> <span data-ttu-id="e6efc-272">İki alan tutarlı değilse, **GX_INVALID_STRING_LENGTH** bir hata döndürülür ve çağrılan API, dize atamasını kabul etmeden döndürülür.</span><span class="sxs-lookup"><span data-stu-id="e6efc-272">If the two fields are not consistent, a **GX_INVALID_STRING_LENGTH** error is returned and the API called returns without accepting the string assignment.</span></span>

<span data-ttu-id="e6efc-273">GUX yazılımının güvenlik açısından dikkat edilmesi gereken noktalar, \***strlen** _ veya _ *_strcpy_* \* gibi standart C dize işlevlerini hiçbir zaman kullanmaz.</span><span class="sxs-lookup"><span data-stu-id="e6efc-273">For safety considerations the GUIX software never internally uses the standard C string functions such as ***strlen** _ or _*_strcpy_\*\*.</span></span> <span data-ttu-id="e6efc-274">Bu işlevlerin, genellikle bağlı uygulamalarda bu durum büyük bir süredir olan dize verileri dinamik olarak elde edildiğinde kötü amaçlı saldırılara açıktır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-274">These functions have been known to be susceptible to malicious attacks when string data is acquired dynamically which is often the case with connected applications.</span></span>

<span data-ttu-id="e6efc-275">Bir parametre olarak kabul edilen () sürüm 5,6 tanımlı API işlevlerinden önce Gux kitaplığı yayınları `GX_CONST GX_CHAR *text` .</span><span class="sxs-lookup"><span data-stu-id="e6efc-275">GUIX library releases prior to release 5.6 defined API functions which accepted (`GX_CONST GX_CHAR *text`) as a parameter.</span></span> <span data-ttu-id="e6efc-276">Bu işlevler, geriye doğru uyumluluk için hala desteklenirken, bir giriş parametresi olarak kabul edilen () tercih edilen API işlevleri tarafından kullanımdan kaldırılmıştır ve değiştirilmiştir `GX_CONST GX_STRING *string` .</span><span class="sxs-lookup"><span data-stu-id="e6efc-276">These functions, while still supported for backwards compatibility, have been obsoleted and replaced by the preferred API functions which accept (`GX_CONST GX_STRING *string`) as an input parameter.</span></span>

<span data-ttu-id="e6efc-277">Varsayılan olarak, kullanım dışı bırakılan metin işleme API 'SI, önceden yazılmış tüm uygulamaların Gux kitaplığındaki en son güncelleştirmelerle düzgün bir şekilde derlenmesine olanak tanımak için etkinleştirilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-277">By default, the deprecated text handling API is enabled allowing all previously written applications to build cleanly with the latest updates to the GUIX library.</span></span> <span data-ttu-id="e6efc-278">Kullanım dışı bırakılan metin işleme API 'sini devre dışı bırakmak için **GX_DISABLE_DEPRECATED_STRING_API** tanım **_gx_user. h_\*_ üst bilgi dosyasına eklenmelidir. Tüm yeni uygulamalar _ GX_DISABLE_DEPRECATED_STRING_API tanımlamalıdır**\* ve yalnızca değiştirme API işlevlerini kullanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-278">To disable the the deprecated text handling API, the definition **GX_DISABLE_DEPRECATED_STRING_API** should be added to the **_gx_user.h_*_ header file. All new applications should define _\* GX_DISABLE_DEPRECATED_STRING_API*\* and should use only the replacement API functions.</span></span> <span data-ttu-id="e6efc-279">GUX kitaplığı sürüm sürüm 5,6 veya üzeri için Gux Studio tarafından oluşturulan tüm çıkış dosyaları yalnızca değiştirme API işlevlerini kullanır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-279">All output files generated by GUIX Studio for GUIX library version release 5.6 or later will utilize only the replacement API functions.</span></span>

<span data-ttu-id="e6efc-280">Aşağıdaki tabloda, kullanım dışı ve yeni tanımlanmış değiştirme API 'SI işlev adları listelenmektedir:</span><span class="sxs-lookup"><span data-stu-id="e6efc-280">The following table lists the deprecated and newly defined replacement API function names:</span></span>

| <span data-ttu-id="e6efc-281">**Kullanım dışı Işlev adı**</span><span class="sxs-lookup"><span data-stu-id="e6efc-281">**Deprecated Function Name**</span></span>              | <span data-ttu-id="e6efc-282">**Yenisiyle değiştirilmiş**</span><span class="sxs-lookup"><span data-stu-id="e6efc-282">**Replaced With**</span></span>                              |
| ------------------------------------------ | ----------------------------------------------- |
| <span data-ttu-id="e6efc-283">gx_binres_language_table_load</span><span class="sxs-lookup"><span data-stu-id="e6efc-283">gx_binres_language_table_load</span></span>          | <span data-ttu-id="e6efc-284">gx_binres_language_table_load_ext</span><span class="sxs-lookup"><span data-stu-id="e6efc-284">gx_binres_language_table_load_ext</span></span>          |
| <span data-ttu-id="e6efc-285">gx_canvas_rotated_text_draw</span><span class="sxs-lookup"><span data-stu-id="e6efc-285">gx_canvas_rotated_text_draw</span></span>            | <span data-ttu-id="e6efc-286">gx_canvas_rotated_text_draw_ext</span><span class="sxs-lookup"><span data-stu-id="e6efc-286">gx_canvas_rotated_text_draw_ext</span></span>            |
| <span data-ttu-id="e6efc-287">gx_canvas_text_draw</span><span class="sxs-lookup"><span data-stu-id="e6efc-287">gx_canvas_text_draw</span></span>                     | <span data-ttu-id="e6efc-288">gx_canvas_text_draw_ext</span><span class="sxs-lookup"><span data-stu-id="e6efc-288">gx_canvas_text_draw_ext</span></span>                     |
| <span data-ttu-id="e6efc-289">gx_context_string_get</span><span class="sxs-lookup"><span data-stu-id="e6efc-289">gx_context_string_get</span></span>                   | <span data-ttu-id="e6efc-290">gx_context_string_get_ext</span><span class="sxs-lookup"><span data-stu-id="e6efc-290">gx_context_string_get_ext</span></span>                   |
| <span data-ttu-id="e6efc-291">gx_display_language_table_get</span><span class="sxs-lookup"><span data-stu-id="e6efc-291">gx_display_language_table_get</span></span>          | <span data-ttu-id="e6efc-292">gx_display_language_table_get_ext</span><span class="sxs-lookup"><span data-stu-id="e6efc-292">gx_display_language_table_get_ext</span></span>          |
| <span data-ttu-id="e6efc-293">gx_display_language_table_set</span><span class="sxs-lookup"><span data-stu-id="e6efc-293">gx_display_language_table_set</span></span>          | <span data-ttu-id="e6efc-294">gx_display_language_table_set_ext</span><span class="sxs-lookup"><span data-stu-id="e6efc-294">gx_display_language_table_set_ext</span></span>          |
| <span data-ttu-id="e6efc-295">gx_display_string_get</span><span class="sxs-lookup"><span data-stu-id="e6efc-295">gx_display_string_get</span></span>                   | <span data-ttu-id="e6efc-296">gx_display_string_get_ext</span><span class="sxs-lookup"><span data-stu-id="e6efc-296">gx_display_string_get_ext</span></span>                   |
| <span data-ttu-id="e6efc-297">gx_display_string_table_get</span><span class="sxs-lookup"><span data-stu-id="e6efc-297">gx_display_string_table_get</span></span>            | <span data-ttu-id="e6efc-298">gx_display_string_table_get_ext</span><span class="sxs-lookup"><span data-stu-id="e6efc-298">gx_display_string_table_get_ext</span></span>            |
| <span data-ttu-id="e6efc-299">gx_multi_line_text_button_text_set</span><span class="sxs-lookup"><span data-stu-id="e6efc-299">gx_multi_line_text_button_text_set</span></span>   | <span data-ttu-id="e6efc-300">gx_multi_line_text_button_text_set_ext</span><span class="sxs-lookup"><span data-stu-id="e6efc-300">gx_multi_line_text_button_text_set_ext</span></span>   |
| <span data-ttu-id="e6efc-301">gx_multi_line_text_input_char_insert</span><span class="sxs-lookup"><span data-stu-id="e6efc-301">gx_multi_line_text_input_char_insert</span></span> | <span data-ttu-id="e6efc-302">gx_multi_line_text_input_char_insert_ext</span><span class="sxs-lookup"><span data-stu-id="e6efc-302">gx_multi_line_text_input_char_insert_ext</span></span> |
| <span data-ttu-id="e6efc-303">gx_multi_line_text_input_text_set</span><span class="sxs-lookup"><span data-stu-id="e6efc-303">gx_multi_line_text_input_text_set</span></span>    | <span data-ttu-id="e6efc-304">gx_multi_line_text_input_text_set_ext</span><span class="sxs-lookup"><span data-stu-id="e6efc-304">gx_multi_line_text_input_text_set_ext</span></span>    |
| <span data-ttu-id="e6efc-305">gx_multi_line_text_view_text_set</span><span class="sxs-lookup"><span data-stu-id="e6efc-305">gx_multi_line_text_view_text_set</span></span>     | <span data-ttu-id="e6efc-306">gx_multi_line_text_view_text_set_ext</span><span class="sxs-lookup"><span data-stu-id="e6efc-306">gx_multi_line_text_view_text_set_ext</span></span>     |
| <span data-ttu-id="e6efc-307">gx_prompt_text_get</span><span class="sxs-lookup"><span data-stu-id="e6efc-307">gx_prompt_text_get</span></span>                      | <span data-ttu-id="e6efc-308">gx_prompt_text_get_ext</span><span class="sxs-lookup"><span data-stu-id="e6efc-308">gx_prompt_text_get_ext</span></span>                      |
| <span data-ttu-id="e6efc-309">gx_prompt_text_set</span><span class="sxs-lookup"><span data-stu-id="e6efc-309">gx_prompt_text_set</span></span>                      | <span data-ttu-id="e6efc-310">gx_prompt_text_set_ext</span><span class="sxs-lookup"><span data-stu-id="e6efc-310">gx_prompt_text_set_ext</span></span>                      |
| <span data-ttu-id="e6efc-311">gx_single_line_text_input_text_set</span><span class="sxs-lookup"><span data-stu-id="e6efc-311">gx_single_line_text_input_text_set</span></span>   | <span data-ttu-id="e6efc-312">gx_single_line_text_input_text_set_ext</span><span class="sxs-lookup"><span data-stu-id="e6efc-312">gx_single_line_text_input_text_set_ext</span></span>   |
| <span data-ttu-id="e6efc-313">gx_system_string_width_get</span><span class="sxs-lookup"><span data-stu-id="e6efc-313">gx_system_string_width_get</span></span>             | <span data-ttu-id="e6efc-314">gx_system_string_width_get_ext</span><span class="sxs-lookup"><span data-stu-id="e6efc-314">gx_system_string_width_get_ext</span></span>             |
| <span data-ttu-id="e6efc-315">gx_system_version_string_get</span><span class="sxs-lookup"><span data-stu-id="e6efc-315">gx_system_version_string_get</span></span>           | <span data-ttu-id="e6efc-316">gx_system_version_string_get_ext</span><span class="sxs-lookup"><span data-stu-id="e6efc-316">gx_system_version_string_get_ext</span></span>           |
| <span data-ttu-id="e6efc-317">gx_text_button_text_get</span><span class="sxs-lookup"><span data-stu-id="e6efc-317">gx_text_button_text_get</span></span>                | <span data-ttu-id="e6efc-318">gx_text_button_text_get_ext</span><span class="sxs-lookup"><span data-stu-id="e6efc-318">gx_text_button_text_get_ext</span></span>                |
| <span data-ttu-id="e6efc-319">gx_text_button_text_set</span><span class="sxs-lookup"><span data-stu-id="e6efc-319">gx_text_button_text_set</span></span>                | <span data-ttu-id="e6efc-320">gx_text_button_text_set_ext</span><span class="sxs-lookup"><span data-stu-id="e6efc-320">gx_text_button_text_set_ext</span></span>                |
| <span data-ttu-id="e6efc-321">gx_text_scroll_wheel_callback_set</span><span class="sxs-lookup"><span data-stu-id="e6efc-321">gx_text_scroll_wheel_callback_set</span></span>     | <span data-ttu-id="e6efc-322">gx_text_scroll_wheel_callback_set_ext</span><span class="sxs-lookup"><span data-stu-id="e6efc-322">gx_text_scroll_wheel_callback_set_ext</span></span>     |
| <span data-ttu-id="e6efc-323">gx_utility_string_to_alphamap</span><span class="sxs-lookup"><span data-stu-id="e6efc-323">gx_utility_string_to_alphamap</span></span>          | <span data-ttu-id="e6efc-324">gx_utility_string_to_alphamap_ext</span><span class="sxs-lookup"><span data-stu-id="e6efc-324">gx_utility_string_to_alphamap_ext</span></span>          |
| <span data-ttu-id="e6efc-325">gx_widget_string_get</span><span class="sxs-lookup"><span data-stu-id="e6efc-325">gx_widget_string_get</span></span>                    | <span data-ttu-id="e6efc-326">gx_widget_string_get_ext</span><span class="sxs-lookup"><span data-stu-id="e6efc-326">gx_widget_string_get_ext</span></span>                    |
| <span data-ttu-id="e6efc-327">gx_widget_text_blend</span><span class="sxs-lookup"><span data-stu-id="e6efc-327">gx_widget_text_blend</span></span>                    | <span data-ttu-id="e6efc-328">gx_widget_text_blend_ext</span><span class="sxs-lookup"><span data-stu-id="e6efc-328">gx_widget_text_blend_ext</span></span>                    |
| <span data-ttu-id="e6efc-329">gx_widget_text_draw</span><span class="sxs-lookup"><span data-stu-id="e6efc-329">gx_widget_text_draw</span></span>                     | <span data-ttu-id="e6efc-330">gx_widget_text_draw_ext</span><span class="sxs-lookup"><span data-stu-id="e6efc-330">gx_widget_text_draw_ext</span></span>                     |

### <a name="guix-string-table"></a><span data-ttu-id="e6efc-331">GUX dize tablosu</span><span class="sxs-lookup"><span data-stu-id="e6efc-331">GUIX String Table</span></span> 

<span data-ttu-id="e6efc-332">GUX dize tablosu ve dize kaynakları bir GUıDX görüntüleme örneğiyle kaydedilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-332">The GUIX string table and string resources are registered with a GUIX display instance.</span></span>

<span data-ttu-id="e6efc-333">Birden çok görüntü sisteminde bulunan her ekran kendi dize tablosuna sahiptir ve her bir ekran kendi seçtiğiniz dilde çalıştırılabilir. Diğer Gux kaynak türleri (renkler, yazı tipleri ve pixelmaps), bu kaynak türleri her bir ekran renk biçimi ve renk derinliğine özgü olduğundan, Gux görüntüleme bileşeni tarafından da korunur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-333">Each display in a multi-display system has its own string table, and each display can run in its own selected language.The other GUIX resource types (colors, fonts, and pixelmaps) are also maintained by the GUIX Display component, since these resource types are specific to each display color format and color depth.</span></span>

<span data-ttu-id="e6efc-334">Uygulama dizesi tablonuzu el ile oluşturabilirsiniz, ancak genellikle görüntüleme dizesi tablosu, proje kaynak dosyanızın bir parçası olarak Gux Studio uygulaması tarafından tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-334">While you can manually create your application string table, most often the display string table is defined by the GUIX Studio application as part of your project resource file.</span></span> <span data-ttu-id="e6efc-335">Kullanılabilir diller, kaynak üst bilgi dosyasında da tanımlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-335">The available languages are also defined in the resource header file.</span></span> <span data-ttu-id="e6efc-336">Görüntüleme dizesi tablosu, uygulama dizelerine yönelik işaretçilerin çok sütunlu bir tablosudur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-336">The display string table is a multi-column table of pointers to application strings.</span></span> <span data-ttu-id="e6efc-337">Dize tablosunun her sütunu, uygulama tarafından desteklenen bir dili temsil eder.</span><span class="sxs-lookup"><span data-stu-id="e6efc-337">Each column of the string table represents one language supported by the application.</span></span>
<span data-ttu-id="e6efc-338">Uygulamanız yalnızca bir dili destekliyorsa (örneğin Ingilizce), dize tablonuzun yalnızca bir sütunu olur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-338">If your application supports only one language, for example English, then your string table will have only one column.</span></span> <span data-ttu-id="e6efc-339">Yine de, uygulama yazılımınızı değiştirmeden istediğiniz zaman ek dil desteği ekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e6efc-339">Still, you can add support for additional languages at any time without modifying your application software.</span></span>

<span data-ttu-id="e6efc-340">Etkin dize tablosu ***gx_display_string_table_set*** API işlevi çağırarak atanır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-340">The active string table is assigned by calling the ***gx_display_string_table_set*** API function.</span></span> <span data-ttu-id="e6efc-341">Bu işlev, GUıDX Studio tarafından oluşturulan başlangıç kodu tarafından otomatik olarak çağrılır, ancak aynı zamanda etkin dize tablosunu değiştirmek için doğrudan uygulama tarafından çağrılabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-341">This function is called automatically by the GUIX Studio generated startup code, but can also be called directly by the application to change the active string table.</span></span>

<span data-ttu-id="e6efc-342">Etkin dil ***gx_display_active_language_set*** API işlevi çağırarak atanır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-342">The active language is assigned by calling the ***gx_display_active_language_set*** API function.</span></span> <span data-ttu-id="e6efc-343">Bu işlev, görüntüleme dizesi tablosunun hangi sütununun etkin olduğunu belirler.</span><span class="sxs-lookup"><span data-stu-id="e6efc-343">This function determines which column of the display string table is active.</span></span>

<span data-ttu-id="e6efc-344">Bu işlev çağrıldığında, tüm görünür GUıDX pencere öğeleri için **GX_EVENT_LANGUAGE_CHANGE** bir olay gönderilir ve bu da yeni etkin dize verilerini görüntüleyecek şekilde güncelleştirilmesine izin verir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-344">When this function is invoked, a **GX_EVENT_LANGUAGE_CHANGE** event is sent to all visible GUIX widgets, allowing them to update to display the newly active string data.</span></span>

<span data-ttu-id="e6efc-345">Pencere öğeleri ve uygulama yazılımı, dize KIMLIĞI değerlerini ve ***gx_display_string_get_ext*** ya da ***gx_widget_string_get_ext*** API işlevlerini kullanarak statik olarak tanımlanan dizeleri çözer.</span><span class="sxs-lookup"><span data-stu-id="e6efc-345">Widgets and application software resolve statically defined strings using string ID values and the ***gx_display_string_get_ext*** or ***gx_widget_string_get_ext*** API functions.</span></span> <span data-ttu-id="e6efc-346">Bu işlevler, belirtilen bir dize KIMLIĞI ve şu anda etkin olan dil ile ilişkili **GX_STRING** döndürür.</span><span class="sxs-lookup"><span data-stu-id="e6efc-346">These functions return the **GX_STRING** associated with a given string ID and the currently active language.</span></span>

### <a name="bi-directional-text-display"></a><span data-ttu-id="e6efc-347">İki yönlü metin görüntüleme</span><span class="sxs-lookup"><span data-stu-id="e6efc-347">Bi-directional Text Display</span></span> 

<span data-ttu-id="e6efc-348">GUX iki yönlü metin desteği için iki strateji sağlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-348">GUIX provide two strategies for bi-directional text support.</span></span>

<span data-ttu-id="e6efc-349">Bir seçenek, Gux Studio uygulamasında bidi metin yeniden sıralamayı yapmak.</span><span class="sxs-lookup"><span data-stu-id="e6efc-349">One option is to do bidi text reordering within the GUIX Studio application.</span></span> <span data-ttu-id="e6efc-350">Bu seçeneğin kullanılması, ekran düzeninde bidi metnini çıkış dosyasına oluşturmaktan sorumludur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-350">Using this option GUIX Studio is responsible for generating bidi text to the output file in its display order.</span></span> <span data-ttu-id="e6efc-351">Bu çözüm, çalışma zamanı performansı üzerinde sıfır etkiye sahiptir ve Gux çalışma zamanı kitaplığı için herhangi bir ekleme gerektirmez.</span><span class="sxs-lookup"><span data-stu-id="e6efc-351">This solution has zero impact on the runtime performance and does not require any additions to the GUIX runtime library.</span></span> <span data-ttu-id="e6efc-352">GUX Studio 'Nun displayorder bidi metin dizeleri oluşturmasına izin vermek için, Gux Studio dil yapılandırması iletişim kutusunda, **görüntüleme düzeninde bidi metni oluştur** onay kutusunu seçmeniz gerekir:</span><span class="sxs-lookup"><span data-stu-id="e6efc-352">To allow GUIX Studio to generate displayorder bidi text strings, you should select the **Generate Bidi Text in Display Order** checkbox in the GUIX Studio language configuration dialog:</span></span>

![Dilleri yapılandırma](./media/guix/user-guide/configure-languages.png)

<span data-ttu-id="e6efc-354">Bu seçenekler seçiliyken, oluşturulan kaynak dosyası görüntüleme düzeninde oluşturulan bidi dizelerini içerir ve Gux çalışma zamanı kitaplığı içinde ek işlem gerekmez.</span><span class="sxs-lookup"><span data-stu-id="e6efc-354">With these options selected, the generated resource file will contain Bidi strings generated in display order, and no extra processing is required within the GUIX runtime library.</span></span>

<span data-ttu-id="e6efc-355">İkinci seçenek, çalışma zamanında çift yönlü metin yeniden sıralamayı yapmak.</span><span class="sxs-lookup"><span data-stu-id="e6efc-355">The second option is to do bidi text reordering at runtime.</span></span> <span data-ttu-id="e6efc-356">Bu seçenek, dinamik olarak tanımlanan ve Gux Studio uygulaması tarafından oluşturulmayan bidi metin dizesini işlemesi gereken uygulamalar için desteklenir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-356">This option is supported for those applications that must handle bidi text string that are dynamically defined, and not generated by the GUIX Studio application.</span></span> <span data-ttu-id="e6efc-357">Bu durumda, Gux çalışma zamanı kitaplığı her metin dizesini çizmadan önce çift yönlü metnin yeniden sıralanması sorumludur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-357">In this case the GUIX runtime library is responsible for reordering the bidi text before drawing each text string.</span></span> <span data-ttu-id="e6efc-358">Bu çözümün çalışma zamanı performansı ve bellek etkisi vardır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-358">This solution has a runtime performance and memory impact.</span></span> <span data-ttu-id="e6efc-359">Bidi metin yeniden sıralama işlemi için yeterli dinamik bellek kullanılabilir olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-359">Sufficient dynamic memory must be available for bidi text reordering process.</span></span> <span data-ttu-id="e6efc-360">Bu çözüm, Gux kitaplığı oluşturulurken koşullu GX_DYNAMIC_BIDI_TEXT_SUPPORT tanımlanmasını gerektirir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-360">This solution requires that the conditional GX_DYNAMIC_BIDI_TEXT_SUPPORT be defined when building the GUIX library.</span></span> <span data-ttu-id="e6efc-361">***Gx_system_bidi_text_enable*** ve ***gx_system_bidi_text_disable*** iki API işlevi, çalışma zamanında çift yönlü metin desteğini etkinleştirmek/devre dışı bırakmak için verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-361">Two API functions ***gx_system_bidi_text_enable*** and ***gx_system_bidi_text_disable*** are provided to enable/disable bidi text support at runtime.</span></span>

<span data-ttu-id="e6efc-362">Hem **GX_DYNAMIC_BIDI_TEXT_SUPPORT** hem de Gux Studio 'yu, görüntüleme düzeninde çift yönlü metin oluşturacak şekilde yapılandırmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-362">You should not use both **GX_DYNAMIC_BIDI_TEXT_SUPPORT** and configure GUIX Studio to generate Bidi text in display order.</span></span> <span data-ttu-id="e6efc-363">Bidi metin dizesi işleme için bir strateji veya diğerini seçmelisiniz.</span><span class="sxs-lookup"><span data-stu-id="e6efc-363">You must select one strategy or the other for bidi text string handling.</span></span>

## <a name="memory-usage"></a><span data-ttu-id="e6efc-364">Bellek Kullanımı</span><span class="sxs-lookup"><span data-stu-id="e6efc-364">Memory Usage</span></span> 

<span data-ttu-id="e6efc-365">GUX, uygulama programıyla birlikte bulunur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-365">GUIX resides along with the application program.</span></span> <span data-ttu-id="e6efc-366">Sonuç olarak, GUıDX 'in statik bellek (veya sabit bellek) kullanımı geliştirme araçları tarafından belirlenir; Örneğin, derleyici, bağlayıcı ve bulucu.</span><span class="sxs-lookup"><span data-stu-id="e6efc-366">As a result, the static memory (or fixed memory) usage of GUIX is determined by the development tools; e.g., the compiler, linker, and locator.</span></span> <span data-ttu-id="e6efc-367">Dinamik bellek (veya çalışma zamanı belleği) kullanımı, uygulamanın doğrudan denetimi altındadır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-367">Dynamic memory (or run-time memory) usage is under direct control of the application.</span></span>

### <a name="static-memory-usage"></a><span data-ttu-id="e6efc-368">Statik bellek kullanımı</span><span class="sxs-lookup"><span data-stu-id="e6efc-368">Static Memory Usage</span></span> 

<span data-ttu-id="e6efc-369">Geliştirme araçlarının çoğu, uygulama programı görüntüsünü beş temel alana böler: *yönerge*, *sabit*, *başlatılan veriler*, *başlatılmamış veriler* ve *guıdx iş parçacığı yığını*.</span><span class="sxs-lookup"><span data-stu-id="e6efc-369">Most of the development tools divide the application program image into five basic areas: *instruction*, *constant*, *initialized data*, *uninitialized data*, and the *GUIX thread stack*.</span></span> <span data-ttu-id="e6efc-370">Şekil x sayfasında bu bellek alanlarının bir örneği gösterilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-370">Figure X on page X shows an example of these memory areas.</span></span>

<span data-ttu-id="e6efc-371">Bunun yalnızca bir örnek olduğunu anlamak önemlidir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-371">It is important to understand that this only an example.</span></span> <span data-ttu-id="e6efc-372">Gerçek statik bellek düzeni işlemci, geliştirme araçları, temel alınan donanım ve uygulamanın kendisi için özeldir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-372">The actual static memory layout is specific to the processor, development tools, underlying hardware, and the application itself.</span></span>

<span data-ttu-id="e6efc-373">Yönerge alanı, programın işlemci yönergelerini içerir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-373">The instruction area contains all of the program’s processor instructions.</span></span> <span data-ttu-id="e6efc-374">Bu alan genellikle ROM ' da bulunur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-374">This area is often located in ROM.</span></span>

<span data-ttu-id="e6efc-375">Sabit alan, varsayılan ayarları ve tüm uygulama kaynaklarını (görüntüler, dizeler, yazı tipleri ve renkler) içeren, farklı derlenmiş sabitler içerir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-375">The constant area contains various compiled constants, which in GUIX contains default settings and all application resources (images, strings, fonts, and colors).</span></span> <span data-ttu-id="e6efc-376">Ayrıca, bu alan başlatılan veri alanının "ilk kopyasını" içerir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-376">In addition, this area contains the “initial copy” of the initialized data area.</span></span> <span data-ttu-id="e6efc-377">Derleyicinin başlatma işlemi sırasında, sabit alanın bu bölümü RAM 'de Genel başlatılmış verileri ayarlamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-377">During the compiler’s initialization process, this portion of the constant area is used to set up the global initialized data in RAM.</span></span> <span data-ttu-id="e6efc-378">Sabit alan genellikle en büyüktür ve genellikle yönerge alanını izler ve genellikle ROM ' da bulunur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-378">The constant area is typically the largest and usually follows the instruction area and is often located in ROM.</span></span>

<span data-ttu-id="e6efc-379">GUX pixelmaps ve yazı tipleri genellikle büyük miktarda sabit veri depolaması gerektirir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-379">GUIX pixelmaps and fonts typically require large amounts of constant data storage.</span></span> <span data-ttu-id="e6efc-380">Bu büyük statik veri alanı normalde ROM veya FLASH 'ta tutulur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-380">These large static data areas are normally kept in ROM or FLASH.</span></span>

<span data-ttu-id="e6efc-381">GUX iş parçacığı yığını, ***gx_system. h*** dosyasında başlatılmamış veri alanı (genel değişken olarak) içinde aşağıdaki gibi tanımlanır:</span><span class="sxs-lookup"><span data-stu-id="e6efc-381">The GUIX thread stack is defined within the uninitialized data area (as a global variable) in ***gx_system.h*** file as follows:</span></span>

```C
_gx_system_thread_stack[GX_THREAD_STACK_SIZE];
```

<span data-ttu-id="e6efc-382">**GX_THREAD_STACK_SIZE** , **_gx_port. h_** içinde tanımlanmıştır, ancak bu sembol ***gx_user. h*** üstbilgi dosyasında ya da proje seçenekleri ya da komut satırı parametreleri aracılığıyla tanımlayarak uygulama tarafından geçersiz kılınabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-382">**GX_THREAD_STACK_SIZE** is defined in **_gx_port.h_**, but may be overridden by the application by defining this symbol in the ***gx_user.h*** header file or via project options or command line parameters.</span></span> <span data-ttu-id="e6efc-383">Yığın boyutu, en kötü durum olay işleme ve iç içe çizim çağrılarını işleyecek kadar büyük olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-383">The stack size must be large enough to handle the worst case event handling and nested drawing calls.</span></span>

### <a name="dynamic-memory-usage"></a><span data-ttu-id="e6efc-384">Dinamik Bellek kullanımı</span><span class="sxs-lookup"><span data-stu-id="e6efc-384">Dynamic Memory Usage</span></span> 

<span data-ttu-id="e6efc-385">Daha önce belirtildiği gibi, dinamik bellek kullanımı uygulamanın doğrudan denetimi altındadır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-385">As mentioned before, dynamic memory usage is under direct control of the application.</span></span> <span data-ttu-id="e6efc-386">Canvaler, vb. ile ilişkili denetim blokları ve bellek, hedefin bellek alanında herhangi bir yere yerleştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-386">Control blocks and memory associated with canvases, etc. can be placed anywhere in the target’s memory space.</span></span> <span data-ttu-id="e6efc-387">Bu önemli bir özelliktir çünkü çalışma zamanında farklı türlerdeki fiziksel belleğin kolay kullanımını kolaylaştırır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-387">This is an important feature because it facilitates easy utilization of different types of physical memory – at run-time.</span></span>

<span data-ttu-id="e6efc-388">Örneğin, bir hedef donanım ortamının hem hızlı bellek hem de yavaş bellek olduğunu varsayalım.</span><span class="sxs-lookup"><span data-stu-id="e6efc-388">For example, suppose a target hardware environment has both fast memory and slow memory.</span></span> <span data-ttu-id="e6efc-389">Uygulamanın çizim için ek performansa ihtiyacı varsa, en iyi performans için tuval belleği yüksek hızlı bellek alanına açık bir şekilde yerleştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-389">If the application needs extra performance for drawing, the canvas memory can be explicitly placed in the high-speed memory area for best performance.</span></span>

<span data-ttu-id="e6efc-390">Birçok isteğe bağlı Gux hizmeti ve özelliği, genellikle yığın olarak adlandırılan bir çalışma zamanı dinamik bellek ayırma mekanizması gerektirir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-390">Several optional GUIX services and features require a runtime dynamic memory allocation mechanism, commonly referred to as a heap.</span></span> <span data-ttu-id="e6efc-391">Bu hizmetler ve özellikler tamamen isteğe bağlıdır ve birçok GUıDX uygulaması herhangi bir yığın kullanmaz ve bir çalışma zamanı bellek ayırma mekanizması tanımlamaz.</span><span class="sxs-lookup"><span data-stu-id="e6efc-391">These services and features are completely optional, and many GUIX applications do not use any heap and do not define a runtime memory allocation mechanism.</span></span>

<span data-ttu-id="e6efc-392">Çalışma zamanı bellek ayırmayı gerektiren hizmetleri kullanacaksanız, bellek dinamik olarak ayrıldığınızda veya serbest bırakıldığında Gux 'in çağırabileceği işlevleri yüklemelisiniz.</span><span class="sxs-lookup"><span data-stu-id="e6efc-392">If you will be using services which require runtime memory allocation, you must install functions which GUIX will call when memory must be dynamically allocated or freed.</span></span> <span data-ttu-id="e6efc-393">Bu işlevleri tercih ettiğiniz şekilde uygulayabilirsiniz, böylece bu durumda dinamik bellek havuzunun konumu uygulama denetimi altındadır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-393">You can implement these functions as you prefer, so that even in this case the location of the dynamic memory pool is under application control.</span></span> <span data-ttu-id="e6efc-394">Dinamik bellek ayırma desteğini yüklemek için, uygulama, bellek ayırmayı ve bellek ücretsiz hizmetlerinizi tanımlamak üzere program başlatılırken API hizmeti ***gx_system_memory_allocator_set*** çağırmalıdır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-394">To install support for dynamic memory allocation, the application should invoke the API service ***gx_system_memory_allocator_set*** during program startup to define your memory allocation and memory free services.</span></span> <span data-ttu-id="e6efc-395">Tüm örnek için bu API 'nin belgelerine bakın.</span><span class="sxs-lookup"><span data-stu-id="e6efc-395">Refer to the documentation of this API for a complete example.</span></span>

<span data-ttu-id="e6efc-396">Çalışma zamanı belleği ayırmayı ve ayırmayı kaldırma hizmetini gerektiren GUıDX Hizmetleri şunları içerir:</span><span class="sxs-lookup"><span data-stu-id="e6efc-396">GUIX services which require a runtime memory allocation and de-allocation service include:</span></span>

  - <span data-ttu-id="e6efc-397">Dış depolamadan Gux çalışma zamanı ortamına ikili kaynakları yükleme.</span><span class="sxs-lookup"><span data-stu-id="e6efc-397">Loading binary resources from external storage into the GUIX runtime environment.</span></span>

  - <span data-ttu-id="e6efc-398">Yazılım çalışma zamanı JPEG görüntü kod çözücüsü.</span><span class="sxs-lookup"><span data-stu-id="e6efc-398">The software runtime jpeg image decoder.</span></span>

  - <span data-ttu-id="e6efc-399">Yazılım çalışma zamanı PNG resmi kod çözücüsü.</span><span class="sxs-lookup"><span data-stu-id="e6efc-399">The software runtime png image decoder.</span></span>

  - <span data-ttu-id="e6efc-400">GX_STYLE_TEXT_COPY ile metin pencere öğeleri kullanma.</span><span class="sxs-lookup"><span data-stu-id="e6efc-400">Using text widgets with GX_STYLE_TEXT_COPY.</span></span>

  - <span data-ttu-id="e6efc-401">Çalışma zamanı Pikselleştirme yeniden boyutlandırma ve döndürme yardımcı programı işlevleri.</span><span class="sxs-lookup"><span data-stu-id="e6efc-401">Runtime pixemap resize and rotation utility functions.</span></span>
  - <span data-ttu-id="e6efc-402">Çalışma zamanı ekranı ve pencere öğesi denetim bloğu ayırması.</span><span class="sxs-lookup"><span data-stu-id="e6efc-402">Runtime screen and widget control block allocation.</span></span>

<span data-ttu-id="e6efc-403">Daha küçük uygulamalar için, GUıDX kaynakları genellikle uygulama görüntüsünün parçası olarak derlenir ve statik olarak bağlanır ve ikili kaynak yüklemesi gerekli değildir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-403">For smaller applications, GUIX resources are usually compiled and statically linked as part of the application image, and binary resource installation is not required.</span></span> <span data-ttu-id="e6efc-404">İkili kaynaklar bir uygulamanın, Flash sürücü veya URL gibi bazı depolama konumlarından yüklenen çalışma zamanında kaynakları (yazı tipleri, görüntüler, diller) yüklemesine olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-404">Binary resources allow an application to install resources (fonts, images, languages) at runtime loaded from some storage location, such as a flash drive or a URL.</span></span>

<span data-ttu-id="e6efc-405">Çalışma zamanı JPEG ve PNG kod çözücüleri isteğe bağlı bileşenlerdir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-405">The runtime jpeg and png decoders are optional components.</span></span> <span data-ttu-id="e6efc-406">En Gux uygulamalar, Gux Studio aracının tüm gerekli görüntü dosyalarını önceden çözmelerine ve bunları özel Gux Pikselemap veri kaynakları olarak depolamasına olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-406">Most GUIX applications allow the GUIX Studio tool to pre-decode all required image files, and store them as proprietary GUIX Pixemap data resources.</span></span> <span data-ttu-id="e6efc-407">Bu hizmetler, JPEG ve/veya PNG görüntülerinin çalışma zamanı dönüştürülmesini gerektiren uygulamalar için pixelmap biçimine yönelik olarak sağlanır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-407">These services are provided for completeness for those applications that require runtime conversion of jpeg and/or PNG images to pixelmap format.</span></span>

<span data-ttu-id="e6efc-408">**GX_STYLE_TEXT_COPY** , kullanıcının belirli bir pencere öğesi ya da pencere öğelerinin, dinamik olarak atanan metnin özel kopyasını tutabileceklerini belirtmesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-408">**GX_STYLE_TEXT_COPY** allows the user to specify that a particular widget or widgets will keep it’s own private copy of dynamically assigned text.</span></span> <span data-ttu-id="e6efc-409">Bu seçeneği kullanmak için bellek ayırma mekanizmasının kullanılmadan önce yüklenmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-409">Using this option requires that the memory allocation mechanism be installed prior to use.</span></span> <span data-ttu-id="e6efc-410">Bir metin türü pencere öğesi oluşturulduğunda bu stil **<span class="underline">bayrağı sağlanmazsa,</span>** uygulamanın dinamik olarak oluşturulan ve atanan tüm metin dizeleri için statik depolama alanı ayırması gerekir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-410">If this style flag is **<span class="underline">not</span>** provided when a text type widget is created, the application must allocate static storage areas for all dynamically created and assigned text strings.</span></span> <span data-ttu-id="e6efc-411">Çalışma zamanı tarafından oluşturulan dize verilerini tutmak için otomatik değişkenlerin bu durumda kullanılması gerekir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-411">Automatic variables should not be used in this case to hold runtime generated string data.</span></span> <span data-ttu-id="e6efc-412">**GX_STYLE_TEXT_COPY** stili etkinse, her pencere öğesi atanan metnin kendi kopyasını oluşturduğundan, her bir pencere öğesi için otomatik değişkenler, guıdx Pencere öğelerinin atandığı dize verilerini tutmak için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-412">If the **GX_STYLE_TEXT_COPY** style is enabled, automatic variables may be used to hold string data assigned to GUIX widgets, since each widget will create its own copy of the assigned text.</span></span>

<span data-ttu-id="e6efc-413">Pixelmap yeniden boyutlandırma ve döndürme yardımcı programı işlevleri, elde edilen çevrilmiş pixelmap 'i uygulama için kullanılabilir yeni bir pixelmap olarak döndürür.</span><span class="sxs-lookup"><span data-stu-id="e6efc-413">Pixelmap resize and rotation utility functions return the resulting translated pixelmap as a new pixelmap available to the application.</span></span>
<span data-ttu-id="e6efc-414">Bu hizmetler kullanılıyorsa, bu çalışma zamanının üretilen pixelmap veri bloklarını barındırmak için yeterli dinamik bellek kullanılabilir olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-414">Sufficient dynamic memory must be available to hold these runtime generated pixelmap data blocks if these services are used.</span></span>

<span data-ttu-id="e6efc-415">Son olarak, GUıDX ekranları ve pencere öğeleri için denetim blokları statik veya dinamik olarak tahsis edilebilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-415">Finally, the control blocks for the GUIX screens and widgets can be statically or dynamically allocated.</span></span> <span data-ttu-id="e6efc-416">Daha küçük uygulamalar için, program başlangıcında tüm uygulama ekranlarını oluşturmak ve statik olarak ayrılan denetim blokları kullanmak yaygındır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-416">For smaller applications, it is common to create all application screens during program startup and use statically allocated control blocks.</span></span> <span data-ttu-id="e6efc-417">Büyük uygulamalar için, ekran ve alt pencere öğesi denetimlerini, gerekli bir tabanda dinamik olarak oluşturmak yaygındır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-417">For large applications, it is common to create the screen and child widget controls dynamically on an as-needed bases.</span></span> <span data-ttu-id="e6efc-418">Dinamik olarak ayrılan denetim blokları, Gux Studio özellikleri görünümünde **çalışma zamanı ayırma** onay kutusu seçilerek veya Standart API aracılığıyla pencere öğesi oluşturulurken **GX_STYLE_DYNAMICALLY_ALLOCATED** stil bayrağına geçerek belirtilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-418">Dynamically allocated control blocks are specified by selecting the **Runtime Allocate** checkbox in the GUIX Studio properties view, or by passing in the style flag **GX_STYLE_DYNAMICALLY_ALLOCATED** when creating a widget via the standard API.</span></span> <span data-ttu-id="e6efc-419">Dinamik olarak ayrılan pencere öğesi denetim bloklarının kullanılması, bellek ayırma ve ayırmayı kaldırma hizmetlerinin yukarıda açıklanan şekilde tanımlanmasını gerektirir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-419">Using dynamically allocated widget control blocks requires that memory allocation and deallocation services are defined as described above.</span></span>

## <a name="guix-components"></a><span data-ttu-id="e6efc-420">GUX bileşenleri</span><span class="sxs-lookup"><span data-stu-id="e6efc-420">GUIX Components</span></span> 

<span data-ttu-id="e6efc-421">GUX API 'Leri bölünür ve Gux sisteminin temel bileşenlerine karşılık gelen çeşitli temel gruplar halinde düzenlenir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-421">The GUIX APIs are divided and organized into several basic groups which correspond to fundamental components of the GUIX system.</span></span> <span data-ttu-id="e6efc-422">Temel bileşenler şunlardır:</span><span class="sxs-lookup"><span data-stu-id="e6efc-422">The fundamental components include:</span></span>

| <!-- -->    | <!-- -->    |
| ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| <span data-ttu-id="e6efc-423">GX_SYSTEM</span><span class="sxs-lookup"><span data-stu-id="e6efc-423">GX_SYSTEM</span></span>  | <span data-ttu-id="e6efc-424">GUX sistem bileşeni, başlatma, olaylar, zamanlayıcılar, dize tabloları ve görünür pencere öğesi hiyerarşi yönetiminden sorumludur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-424">The GUIX system component, responsible for initialization, events, timers, string tables, and visible widget hierarchy management.</span></span>                                                                                                                                                                                                                                                                      |
| <span data-ttu-id="e6efc-425">GX_CANVAS</span><span class="sxs-lookup"><span data-stu-id="e6efc-425">GX_CANVAS</span></span>  | <span data-ttu-id="e6efc-426">Bir çizim alanı.</span><span class="sxs-lookup"><span data-stu-id="e6efc-426">A drawing area.</span></span> <span data-ttu-id="e6efc-427">Bir tuval, donanım çerçeve arabelleğinin ince bir soyutlaması olabilir veya bir saf bellek tuvali de olabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-427">A Canvas can be a thin abstraction of the hardware frame buffer, or it might also be a pure memory canvas.</span></span> <span data-ttu-id="e6efc-428">Tuval türü gx_canvas_create API işlevine geçirilen parametrelere göre belirlenir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-428">The canvas type is determined by parameters passed to the gx_canvas_create API function.</span></span>                                                                                                                                                                                   |
| <span data-ttu-id="e6efc-429">GX_CONTEXT</span><span class="sxs-lookup"><span data-stu-id="e6efc-429">GX_CONTEXT</span></span> | <span data-ttu-id="e6efc-430">Çizim bağlamı bileşeni.</span><span class="sxs-lookup"><span data-stu-id="e6efc-430">The drawing context component.</span></span> <span data-ttu-id="e6efc-431">Çizim bağlamı, geçerli çizim işlemleri için ekran, tuval ve fırça ve kırpma alanı hakkında bilgiler içerir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-431">The drawing context contains information about the screen, canvas, and brush, and clipping area for the current drawing operations.</span></span>                                                                                                                                                                                                                                      |
| <span data-ttu-id="e6efc-432">GX_DISPLAY</span><span class="sxs-lookup"><span data-stu-id="e6efc-432">GX_DISPLAY</span></span> | <span data-ttu-id="e6efc-433">, Uygulamanızın ve Gux Pencere öğelerinin tuvalde çizim gerçekleştirmesine izin vermek için API 'Ler ve sürücü düzeyi uygulamalar sağlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-433">Provides the APIs and driver-level implementations to allow your application and the GUIX widgets to perform drawing on a canvas.</span></span> <span data-ttu-id="e6efc-434">GX_DISPLAY, tuvalin gerekli renk biçimini kullanarak her tuvalde grafikleri doğru şekilde işlemek için uygulanır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-434">GX_DISPLAY is implemented to correctly render graphics on each canvas using that canvas’ required color format.</span></span> <span data-ttu-id="e6efc-435">GX_DISPLAY bileşeni, her bir görüntüleme ile bağlantılı olarak pencere öğeleri çizimi için kullanılabilir kaynakları (renkler, yazı tipleri ve pixelharitalar) yönetir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-435">The GX_DISPLAY component also manages the resources (colors, fonts, and pixelmaps) available to widgets drawing to canvases linked to each display.</span></span> |
| <span data-ttu-id="e6efc-436">GX_WIDGET</span><span class="sxs-lookup"><span data-stu-id="e6efc-436">GX_WIDGET</span></span>  | <span data-ttu-id="e6efc-437">Temel görünür pencere öğesi nesnesi ve ilişkili API 'Ler.</span><span class="sxs-lookup"><span data-stu-id="e6efc-437">The basic visible widget object and associated APIs.</span></span> <span data-ttu-id="e6efc-438">Tüm GUıDX pencere öğesi türleri temel GX_WIDGET türünden dayanır veya türetilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-438">All GUIX widget types are based on or derived from the basic GX_WIDGET type.</span></span>                                                                                                                                                                                                                                                                      |
| <span data-ttu-id="e6efc-439">GX_UTILITY</span><span class="sxs-lookup"><span data-stu-id="e6efc-439">GX_UTILITY</span></span> | <span data-ttu-id="e6efc-440">Dikdörtgenlerle çalışmaya yönelik yardımcı program işlevleri, dize dönüştürme işlevleri ve ANSI olmayan matematik işlevleri bu gruba dahil edilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-440">Utility functions for working with rectangles, functions for string conversion, and non-ANSI mathematical functions are included in this group.</span></span>                                                                                                                                                                                                                                                         |

<span data-ttu-id="e6efc-441">Bu temel bileşenlere ek olarak, GUıDX, kitaplıkta belirtilen her pencere öğesi türüne özgü API 'Leri içerir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-441">In addition to these basic components, GUIX includes APIs unique to each type of widget provided in the library.</span></span> <span data-ttu-id="e6efc-442">Bu API 'Ler, bu kullanıcı kılavuzunun Bölüm 4 ' te "Gux Services açıklaması" bölümünde açıklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-442">These APIs are described in Chapter 4 of this User Guide, “Description of GUIX Services”.</span></span>

## <a name="guix-system-component"></a><span data-ttu-id="e6efc-443">GUIX sistem bileşeni</span><span class="sxs-lookup"><span data-stu-id="e6efc-443">GUIX System Component</span></span>

<span data-ttu-id="e6efc-444">GUX sistem bileşeni, UI uygulaması için genel olan çeşitli hizmetler sunar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-444">The GUIX system component provides several services that are global to the UI application.</span></span> <span data-ttu-id="e6efc-445">Bu hizmetler şunları içerir: *başlatma, olay yönetimi, görüntüleme yönetimi, kaynak yönetimi, Zamanlayıcı yönetimi* ve *pencere öğesi yönetimi*.</span><span class="sxs-lookup"><span data-stu-id="e6efc-445">These services include: *initialization, event management, display management, resource management, timer management,* and *widget management*.</span></span> <span data-ttu-id="e6efc-446">Her hizmet, uygulama programınızın organizasyonu için gereklidir ve bu hizmetler aşağıdaki alt bölümlerde daha ayrıntılı olarak açıklanmıştır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-446">Each service is essential to the organization of your application program, and these services are described in more detail in the following sub-sections.</span></span>

### <a name="initialization"></a><span data-ttu-id="e6efc-447">Başlatma</span><span class="sxs-lookup"><span data-stu-id="e6efc-447">Initialization</span></span> 

<span data-ttu-id="e6efc-448">GUX başlatma, uygulama tarafından ThreadX ***tx_application_define*** yordamından (başlatma bağlamından) veya uygulama iş parçacıklarından çağrılabilen hizmet ***gx_system_initialize*** çağıran uygulama tarafından gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-448">GUIX initialization is accomplished by the application calling the service ***gx_system_initialize***, which may be called by the application from the ThreadX ***tx_application_define*** routine (initialization context) or from application threads.</span></span> <span data-ttu-id="e6efc-449">***Gx_system_initialize*** işlevi tüm genel guıdx veri yapılarını başlatır ve Gux sistem mutex 'i, olay kuyruğunu, süreölçeri ve iş parçacığını oluşturur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-449">The ***gx_system_initialize*** function initializes all global GUIX data structures and creates the GUIX system mutex, event queue, timer, and thread.</span></span> <span data-ttu-id="e6efc-450">***Gx_system_initialize*** döndüğünde, uygulama Gux kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-450">Once ***gx_system_initialize*** returns, the application can use GUIX.</span></span>

### <a name="thread-processing"></a><span data-ttu-id="e6efc-451">İş parçacığı Işleme</span><span class="sxs-lookup"><span data-stu-id="e6efc-451">Thread Processing</span></span> 

<span data-ttu-id="e6efc-452">Başlatma sırasında oluşturulan iç Gux iş parçacığı-Gux ' teki çoğu işlemin sorumluluğundadır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-452">The internal GUIX thread – created during initialization – is responsible for most of the processing in GUIX.</span></span> <span data-ttu-id="e6efc-453">Bu iş parçacığındaki işlem ilk olarak, temel alınan görüntü sürücüsünün gerektirdiği ek başlatma işlemini tamamlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-453">The processing in this thread first completes any additional initialization required by the underlying display driver.</span></span> <span data-ttu-id="e6efc-454">Bu işlem tamamlandıktan sonra, GUıDX iş parçacığı, önce Gux olay kuyruğunda bulunan tüm olayları işleyen bir döngü girer ve gerekirse ekranı yeniler.</span><span class="sxs-lookup"><span data-stu-id="e6efc-454">Once this is complete, the GUIX thread enters a loop which first processes all events present in the GUIX event queue and then refreshes the screen if required.</span></span> <span data-ttu-id="e6efc-455">Ekran yenilemesi, görünür hale ve bu işlevin yeniden çizilmesini gerektiren kirli bir anlamı temel alarak gerekli Gux çizim işlevlerini yürütür.</span><span class="sxs-lookup"><span data-stu-id="e6efc-455">The screen refresh executes the necessary GUIX drawing functions, based on what is visible and has been marked as dirty meaning it needs to be redrawn.</span></span> <span data-ttu-id="e6efc-456">Hiçbir olay olmadığında ve ekranda yenilenmek üzere hiçbir şey kalmadığında, Gux iş parçacığı askıya alınır ve sonraki Gux olayının gelmesi bekleniyor.</span><span class="sxs-lookup"><span data-stu-id="e6efc-456">When there are no events and nothing left to refresh on the display, the GUIX thread will suspend, waiting for the next GUIX event to arrive.</span></span>

### <a name="rtos-binding"></a><span data-ttu-id="e6efc-457">RTOS bağlama</span><span class="sxs-lookup"><span data-stu-id="e6efc-457">RTOS Binding</span></span> 

<span data-ttu-id="e6efc-458">GUX sistem bileşeni varsayılan olarak, iş parçacığı Hizmetleri, olay kuyruğu Hizmetleri ve Zamanlayıcı Hizmetleri gibi hizmetler için ThreadX gerçek zamanlı işletim sistemini kullanacak şekilde yapılandırılmıştır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-458">The GUIX system component is by default configured to utilize the ThreadX real time operating system for services such as thread services, event queue services, and timer services.</span></span> <span data-ttu-id="e6efc-459">GUX, Önişlemci yönergesini GX_DISABLE_THREADX_BINDING ve Gux kitaplığını yeniden oluşturarak diğer işletim sistemlerine kolayca eklenebilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-459">GUIX can easily be ported to other operating systems by using the preprocessor directive GX_DISABLE_THREADX_BINDING and re-building the GUIX library.</span></span> <span data-ttu-id="e6efc-460">Bu, Gux kaynak kodundan alınan ThreadX bağımlılıklarını kaldırır ve uygulama geliştiricisinin hedef sistem tarafından belirtilen RTOS 'yi kullanarak gerekli işletim sistemi hizmetlerini uygulamasına izin verir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-460">This removes the ThreadX dependencies from the GUIX source code, and allows the application developer to implement the required operating system services using whatever RTOS is provided by the target system.</span></span> <span data-ttu-id="e6efc-461">[Ek F-Gux RTOS bağlama hizmetleri](appendix-f.md) , Gux bağlantı noktası Için threadx işletim sistemi dışında bir işletim sistemine uygulanması gereken hizmetleri tanımlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-461">[Appendix F - GUIX RTOS Binding Services](appendix-f.md) describes the services that need to be implemented to port GUIX to an operating system other than the ThreadX operating system.</span></span>

### <a name="multithread-safety"></a><span data-ttu-id="e6efc-462">Çoklu iş parçacığı güvenliği</span><span class="sxs-lookup"><span data-stu-id="e6efc-462">Multithread Safety</span></span> 

<span data-ttu-id="e6efc-463">GUX API 'SI, Gux iş parçacığı bağlamından ve diğer uygulama iş parçacıklarından kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-463">The GUIX API is available from the GUIX thread context as well as other application threads.</span></span> <span data-ttu-id="e6efc-464">Uygulama iş parçacıkları,, paylaşılan değişkenlere erişime ve Gux API işlevlerinin kullanılmasıyla birlikte olayları gönderip alarak, Gux iş parçacığı ile etkileşime geçebilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-464">Application threads can interact with the GUIX thread by sending and receiving events, by access to shared variables, and through use of the GUIX API functions.</span></span> <span data-ttu-id="e6efc-465">GUIX, çok iş parçacığı kaynak koruması için bir iç ThreadX mutex kullanır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-465">GUIX uses an internal ThreadX mutex for multi-thread resource protection.</span></span> <span data-ttu-id="e6efc-466">Ayrıca, GUıDX, ekran yenileme işlemi başladıktan sonra görünür pencere öğelerinin iç yapısının değiştirilmesini engeller.</span><span class="sxs-lookup"><span data-stu-id="e6efc-466">In addition, GUIX prevents the internal structure of visible widgets from being modified once a screen refresh operation has begun.</span></span> <span data-ttu-id="e6efc-467">Görünür nesneler ağacını değiştirecek API 'Ler, çizim işlemleri devam ederken engellenir ve ekran yenilemesi tamamlandıktan sonra serbest bırakılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-467">APIs which would modify the tree of visible objects are blocked while drawing operations are in progress, and released once the screen refresh is complete.</span></span>

### <a name="system-timers"></a><span data-ttu-id="e6efc-468">Sistem süreölçerleri</span><span class="sxs-lookup"><span data-stu-id="e6efc-468">System Timers</span></span> 

<span data-ttu-id="e6efc-469">GUX, her zaman Gux Windows 'ta görüntülenen verilerin düzenli olarak güncelleştirilmesi için kullanılan dönemsel zamanlayıcılar sağlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-469">GUIX provides the application with periodic timers, which are often used for periodic update of data displayed in GUIX windows.</span></span> <span data-ttu-id="e6efc-470">Bu, bir ThreadX dönemsel süreölçeri aracılığıyla yapılır, bu da ekran belirme/genişletme gibi Gux sistem düzeyi etkileri gerçekleştirmek için de kullanılır, vb.</span><span class="sxs-lookup"><span data-stu-id="e6efc-470">This is accomplished via a ThreadX periodic timer, which is also used to perform GUIX system-level effects like screen fade in/out, etc.</span></span>

<span data-ttu-id="e6efc-471">Uygulama zamanlayıcılar oluşturabilir ve Gux tarafından dahili olarak kullanılan Zamanlayıcı özelliğini kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-471">The application can create timers and utilize the same timer facility that is used internally by GUIX.</span></span> <span data-ttu-id="e6efc-472">Kuşkusuz, uygulama gerekirse ThreadX zamanlayıcılarını doğrudan oluşturabilir ve kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-472">Of course the application can also directly create and use ThreadX timers if required.</span></span> <span data-ttu-id="e6efc-473">GUX zamanlayıcıları 'nın avantajı, kullanımı çok kolay ve Gux olay odaklı işleme sistemi içinde çalışacak şekilde önceden yapılandırılmıştır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-473">The advantage of the GUIX timers is that they are very easy to use and are pre-configured to work within the GUIX event-driven processing system.</span></span>

<span data-ttu-id="e6efc-474">Bir GUıDX süreölçeri oluşturup başlatmak için, uygulama ***gx_system_timer_start*** işlevi çağırmalıdır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-474">To create and start a GUIX timer, the application should invoke the function ***gx_system_timer_start***.</span></span> <span data-ttu-id="e6efc-475">Bu işleve yönelik parametreler, çağıran pencere öğesi, Zamanlayıcı kimliği (bir pencere öğesinin birçok Zamanlayıcı başlatmasına izin veriliyor) ve ilk ve yeniden zamanlama zaman aşımı değerlerini içerir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-475">The parameters to this function include a pointer to the calling widget, the timer id (allowing one widget to start many timers), and the initial and reschedule timeout values.</span></span> <span data-ttu-id="e6efc-476">Yeniden zamanlama zaman aşımı değeri 0 ise, süreölçer yalnızca bir kez çalışır ve süresi dolduktan sonra etkin Zamanlayıcı listesinden kendisini siler.</span><span class="sxs-lookup"><span data-stu-id="e6efc-476">If the reschedule timeout value is 0, the timer will only run one time and will delete itself from the active timer list once it expires.</span></span>

<span data-ttu-id="e6efc-477">Başlatıldıktan sonra, Gux süreölçeri Zamanlayıcı sahibine bir kez veya zamanlayıcı yeniden zamanlama değerine göre düzenli olarak GX_EVENT_TIMEOUT olayları gönderir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-477">Once started, the GUIX timer will send GX_EVENT_TIMEOUT events to the timer owner, either once or periodically depending on the timer reschedule value.</span></span> <span data-ttu-id="e6efc-478">Bir Gux süreölçeri, ***GX_SYSTEM_TIMER_STOP*** API işlevi çağırarak durdurulabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-478">A GUIX timer can be stopped by calling the API function ***gx_system_timer_stop***.</span></span>

### <a name="pen-speed-configuration"></a><span data-ttu-id="e6efc-479">Kalem hızı yapılandırması</span><span class="sxs-lookup"><span data-stu-id="e6efc-479">Pen Speed Configuration</span></span> 

<span data-ttu-id="e6efc-480">GUX sistem bileşeni, kalem hızı izlemeyle ilgili yapılandırma bilgilerini içerir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-480">The GUIX system component holds configuration information related to pen speed tracking.</span></span> <span data-ttu-id="e6efc-481">GUX, varsa Touch giriş sürücüsü tarafından oluşturulan PEN_DOWN olaylarının hızına ve uzaklığa göre **GX_EVENT_VERTICAL_FLICK** ve **GX_EVENT_HORIZONTAL_FLICK** olaylarını temel alır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-481">GUIX internally generated **GX_EVENT_VERTICAL_FLICK** and **GX_EVENT_HORIZONTAL_FLICK** events based on the speed and distance of PEN_DOWN events generated by the touch input driver, if any.</span></span> <span data-ttu-id="e6efc-482">Uygulama, **_gx_system_pen_configure_** API işlevini kullanarak bu iç oluşturulan olayları tetiklemek için gereken en düşük uzaklık ve hızı yapılandırabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-482">The application can configure the minimum distance and speed required to trigger these internally generated events using the **_gx_system_pen_configure_** API function.</span></span>

### <a name="screen-stack"></a><span data-ttu-id="e6efc-483">Ekran yığını</span><span class="sxs-lookup"><span data-stu-id="e6efc-483">Screen Stack</span></span> 

<span data-ttu-id="e6efc-484">GUX sistem bileşeni, ekran yığınında, hangi ekranların gönderilebileceği, polamış ve çalışma zamanında alınan bir sanal pencere öğesi yığınını destekleyen isteğe bağlı bir işlevdir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-484">The GUIX system component provides services related to the GUIX screen stack, which is an optional functionality supporting a virtual widget stack onto which screens can be pushed, popped, and retrieved at runtime by the application.</span></span> <span data-ttu-id="e6efc-485">Ekran yığını, kullanıcının menü sisteminde çeşitli durumlara ulaşmasına yol gösteren rotada karmaşık menü sistemlerini yönetmek için yararlıdır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-485">The screen stack is useful for managing complex menu systems, wherein the route by which the user may arrive at various states in the menu system is varied.</span></span> <span data-ttu-id="e6efc-486">Menü sisteminde önceki duruma dönmek, önce önceki ekran durumunu ileterek, sonra yeni ekranı görüntüleyerek ve geçerli ekran kapatıldığında yeni ekranın ekran yığınından önceki durumu açmasına izin vererek kolayca yapılabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-486">Returning to the previous state in the menu system can be easily done by first pushing the previous screen state, then displaying the new screen, and allowing the new screen to pop the previous state from the screen stack when the current screen is dismissed.</span></span>

### <a name="clipboard-maintenance"></a><span data-ttu-id="e6efc-487">Pano Bakımı</span><span class="sxs-lookup"><span data-stu-id="e6efc-487">Clipboard Maintenance</span></span> 

<span data-ttu-id="e6efc-488">GUIX, çalışma zamanında yürütme sırasında metin kopyalayıp yapıştırarak bir panoyu destekler.</span><span class="sxs-lookup"><span data-stu-id="e6efc-488">GUIX supports a clipboard for copying and pasting text during runtime execution.</span></span> <span data-ttu-id="e6efc-489">Bu destek, GUıDX sistem bileşeni tarafından sağlanır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-489">This support is provided by the GUIX System component.</span></span>

### <a name="dirty-list-maintenance"></a><span data-ttu-id="e6efc-490">Kirli liste Bakımı</span><span class="sxs-lookup"><span data-stu-id="e6efc-490">Dirty List Maintenance</span></span> 

<span data-ttu-id="e6efc-491">GUX kirli pencere öğelerinin bir listesini, görünür olan ve durum değişiklikleri nedeniyle yeniden çizilmesini gereken ve yeni görünür hale getirilen Pencere öğelerinin bir listesini tutar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-491">GUIX maintains a list of dirty widgets, meaning widgets that are visible and need to be redrawn due to status changes or being made newly visible.</span></span> <span data-ttu-id="e6efc-492">Bu kirli liste, Gux 'in her bir kullanıcı arabirimi değişikliği yapıldığından tuval yenilemesi yapmak yerine, tek bir tuval yenileme işlemi yapmasına izin vererek çizim performansını geliştirir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-492">This dirty list improves drawing performance by allowing GUIX to do one canvas refresh operation to reflect all current changes to the UI status, rather than doing a canvas refresh as each UI change is made.</span></span>
<span data-ttu-id="e6efc-493">Bu kirli liste, GUıDX sistem bileşeni tarafından da korunur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-493">This dirty list is also maintained by the GUIX system component.</span></span>

### <a name="animation-control-block-pool"></a><span data-ttu-id="e6efc-494">Animasyon denetim blok havuzu</span><span class="sxs-lookup"><span data-stu-id="e6efc-494">Animation Control Block Pool</span></span> 

<span data-ttu-id="e6efc-495">Uygulamalar genellikle paralel olarak birden çok animasyon dizisi yürütmeyi ister.</span><span class="sxs-lookup"><span data-stu-id="e6efc-495">Applications often desire to execute multiple animation sequences, often in parallel.</span></span> <span data-ttu-id="e6efc-496">GUX, uygulamanın ayırabileceği ve kullanabileceği bir animasyon denetim bloğu havuzunu saklar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-496">GUIX maintains a pool of animation control blocks from which the application can allocate and use.</span></span> <span data-ttu-id="e6efc-497">Bu, uygulamayı statik olarak tanımlayan bu denetim bloklarını serbest bırakır ve uygulamanın tanımlayabilecek her animasyon için benzersiz bir animasyon denetim bloğu tanımlamak yerine farklı zamanlarda yeniden kullanılabilmelerini sağlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-497">This frees the application from statically defining these control blocks and allows them to be reused at different times, rather than defining a unique animation control block for every animation that the application might define.</span></span> <span data-ttu-id="e6efc-498">Animasyon denetim bloğu havuzu, GUıDX sistem bileşeni tarafından da korunur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-498">The animation control block pool is also maintained by the GUIX system component.</span></span>

### <a name="system-error-handling"></a><span data-ttu-id="e6efc-499">Sistem hatası Işleme</span><span class="sxs-lookup"><span data-stu-id="e6efc-499">System Error Handling</span></span> 

<span data-ttu-id="e6efc-500">GUX sistem hatası işleyicisi, API perspektifinden belirlenmesi daha zor olabilecek ve Gux 'teki iç sistem hatalarını bulmada uygulamanın yardımcı olmaya yöneliktir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-500">The GUIX system error handler is intended to assist the application in finding internal system errors in GUIX that might be more difficult to determine from the API perspective.</span></span> <span data-ttu-id="e6efc-501">GUX içinde bir sistem hatası oluştuğunda, iç ***_gx_system_error_process*** işlevi çağırılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-501">Whenever a system error occurs inside of GUIX the internal ***_gx_system_error_process*** function is called.</span></span> <span data-ttu-id="e6efc-502">Bu işlev, girilen hata kodunu kaydeder ve algılanan toplam sistem hatası sayısını artırır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-502">This function saves the error code provided and increments the total number of system errors detected.</span></span> <span data-ttu-id="e6efc-503">Sistem hatası değişkenleri aşağıdaki gibi tanımlanır:</span><span class="sxs-lookup"><span data-stu-id="e6efc-503">The system error variables are defined as follows:</span></span>

<span data-ttu-id="e6efc-504">UINT **_gx_system_last_error**;</span><span class="sxs-lookup"><span data-stu-id="e6efc-504">UINT **_gx_system_last_error**;</span></span>

<span data-ttu-id="e6efc-505">ULONG **_gx_system_error_count**;</span><span class="sxs-lookup"><span data-stu-id="e6efc-505">ULONG **_gx_system_error_count**;</span></span>

<span data-ttu-id="e6efc-506">GUX uygulaması Strangely çalışıyorsa hata ayıklayıcıda hata sayısı değişkenine bakmak yararlı olur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-506">If the GUIX application is behaving strangely, it is useful to look at the error count variable in the debugger.</span></span> <span data-ttu-id="e6efc-507">Ayarlanırsa, sorunu gidermek için iyi bir yol ***_gx_system_error_process*** işlevinde bir kesme noktası ayarlamak ve ne zaman/nerede çağrılmakta olduğunu görmeniz.</span><span class="sxs-lookup"><span data-stu-id="e6efc-507">If it is set, a good way to troubleshoot the problem is to set a breakpoint in the ***_gx_system_error_process*** function and see when/where it is being called from.</span></span>

## <a name="guix-canvas-component"></a><span data-ttu-id="e6efc-508">GUX tuval bileşeni</span><span class="sxs-lookup"><span data-stu-id="e6efc-508">GUIX Canvas Component</span></span>

<span data-ttu-id="e6efc-509">Tuval bileşeni, tuvalle ilgili tüm işlemeden sorumludur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-509">The canvas component is responsible for all canvas related processing.</span></span> <span data-ttu-id="e6efc-510">Tuval etkin bir şekilde sanal çerçeve arabelleği olur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-510">A canvas is effectively a virtual frame buffer.</span></span> <span data-ttu-id="e6efc-511">Uygulamanızın grafik çıkışı oluşturmak için en az bir tuval oluşturması gerekir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-511">Your application must create at least one canvas in order to produce graphical output.</span></span>
<span data-ttu-id="e6efc-512">Genellikle, sisteminiz tarafından desteklenen her bir fiziksel görüntü için en az bir tuval oluşturursunuz.</span><span class="sxs-lookup"><span data-stu-id="e6efc-512">Typically, you would create at least one canvas for each physical display supported by your system.</span></span>

<span data-ttu-id="e6efc-513">Tüm Gux çizimi bir tuvalde gerçekleşir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-513">All GUIX drawing takes place on a canvas.</span></span> <span data-ttu-id="e6efc-514">Daha basit veya bellek kısıtlı sistemlerde, daha fazla bellek ve daha gelişmiş grafik gereksinimlerine sahip sistemler birden çok canvaı gerektirebilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-514">In simpler or memory constrained systems, there will likely be only one canvas which might be directly linked to the visible frame buffer, whereas systems with more memory and more advanced graphics requirements might require multiple canvases.</span></span> <span data-ttu-id="e6efc-515">Birden çok Canun bir ekran için kullanılabilir hale getirilmesi, ekran ve pencere belirme ve soluklaştırma etkileri gibi özellikler sunar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-515">Making multiple canvases available for one display enables features such as screen and window fade-in and fade-out effects.</span></span>
<span data-ttu-id="e6efc-516">Canvases, basit veya yönetilen iki ana türden biri olabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-516">Canvases can be one of two main types, simple or managed.</span></span>

<span data-ttu-id="e6efc-517">Basit tuval, uygulama tarafından kullanılan bir ekran çizimi alanıdır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-517">A simple canvas is an off-screen drawing area used by the application.</span></span>
<span data-ttu-id="e6efc-518">GUX basit bir tuval ile hiçbir şey yapmaz, ancak uygulama, karmaşık çizimi bir ekran arabelleğine işlemek için basit bir tuval kullanabilir ve sonra gerektiğinde görünür tuvali yenilemek için bu ekran arabelleğini kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-518">GUIX does nothing directly with a simple canvas, but the application can use a simple canvas to render complex drawing to an off-screen buffer, and then use this off-screen buffer to refresh the visible canvas when needed.</span></span>

<span data-ttu-id="e6efc-519">Yönetilen bir tuval, GUıDX tarafından donanım çerçeve arabelleği içinde otomatik olarak görüntülenir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-519">A managed canvas is automatically displayed within the hardware frame buffer by GUIX.</span></span> <span data-ttu-id="e6efc-520">Yönetilen bir tuval, birden çok yönetilen canların desteklenmesi için yeterli belleğe sahip olan sistemler için bileşik bir tuval oluşturmaya dahildir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-520">A managed canvas is included in building a composite canvas for those systems with enough memory to support multiple managed canvases.</span></span> <span data-ttu-id="e6efc-521">Yönetilen canteler, GUıDX tarafından tutulan bir Z sırasına sahiptir ve tüm yönetilen cantlarla görüntü kırpması uygulanır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-521">Managed canvases have a Z-order maintained by GUIX, and view clipping is enforced on all managed canvases.</span></span>

<span data-ttu-id="e6efc-522">Bir tuval, daha genel olması için bir çerçeve arabelleğinden farklıdır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-522">A canvas differs from a frame buffer in that it is more generic.</span></span> <span data-ttu-id="e6efc-523">Bellek kısıtlı sistemlerde yalnızca bir tuval olabilir ve bu tuval için bellek, görünür çerçeve arabelleği belleği olabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-523">In memory constrained systems, there may be only one canvas and the memory for this canvas might be the visible frame buffer memory.</span></span> <span data-ttu-id="e6efc-524">Ancak, daha gelişmiş grafik yer paylaşımlarını ve birden çok canvalarını destekleyen daha karmaşık sistemler için, yönetilen canvaler, her biri donanım çerçevesi arabellek belleğinden farklı olan kendi bellek bölgelerini ayırmıştır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-524">However, for more complex systems supporting more advanced graphical overlays and multiple canvases, the managed canvases are each allocated their own memory areas which are distinct from the hardware frame buffer memory.</span></span>
<span data-ttu-id="e6efc-525">Bu yönetilen canvaler, çerçeve arabelleği yenileme veya geçiş işlemi sırasında görünür çerçeve arabelleğine işlenir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-525">These managed canvases are rendered into the visible frame buffer during the frame buffer refresh or toggle operation.</span></span>

<span data-ttu-id="e6efc-526">Birden çok grafik katmanını destekleyen donanımlar, yani birden çok fazla sayıda çerçeve arabelleği için, uygulama ***gx_canvas_hardware_layer_bind*** API 'sini kullanarak bir veya daha fazla canvaı 'yi donanım grafik katmanlarına bağlayabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-526">For hardware supporting multiple graphics layers, i.e. multiple overlayed frame buffers, the application can bind one or more canvases to the hardware graphics layers using the ***gx_canvas_hardware_layer_bind*** API.</span></span> <span data-ttu-id="e6efc-527">Bu hizmet, tuvalde belirli bir donanım grafik katmanıyla bağlantılı olduğunu bildirir ve bu tuval bağlandığında tuval görünürlüğü için donanım desteğini kullanmayı dener (ör.</span><span class="sxs-lookup"><span data-stu-id="e6efc-527">This service informs the canvas that it is linked to a particular hardware graphics layer, and once linked this canvas will attempt to utilize hardware support for canvas visibility (i.e</span></span> <span data-ttu-id="e6efc-528">gx_canvas_show, gx_canvas_hide), tuval Alfa karıştırma (yani ***gx_canvas_alpha_set***) ve görüntü içindeki tuval kayması (***gx_canvas_offset_set***).</span><span class="sxs-lookup"><span data-stu-id="e6efc-528">gx_canvas_show, gx_canvas_hide), canvas alpha blending (i.e. ***gx_canvas_alpha_set***) and canvas offset within the display (***gx_canvas_offset_set***).</span></span>

<span data-ttu-id="e6efc-529">En basit tek tuval/tek çerçeve arabelleği organizasyonu dışındaki mimariler için, bir tuvalin boyutu uygulama tarafından belirlenir ve bir çerçeve arabelleğinin sabit boyutundan farklı olabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-529">For architectures other than the simplest single canvas/single frame buffer organization, the size of a canvas is determined by the application and may be different than the fixed size of a frame buffer.</span></span>
<span data-ttu-id="e6efc-530">Ayrıca, uygulama tarafından seçilen bir uzaklığında de olabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-530">It may also be at an offset selected by the application.</span></span> <span data-ttu-id="e6efc-531">Z sırası gibi diğer bilgiler tuvalde korunur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-531">Other information, such as Z-order is maintained within the canvas.</span></span> <span data-ttu-id="e6efc-532">Tuval çizimi tamamlandığında, tuvalin içeriği görüntüleme sürücüsü tarafından fiziksel görüntülemeye aktarılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-532">When the canvas drawing is complete, the contents of the canvas are transferred to the physical display by the display driver.</span></span> <span data-ttu-id="e6efc-533">Ayrı bir tuval ve çerçeve arabelleği bellek alanı için yeterli belleğe sahip olmayan bazı sistemlerde, tuval güncelleştirmesi aslında görüntü sürücüsü aracılığıyla doğrudan fiziksel görüntülemeye yapılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-533">In some systems that don’t have enough memory for a separate canvas and frame buffer memory areas, the canvas update is actually made directly to the physical display via the display driver.</span></span>

### <a name="canvas-creation"></a><span data-ttu-id="e6efc-534">Tuval oluşturma</span><span class="sxs-lookup"><span data-stu-id="e6efc-534">Canvas Creation</span></span> 

<span data-ttu-id="e6efc-535">Bir tuval nesnesi, başlatma sırasında veya uygulama iş parçacıklarının yürütülmesi sırasında herhangi bir zamanda oluşturulabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-535">A canvas object can be created during initialization or anytime during the execution of application threads.</span></span> <span data-ttu-id="e6efc-536">Bir uygulama tarafından oluşturulabilen tuval nesneleri sayısında bir sınır yoktur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-536">There is no limit on the number of canvas objects that can be created by an application.</span></span> <span data-ttu-id="e6efc-537">Ancak çoğu uygulama, tüm Gux çizimi için yalnızca bir tuval nesnesi oluşturur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-537">Most applications, however, will create only one canvas object for all GUIX drawing.</span></span>

### <a name="canvas-control-block"></a><span data-ttu-id="e6efc-538">Tuval denetim bloğu</span><span class="sxs-lookup"><span data-stu-id="e6efc-538">Canvas Control Block</span></span> 

<span data-ttu-id="e6efc-539">Her tuval nesnesinin özellikleri, denetim bloğunda **GX_CANVAS** bulunur ve **_gx_api. h_** içinde tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-539">The characteristics of each canvas object are found in its control block **GX_CANVAS** and is defined in **_gx_api.h_**.</span></span> <span data-ttu-id="e6efc-540">Tuval nesnesi için gereken bellek, uygulama tarafından sağlanır ve bellekte herhangi bir yerde bulunabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-540">The memory required for a canvas object is provided by the application and can be located anywhere in memory.</span></span> <span data-ttu-id="e6efc-541">Ancak, tuval nesne denetim bloğunu ve çizim alanını herhangi bir işlevin kapsamı dışında tanımlayarak genel bir yapıya getirmek en yaygın olarak kullanılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-541">However, it is most common to make the canvas object control block and the drawing area a global structure by defining them outside the scope of any function.</span></span>

### <a name="canvas-alpha-channel"></a><span data-ttu-id="e6efc-542">Tuval alfa kanalı</span><span class="sxs-lookup"><span data-stu-id="e6efc-542">Canvas Alpha Channel</span></span>

<span data-ttu-id="e6efc-543">GUIX, her piksel için bir karıştırma oranı belirten bit eşlem ve arka plan renklerinin, 16 BPP ve daha yüksek renk derinliğinde bir fırçanın karıştırma oranını belirten ve bir kaplama tuvalinin karıştırma oranını belirten bir tuval Alpha da dahil olmak üzere çok sayıda düzeyde ön plan ve arka plan renklerini Alfa karışımı destekler.</span><span class="sxs-lookup"><span data-stu-id="e6efc-543">GUIX supports alpha-blending of foreground and background colors on many levels, including bitmap alpha channel which specifies a blending ratio per pixel, brush alpha which specifies the blending ratio for a brush at 16 bpp and higher color depths, and canvas alpha which specifies the blending ratio for an overlay canvas.</span></span>

<span data-ttu-id="e6efc-544">Bir tuvalin alfa değeri, çerçeve arabelleği içinde görüntülenmek üzere bir araya eklenen birden çok canvaya olduğunda kullanılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-544">The alpha value of a canvas is used when there are multiple canvases which are composited together for display within the frame buffer.</span></span> <span data-ttu-id="e6efc-545">Tuval Z düzeni diğer canvaların üzerinde yer alıyorsa, tuval alfa değeri tuvali arkasında yer alan öğelerle Blend için ayarlanabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-545">If the canvas Z-order is such that a canvas is above other canvases, then the canvas alpha value can be set to blend the canvas with those that lie behind.</span></span> <span data-ttu-id="e6efc-546">Bir tuvalin Alfa değerini hızlı bir şekilde değiştirmek, "belirme" ekran geçişi efektlerini sağlamak için kullanılır, ancak tuval Alpha birçok şekilde kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-546">Rapidly modifying the alpha value of a canvas is used to provide “fade in” screen transition effects, but the canvas alpha can be used in many ways.</span></span>

<span data-ttu-id="e6efc-547">Bir tuval gx_canvas_hardware_layer_bind () kullanılarak bir donanım grafik katmanına bağlıysa, GUıDX, bir kaplama tuvali karıştırma ile İlişkili Yazılım ek yükünü en aza indirerek, donanım desteğinden yararlanarak tuval Alpha karışımı uygulamayı dener.</span><span class="sxs-lookup"><span data-stu-id="e6efc-547">If a canvas is bound to a hardware graphics layer using gx_canvas_hardware_layer_bind(), GUIX will attempt to implement canvas alpha blending utilizing hardware support, minimizing the software overhead associated with blending an overlay canvas.</span></span>

<span data-ttu-id="e6efc-548">Alfa değerleri 0 ile 255 arasında değişir; burada 0 değeri, pikselin tamamen şeffaf olduğu ve 0 ' dan büyük değerlerin daha az saydam olduğu anlamına gelir ve tuval karıştırma için donanım yardımı sağlanmamışsa yalnızca 16-BPP ve üzeri sürümlerde çalışan ekran sürücüleri için desteklenir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-548">Alpha values range from 0 through 255, where a value of 0 means the pixel is fully transparent and values greater than 0 are increasing less transparent canvas alpha value can only be supported for screen drivers running at 16-bpp and higher unless hardware assistance for canvas blending is provided.</span></span>

### <a name="canvas-offset"></a><span data-ttu-id="e6efc-549">Tuval boşluğu</span><span class="sxs-lookup"><span data-stu-id="e6efc-549">Canvas Offset</span></span> 

<span data-ttu-id="e6efc-550">Bir tuval, ***gx_canvas_offset_set*** API hizmetini çağırarak görünür çerçeve arabelleği içinde yer alabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-550">A canvas can be offset within the visible frame buffer by invoking the ***gx_canvas_offset_set*** API service.</span></span> <span data-ttu-id="e6efc-551">Tuval uzaklıkları genellikle Sprite animasyonlarını uygulamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-551">Canvas offsets are usually used to implement sprite animations.</span></span> <span data-ttu-id="e6efc-552">Bir tuval ***gx_canvas_hardware_layer_bind*** API işlevini çağırarak bir donanım grafik katmanına bağlıysa, guıdx, tuval konumunu değiştirme ile İlişkili Yazılım ek yükünü en aza indirerek donanım desteğini kullanan tuval fark değişikliklerini uygulamaya çalışır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-552">If a canvas is bound to a hardware graphics layer by invoking the ***gx_canvas_hardware_layer_bind*** API function, GUIX will attempt to implement canvas offset changes utilizing hardware support, minimizing the software overhead associated with shifting the canvas position.</span></span>

### <a name="canvas-drawing"></a><span data-ttu-id="e6efc-553">Tuval çizimi</span><span class="sxs-lookup"><span data-stu-id="e6efc-553">Canvas Drawing</span></span> 

<span data-ttu-id="e6efc-554">GUX tuvali bileşeni, uygulamaya tam bir çizim API 'SI sağlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-554">The GUIX canvas component provides a full drawing API to the application.</span></span> <span data-ttu-id="e6efc-555">***Gx_canvas_line_draw*** veya ***Gx_canvas_pixelmap_draw*** gibi çizim API 'leri çağrılabilmeniz için, ***gx_canvas_drawing_initiate*** API işlevini çağırarak hedef Tuvalin çizim için açılması gerekir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-555">Before the drawing APIs such as ***gx_canvas_line_draw*** or ***gx_canvas_pixelmap_draw*** can be invoked, the target canvas must be opened for drawing by invoking the ***gx_canvas_drawing_initiate*** API function.</span></span> <span data-ttu-id="e6efc-556">Bu işlev, çizim için bir tuval hazırlar ve ***Çizim bağlamı*** oluşturur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-556">This function prepares a canvas for drawing and creates a ***drawing context***.</span></span>

<span data-ttu-id="e6efc-557">Tuvale işlenen, ***gx_canvas_line_draw** _ veya _*_Gx_canvas_text_draw_\*_ gibi çizim API 'leri, çizgi stilini, genişliği ve renkleri tanımlamak için geçerli çizim bağlamı fırçasının içinde bulunan parametreleri kullanır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-557">The drawing APIs that render to the canvas, such as ***gx_canvas_line_draw** _ or _*_gx_canvas_text_draw_\*_, use parameters found in the current drawing context brush to define the line style, width, and colors.</span></span> <span data-ttu-id="e6efc-558">Bu fırça parametreleri, _ *_gx_canvas_drawing_initiate_* \* çağırarak bir çizim bağlamı kurulduktan sonra _*_gx_context_brush_define_*_, _\* _gx_context_brush_set_\* \*, \***gx_context_brush_style_set**_ ve benzer API işlevleri çağırarak değiştirilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-558">These brush parameters are modified by calling the _*_gx_context_brush_define_*_, _\*_gx_context_brush_set_\*\*, \***gx_context_brush_style_set**_, and similar API functions after a drawing context has been established by calling _\*_gx_canvas_drawing_initiate_\*\*.</span></span>

<span data-ttu-id="e6efc-559">GUIX, bir ertelenmiş tuval yenileme işleminin parçası olarak pencere ve pencere öğesi çizim işlevlerini çağırdığında, hedef tuval pencere öğesi çizim işlevleri çağrılmadan önce çizim için açılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-559">When GUIX invokes the window and widget drawing functions as part of a deferred canvas refresh operation, the target canvas is opened for drawing prior to calling the widget drawing function(s).</span></span> <span data-ttu-id="e6efc-560">Bu nedenle, standart pencere öğesi çizim işlevleri hedef tuvali açmak için gerekli değildir, bu, bunlar için yapılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-560">Therefore the standard widget drawing functions are not required to open the target canvas, this has been done for them.</span></span>

<span data-ttu-id="e6efc-561">Bazı durumlarda, uygulama bir tuvale hemen çizim zorlamak isteyebilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-561">In some cases the application may want to force immediate drawing to a canvas.</span></span> <span data-ttu-id="e6efc-562">Bu durumda, uygulama aşağıdaki adımları gerçekleştirebilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-562">In this case, the application can perform the following steps.</span></span>

1. <span data-ttu-id="e6efc-563">Hedef tuvali ve uygulamanın çizmek istediği tuval içindeki dikdörtgeni geçirerek ***gx_canvas_drawing_initiate*** API işlevini çağırın.</span><span class="sxs-lookup"><span data-stu-id="e6efc-563">Call the ***gx_canvas_drawing_initiate*** API function, passing in the target canvas and rectangle within that canvas on which the application wants to draw.</span></span> 

2. <span data-ttu-id="e6efc-564">İstenen çizimi gerçekleştirmek için herhangi bir sayıda tuval çizimi API 'si çağırın.</span><span class="sxs-lookup"><span data-stu-id="e6efc-564">Call any number of canvas drawing APIs to accomplish the desired drawing.</span></span>

3. <span data-ttu-id="e6efc-565">Çizimin tamamlandığını bildirmek için ***gx_canvas_drawing_complete*** API işlevini çağırın.</span><span class="sxs-lookup"><span data-stu-id="e6efc-565">Call the ***gx_canvas_drawing_complete*** API function to signal that drawing has been completed.</span></span> <span data-ttu-id="e6efc-566">Bu, tuvali görünür çerçeve arabelleğine boşaltır ve/veya sistem belleği mimarisine bağlı olarak bir arabellek geçiş işlemi tetikler.</span><span class="sxs-lookup"><span data-stu-id="e6efc-566">This flushes the canvas to the visible frame buffer and/or triggers a buffer toggle operation, depending on the system memory architecture.</span></span>

### <a name="drawing-apis"></a><span data-ttu-id="e6efc-567">Çizim API 'Leri</span><span class="sxs-lookup"><span data-stu-id="e6efc-567">Drawing APIs</span></span> 

<span data-ttu-id="e6efc-568">Ekrandaki tüm görsel öğeleri çizmek için Gux 'in gerektirdiği birkaç asıl çizim temel tabanı vardır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-568">There are several principal drawing primitives that are required by GUIX to draw all the visual elements on the screen.</span></span> <span data-ttu-id="e6efc-569">Bu çizim API 'Leri, genellikle özel bir pencere öğesi çizim işlevinin bir parçası olarak uygulama yazılımı tarafından da çağrılabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-569">These drawing APIs can also be invoked by application software, usually as part of a custom widget drawing function.</span></span> <span data-ttu-id="e6efc-570">Bu Gux tuval çizim API 'Leri parametre doğrulama ve kırpma işlemleri yapar ve ardından kırpılan çizim koordinatlarını, donanım ve renk biçimine özgü çizim uygulamaları için görüntü sürücüsüne iletir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-570">These GUIX canvas drawing APIs perform parameter validation and clipping, and then pass the clipped drawing coordinates down to the display driver for hardware and color-format specific drawing implementations.</span></span> <span data-ttu-id="e6efc-571">Bu çizim API 'SI işlevleri aşağıdaki gibi tanımlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-571">These drawing API functions are defined as follows.</span></span>

- <span data-ttu-id="e6efc-572">gx_canvas_alpha_set</span><span class="sxs-lookup"><span data-stu-id="e6efc-572">gx_canvas_alpha_set</span></span>
- <span data-ttu-id="e6efc-573">gx_canvas_arc_draw</span><span class="sxs-lookup"><span data-stu-id="e6efc-573">gx_canvas_arc_draw</span></span>
- <span data-ttu-id="e6efc-574">gx_canvas_block_move</span><span class="sxs-lookup"><span data-stu-id="e6efc-574">gx_canvas_block_move</span></span>
- <span data-ttu-id="e6efc-575">gx_canvas_circle_draw</span><span class="sxs-lookup"><span data-stu-id="e6efc-575">gx_canvas_circle_draw</span></span>
- <span data-ttu-id="e6efc-576">gx_canvas_ellipse_draw</span><span class="sxs-lookup"><span data-stu-id="e6efc-576">gx_canvas_ellipse_draw</span></span>
- <span data-ttu-id="e6efc-577">gx_canvas_glyphs_draw</span><span class="sxs-lookup"><span data-stu-id="e6efc-577">gx_canvas_glyphs_draw</span></span>
- <span data-ttu-id="e6efc-578">gx_canvas_hardware_layer_bind</span><span class="sxs-lookup"><span data-stu-id="e6efc-578">gx_canvas_hardware_layer_bind</span></span>
- <span data-ttu-id="e6efc-579">gx_canvas_hide</span><span class="sxs-lookup"><span data-stu-id="e6efc-579">gx_canvas_hide</span></span>
- <span data-ttu-id="e6efc-580">gx_canvas_line_draw</span><span class="sxs-lookup"><span data-stu-id="e6efc-580">gx_canvas_line_draw</span></span>
- <span data-ttu-id="e6efc-581">gx_canvas_offset_set</span><span class="sxs-lookup"><span data-stu-id="e6efc-581">gx_canvas_offset_set</span></span>
- <span data-ttu-id="e6efc-582">gx_canvas_pie_draw</span><span class="sxs-lookup"><span data-stu-id="e6efc-582">gx_canvas_pie_draw</span></span>
- <span data-ttu-id="e6efc-583">gx_canvas_pixel_draw</span><span class="sxs-lookup"><span data-stu-id="e6efc-583">gx_canvas_pixel_draw</span></span>
- <span data-ttu-id="e6efc-584">gx_canvas_pixelmap_blend</span><span class="sxs-lookup"><span data-stu-id="e6efc-584">gx_canvas_pixelmap_blend</span></span>
- <span data-ttu-id="e6efc-585">gx_canvas_pixelmap_rotate</span><span class="sxs-lookup"><span data-stu-id="e6efc-585">gx_canvas_pixelmap_rotate</span></span>
- <span data-ttu-id="e6efc-586">gx_canvas_pixelmap_tile</span><span class="sxs-lookup"><span data-stu-id="e6efc-586">gx_canvas_pixelmap_tile</span></span>
- <span data-ttu-id="e6efc-587">gx_canvas_polygon_draw</span><span class="sxs-lookup"><span data-stu-id="e6efc-587">gx_canvas_polygon_draw</span></span>
- <span data-ttu-id="e6efc-588">gx_canvas_rectangle_draw</span><span class="sxs-lookup"><span data-stu-id="e6efc-588">gx_canvas_rectangle_draw</span></span>
- <span data-ttu-id="e6efc-589">gx_canvas_rotated_text_draw</span><span class="sxs-lookup"><span data-stu-id="e6efc-589">gx_canvas_rotated_text_draw</span></span>
- <span data-ttu-id="e6efc-590">gx_canvas_shift</span><span class="sxs-lookup"><span data-stu-id="e6efc-590">gx_canvas_shift</span></span>
- <span data-ttu-id="e6efc-591">gx_canvas_show</span><span class="sxs-lookup"><span data-stu-id="e6efc-591">gx_canvas_show</span></span>
- <span data-ttu-id="e6efc-592">gx_canvas_text_draw</span><span class="sxs-lookup"><span data-stu-id="e6efc-592">gx_canvas_text_draw</span></span>

<span data-ttu-id="e6efc-593">Çizim API 'si Gux tuval API 'SI aracılığıyla çağrılır ve tüm çizimler gx_canvas_ \* API işlevleri kullanılarak yapılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-593">The drawing API is invoked via the GUIX Canvas API, and all drawing is done using gx_canvas_\* API functions.</span></span> <span data-ttu-id="e6efc-594">Çizim, geçerli çizim bağlamındaki geçerli fırça kullanılarak yapılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-594">Drawing is done using the current brush in the current drawing context.</span></span> <span data-ttu-id="e6efc-595">Yukarıdaki şekil çizim işlevlerinden herhangi biri, geçerli fırça tarafından tanımlanan şekilde anahatlı, düz renk doldurulmuş veya pixelmap olarak doldurulmuş olabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-595">Any of the shape drawing functions above can be outlined, solid color filled, or pixelmap filled as defined by the current brush.</span></span> <span data-ttu-id="e6efc-596">Şekil ana hat genişliğini, rengini veya dolguyu değiştirmek için, geçerli çizim bağlamı içinde fırçayı tanımlamak üzere gx_context_brush_ \* API işlevlerini kullanın.</span><span class="sxs-lookup"><span data-stu-id="e6efc-596">To modify the shape outline width, color, or fill, use the gx_context_brush_\* API functions to define the brush within the current drawing context.</span></span>

<span data-ttu-id="e6efc-597">Yukarıdaki uygulama düzeyi çizim API 'Leri tuvalde gerçek çizim yapmayın, ancak bunun yerine, görüntü sürücü düzeyi çizim işlevini çağırmadan önce çağıranın parametrelerini doğrulayın.</span><span class="sxs-lookup"><span data-stu-id="e6efc-597">The above application level drawing APIs don’t do actual drawing to the canvas, but instead verify the caller’s parameters before invoking the display driver level drawing function.</span></span> <span data-ttu-id="e6efc-598">Sürücü düzeyi çizim işlevi aslında bir piksel verisini tuval belleğine yazar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-598">The driver level drawing function actually writes pixel data into the canvas memory.</span></span>

<span data-ttu-id="e6efc-599">GUX, 1, 2, 4, 8, 16, 24 ve piksel başına 32 bit (BPP) dahil olmak üzere çeşitli renk derinlikleri için hisse veya genel ekran sürücüsü çizim işlevleri sağlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-599">GUIX provides stock or generic display driver drawing functions for various color depths, including 1, 2, 4, 8, 16, 24, and 32 bits per pixel (bpp).</span></span> <span data-ttu-id="e6efc-600">Bazı durumlarda, varsayılan yazılım çizimi uygulaması, 2B çizim Hızlandırıcısı sağlayan bu donanım hedefleri için donanım hızlandırmalı uygulamalarla değiştirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-600">In some cases, the default software drawing implementation is replaced by hardware-accelerated implementations for those hardware targets that provide a 2D drawing accelerator.</span></span>

### <a name="color-depth"></a><span data-ttu-id="e6efc-601">Renk derinliği</span><span class="sxs-lookup"><span data-stu-id="e6efc-601">Color Depth</span></span> 

<span data-ttu-id="e6efc-602">GUX, 32-BPP ve tek renkli ve gri tonlamalı renk derinliklerini destekler.</span><span class="sxs-lookup"><span data-stu-id="e6efc-602">GUIX supports color depths up to 32-bpp as well as monochrome and grayscale.</span></span> <span data-ttu-id="e6efc-603">Büyük ölçüde temel alınan fiziksel görüntünün özelliklerine göre belirlenen renk derinliği desteği ve ayrıca tuval çizim alanı için gereken bellek miktarı üzerinde bir etkisi vardır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-603">The type of color depth support largely determined by the capabilities of the underlying physical display and also has an impact on how much memory is required for the canvas drawing area.</span></span> <span data-ttu-id="e6efc-604">Renk derinliği desteğinin bir listesi, bu renk derinliği içindeki çeşitlemelerin kısa bir açıklamasıyla birlikte verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-604">The following is a list of color depth support along with a brief description of the variations within that color depth.</span></span>

| <span data-ttu-id="e6efc-605">Renk &nbsp; biçimi</span><span class="sxs-lookup"><span data-stu-id="e6efc-605">Color&nbsp;Format</span></span>       | <span data-ttu-id="e6efc-606">Açıklama</span><span class="sxs-lookup"><span data-stu-id="e6efc-606">Description</span></span>                                                                                                   |
| ------------------ | -------------------------------------------------------------------------------------------------------------------------------- |
| <span data-ttu-id="e6efc-607">1 bit tek renkli</span><span class="sxs-lookup"><span data-stu-id="e6efc-607">1-bit monochrome</span></span>   | <span data-ttu-id="e6efc-608">piksel olarak paketlenmiş biçim başına 1 bit.</span><span class="sxs-lookup"><span data-stu-id="e6efc-608">1-bit per pixel packed format.</span></span>                                                                                                   |
| <span data-ttu-id="e6efc-609">2 bit gri tonlamalı</span><span class="sxs-lookup"><span data-stu-id="e6efc-609">2-bit grayscale</span></span>    | <span data-ttu-id="e6efc-610">4 gri düzey, her bayt için dört piksel.</span><span class="sxs-lookup"><span data-stu-id="e6efc-610">4 gray levels, packed four pixels per byte.</span></span>                                                                                      |
| <span data-ttu-id="e6efc-611">4 bit gri tonlamalı</span><span class="sxs-lookup"><span data-stu-id="e6efc-611">4-bit grayscale</span></span>    | <span data-ttu-id="e6efc-612">16 gri düzey, bayt başına iki piksel.</span><span class="sxs-lookup"><span data-stu-id="e6efc-612">16 gray levels, packed two pixels per byte.</span></span>                                                                                      |
| <span data-ttu-id="e6efc-613">4 bit renk</span><span class="sxs-lookup"><span data-stu-id="e6efc-613">4-bit color</span></span>        | <span data-ttu-id="e6efc-614">VGA biçim düzlem belleği organizasyonu.</span><span class="sxs-lookup"><span data-stu-id="e6efc-614">A VGA format planar memory organization.</span></span>                                                                                         |
| <span data-ttu-id="e6efc-615">8 bit gri tonlamalı</span><span class="sxs-lookup"><span data-stu-id="e6efc-615">8-bit grayscale</span></span>    | <span data-ttu-id="e6efc-616">256 gri düzeyler</span><span class="sxs-lookup"><span data-stu-id="e6efc-616">256 gray levels</span></span>                                                                                                                  |
| <span data-ttu-id="e6efc-617">8 bit palet modu</span><span class="sxs-lookup"><span data-stu-id="e6efc-617">8-bit palette mode</span></span> | <span data-ttu-id="e6efc-618">Palet dizini olarak kullanılan piksel başına 1 bayt</span><span class="sxs-lookup"><span data-stu-id="e6efc-618">1 byte per pixel used as palette index</span></span>                                                                                           |
| <span data-ttu-id="e6efc-619">8 bit r:g: b modu</span><span class="sxs-lookup"><span data-stu-id="e6efc-619">8-bit r:g:b mode</span></span>   | <span data-ttu-id="e6efc-620">Daha az yaygın olarak kullanılan 2:3:2 r:g: b biçimi.</span><span class="sxs-lookup"><span data-stu-id="e6efc-620">A less commonly used 2:3:2 r:g:b format.</span></span>                                                                                         |
| <span data-ttu-id="e6efc-621">16 bit</span><span class="sxs-lookup"><span data-stu-id="e6efc-621">16-bit</span></span>             | <span data-ttu-id="e6efc-622">Her piksel iki bayt gerektirir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-622">Each pixel requires two bytes.</span></span> <span data-ttu-id="e6efc-623">R:g: b veya b:g: r bayt sıralaması olabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-623">Can be r:g:b or b:g:r byte order.</span></span> <span data-ttu-id="e6efc-624">Normalde 5:6:5 yapısı, ancak 5:5:5 yapısı veya 4:4:4:4 a:r: g:b yapısı da olabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-624">Normally 5:6:5 structure, but can also be 5:5:5 structure or 4:4:4:4 a:r:g:b structure.</span></span> |
| <span data-ttu-id="e6efc-625">24 bit</span><span class="sxs-lookup"><span data-stu-id="e6efc-625">24-bit</span></span>             | <span data-ttu-id="e6efc-626">Her piksel 3 (paketlenmiş biçim) veya 4 (paketi açılmış biçim) bayt gerektirir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-626">Each pixel requires 3 (packed format) or 4 (unpacked format) bytes.</span></span> <span data-ttu-id="e6efc-627">R:g: b veya b:g: donanım tarafından istenen şekilde r bayt sıralaması içinde olabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-627">Can be in r:g:b or b:g:r byte order as required by hardware.</span></span> |
| <span data-ttu-id="e6efc-628">32 bit</span><span class="sxs-lookup"><span data-stu-id="e6efc-628">32-bit</span></span>             | <span data-ttu-id="e6efc-629">Her piksel bir alfa kanalı ile 4 bayt gerektirir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-629">Each pixel requires 4 bytes with an alpha channel.</span></span> <span data-ttu-id="e6efc-630">Can r: g:b veya b:g: r:a bayt sırası ve donanımla belirlenir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-630">Can be a:r:g:b or b:g:r:a byte order and determined by hardware.</span></span>              |

### <a name="mouse-support"></a><span data-ttu-id="e6efc-631">Fare desteği</span><span class="sxs-lookup"><span data-stu-id="e6efc-631">Mouse Support</span></span> 

<span data-ttu-id="e6efc-632">GUIX, istenen tuvalde fare imlecini çizmeyi destekler.</span><span class="sxs-lookup"><span data-stu-id="e6efc-632">GUIX supports drawing a mouse cursor on any desired canvas.</span></span> <span data-ttu-id="e6efc-633">Fare imleci yazılımda çizilirken veya donanım imleç kaplaması tarafından destekleniyor olabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-633">The mouse cursor can be drawing in software or might be supported by hardware cursor overlay.</span></span> <span data-ttu-id="e6efc-634">Her iki durumda da, fare imleç desteğiyle ilgili uygulamaya sunulan API, yazılım veya donanım fare imleç çizimi ile aynı olup olmadığına benzer.</span><span class="sxs-lookup"><span data-stu-id="e6efc-634">In either case, the API provided to the application related to mouse cursor support is the same whether using software or hardware mouse cursor drawing.</span></span>

<span data-ttu-id="e6efc-635">GUX fare desteği yalnızca, `#define GX_MOUSE_SUPPORT` Gux kitaplığını oluşturmadan önce gx_user. h üstbilgi dosyasında tanımlanmışsa etkinleştirilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-635">GUIX mouse support is only enabled if the `#define GX_MOUSE_SUPPORT` is defined in the gx_user.h header file before building the GUIX library.</span></span>

<span data-ttu-id="e6efc-636">Uygulama, ***gx_canvas_mouse_define*** API işlevini kullanarak fare imlecini ve etkin noktayı tanımlamalıdır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-636">The application must define the mouse cursor and hotspot using the ***gx_canvas_mouse_define*** API function.</span></span> <span data-ttu-id="e6efc-637">Bu API, imleç resminin çizilmesi gereken tuvale yönelik bir işaretçi ve fare imleci görüntüsünü ve görüntünün sol üst köşesine göre fare resminin etkin olmasını tanımlayan **GX_MOUSE_CURSOR_INFO** yapısına yönelik bir işaretçi kabul eder.</span><span class="sxs-lookup"><span data-stu-id="e6efc-637">This API accepts a pointer to the canvas on which the cursor image should be drawn, and a pointer to a **GX_MOUSE_CURSOR_INFO** structure, which defines the mouse cursor image and hotspot of the mouse image relative the image top-left corner.</span></span>

## <a name="guix-display-component"></a><span data-ttu-id="e6efc-638">GUX görüntü bileşeni</span><span class="sxs-lookup"><span data-stu-id="e6efc-638">GUIX Display Component</span></span> 

<span data-ttu-id="e6efc-639">Görüntüleme bileşeni, her bir veya daha fazla canvau, pencere öğesi ve pencere içerdiği tüm görüntüleme nesnelerinin işlenmesini yönettiği için, GUıDX içinde temel bir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-639">The display component is fundamental in GUIX, since it manages the processing of all display objects, which in themselves contain one or more canvases, widgets, and windows.</span></span> <span data-ttu-id="e6efc-640">Görüntü bileşeni aynı zamanda bir dizi işlev işaretçisi aracılığıyla her bir ekranla ilişkili temel alınan donanım ekran sürücüsüyle etkileşime girer.</span><span class="sxs-lookup"><span data-stu-id="e6efc-640">The display component also interacts with the underlying hardware screen driver associated with each display through a series of function pointers.</span></span>

### <a name="display-creation"></a><span data-ttu-id="e6efc-641">Görüntüleme oluşturma</span><span class="sxs-lookup"><span data-stu-id="e6efc-641">Display Creation</span></span> 

<span data-ttu-id="e6efc-642">Bir görüntüleme nesnesi başlatma sırasında veya uygulama iş parçacıklarının yürütülmesi sırasında herhangi bir zamanda oluşturulabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-642">A display object can be created during initialization or anytime during the execution of application threads.</span></span> <span data-ttu-id="e6efc-643">Genellikle bir uygulama, her fiziksel ekranı yönetmek için bir görüntüleme nesnesi oluşturur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-643">Typically an application creates one display object to manage each physical screen.</span></span> <span data-ttu-id="e6efc-644">Uygulamanızı ve kullanılabilir fiziksel ekranları tanımlamak için Gux Studio kullandıysanız, görüntülerinizin her birini oluşturmak ve başlatmak için gx_studio_display_configure API işlevini kullanırsınız.</span><span class="sxs-lookup"><span data-stu-id="e6efc-644">If you have used GUIX Studio to define your application and the physical displays available, you will use the gx_studio_display_configure API function to create and initialize each of your displays.</span></span>

### <a name="display-control-block"></a><span data-ttu-id="e6efc-645">Görüntüleme denetim bloğu</span><span class="sxs-lookup"><span data-stu-id="e6efc-645">Display Control Block</span></span> 

<span data-ttu-id="e6efc-646">Her bir görüntüleme nesnesinin özellikleri, denetim bloğunda \***GX_DISPLAY** _ bulunur ve _ *_gx_api. h_* \* içinde tanımlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-646">The characteristics of each display object are found in its control block ***GX_DISPLAY** _ and are defined in _*_gx_api.h_\*\*.</span></span> <span data-ttu-id="e6efc-647">Bir görüntüleme nesnesi için gereken bellek, uygulama tarafından sağlanır ve bellekte herhangi bir yerde bulunabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-647">The memory required for a display object is provided by the application and can be located anywhere in memory.</span></span> <span data-ttu-id="e6efc-648">Ancak, herhangi bir işlevin kapsamı dışında tanımlayarak, görüntüleme denetiminin genel yapıyı engellemesini sağlamak en yaygın olarak kullanılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-648">However, it is most common to make the display control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="resource-management"></a><span data-ttu-id="e6efc-649">Kaynak Yönetimi</span><span class="sxs-lookup"><span data-stu-id="e6efc-649">Resource Management</span></span> 

<span data-ttu-id="e6efc-650">Kaynaklar, uygulamanın gerektirdiği Kullanıcı arabirimi bileşenleridir, ancak uygulama kodu değildir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-650">Resources are UI components that are needed by the application, but they are not application code.</span></span> <span data-ttu-id="e6efc-651">Kaynaklar uygulama verileri olur ve genellikle statik olarak tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-651">Resources are application data and are usually statically defined.</span></span> <span data-ttu-id="e6efc-652">Kaynak türleri arasında pixelmaps, yazı tipleri, renkler ve dizeler bulunur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-652">Resource types include pixelmaps, fonts, colors, and strings.</span></span> <span data-ttu-id="e6efc-653">Bu kaynaklar, genellikle herhangi bir uygulama yazılımını değiştirmeksizin herhangi bir zamanda değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-653">These resources can be changed at any time, usually without changing any application software.</span></span> <span data-ttu-id="e6efc-654">Uygulama yazılımında yapılan değişiklikler genellikle ilgili yazılımın yeniden test edilmesi ve doğrulanması gerektiğinden, uygulama kodunu değiştirmeden Kullanıcı arabirimi görünümü değişikliğine izin vermek için uygulama yazılımından ayrılan kaynaklara yönelik depolamanın ve başvuruların tutulması önemlidir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-654">It is important to keep the storage of and references to resources separated from the application software to allow changing UI appearance without changing application code since changes to the application software usually require the associated re-testing and verification of that software.</span></span>

<span data-ttu-id="e6efc-655">GUX ***görüntüleme*** modülü, ekran renk derinliğine ve görüntü biçimine bağlı olan tüm kaynaklar için kaynak yönetimi olanakları sağlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-655">The GUIX ***display*** module provides resource management facilities for all resources that are dependent on the color depth and format of the display.</span></span> <span data-ttu-id="e6efc-656">Bu tesisler, etkin pixelmap tablosu, etkin yazı tipi tablosu ve etkin renk tablosunun korunmasından daha fazlasını içerir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-656">These facilities include maintaining the active pixelmap table, active font table, and active color table.</span></span> <span data-ttu-id="e6efc-657">Dize kaynakları normalde renk derinliğine ve biçime göre değiştirilmemelidir, dize tablosu kaynağı Gux sistem modülü tarafından korunur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-657">The string table resource is maintained by the GUIX system module, since string resources do not normally need to be changed based on color depth and format.</span></span>

<span data-ttu-id="e6efc-658">Uygulama yazılımı kaynaklarına kaynak kimliğine göre başvurur, bu da karşılık gelen kaynak tablosuna bir dizindir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-658">The application software references resources by their resource Id, which is an index into the corresponding resource table.</span></span> <span data-ttu-id="e6efc-659">Bu, tablonun değiştirilmesine izin verir, örneğin, bir ürün "gün modu" iken "gece modu" olarak değiştiğinde ancak renk KIMLIĞI değerleri aynı kalacaksa renk tablosu değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-659">This allows the table to be changed, for example the color table might be changed when a product changes from “day mode” to “night mode”, but the color ID values to remain the same.</span></span>

<span data-ttu-id="e6efc-660">Uygulama kaynaklarınız, GUıDX Studio uygulaması tarafından bir kaynak dosyasına (veya kaynak dosyaları kümesine) yazılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-660">Your application resources are written to a resource file (or set of resource files) by the GUIX Studio application.</span></span> <span data-ttu-id="e6efc-661">Varsayılan renkler, pixelmaps ve yazı tipleri, yeni bir Gux Studio projesi oluşturduğunuzda otomatik olarak sağlanır, ancak uygulamanızın görünümünü ve hisyi tanımladığınızda bu varsayılanlar kolayca değiştirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-661">Default colors, pixelmaps, and fonts are provided automatically when you create a new GUIX Studio project, but these defaults are easily replaced as you define the look and feel of your application.</span></span>

<span data-ttu-id="e6efc-662">Renkler, yazı tipleri ve pixelmaps için kaynak kimliklerinin, etkin görüntü bileşeni bilinene kadar gerçek renklerine, yazı tipine veya pixelmap değerlerine çözümlenemeyeceğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="e6efc-662">It is important to note that Resource IDs for colors, fonts, and pixelmaps cannot be resolved to their actual color, font, or pixelmap values until the active Display component is known.</span></span> <span data-ttu-id="e6efc-663">GUX mimarisi birden çok etkin ekranı desteklediğinden, kaynak kimlikleri yalnızca bir pencere öğesi ve ilişkili kaynak KIMLIĞI belirli bir ekranda çözümlenebiliyorsa kaynak değerlerine çözülebilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-663">Since the GUIX architecture supports multiple active displays, Resource IDs can only be resolved to resource values when a widget and its associated Resource ID can be resolved to a specific display.</span></span> <span data-ttu-id="e6efc-664">Bu özellik dinamik bağlama olarak bilinir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-664">This property is known as dynamic binding.</span></span> <span data-ttu-id="e6efc-665">Metin rengi gibi bir özelliğin kaynak KIMLIĞI, örneğin GX_COLOR_ID_TEXT kaynak KIMLIĞI **,** bir ekranda kullanıldığında beyaz için bir 16 BIT r:g: B değeri çözümleyebilir, ancak aynı renk kimliği, başka bir ekranda kullanıldığında tek renkli siyah renk değerine çözümleyebilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-665">The Resource ID for a property such as a text color, for example the resource ID **GX_COLOR_ID_TEXT,** might resolve to a 16-bit R:G:B value for white when used on one display, but the same color ID might resolve to a monochrome black color value when used on another display.</span></span>

<span data-ttu-id="e6efc-666">Bu uygulamada, kaynak değerlerine kaynak kimliklerinin dinamik olarak bağlanması, uygulama yazılımının ve Gux iç bileşenlerinin çoğu zaman yalnızca etkin bir çizim bağlamı içindeki kaynak değerleriyle kaynak kimliklerini çözmesi anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-666">In practice this dynamic binding of Resources IDs to resource values means that application software and GUIX internal components should most often only resolve Resource IDs to resource values within an active drawing context.</span></span> <span data-ttu-id="e6efc-667">Etkin bir çizim bağlamı, Gux 'in her kaynak KIMLIĞINI belirli bir kaynak değerine çözümlemesine izin veren şu anda etkin olan ekranı belirtir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-667">An active drawing context specifies the currently active display, which allows GUIX to resolve each Resource ID to a specific resource value.</span></span> <span data-ttu-id="e6efc-668">Uygulama yazılımının bir çizim bağlamı dışında belirli bir kaynak değerini bulması gerekiyorsa, bu, görünür pencere öğeleri için de yapılabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-668">If the application software is required to find a specific resource value outside of a drawing context, this can also be done for visible widgets.</span></span> <span data-ttu-id="e6efc-669">Görünür pencere öğeleri, etkin tuvali çözümlemek ve bu pencere öğesi için göstermek için de kullanılabilen bir kök pencereye bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-669">Visible widgets are linked to a root window which can also be used to resolve the active canvas and display for that widget.</span></span>

<span data-ttu-id="e6efc-670">Bir pencere öğesi oluşturulmadıysa ancak henüz görüntülenmiyorsa (yani herhangi bir kök pencereye veya başka bir görünmeyen üst öğeye bağlanmadıysa), bu pencere öğesiyle ilişkili tüm kaynak kimlikleri, belirli bir görüntülemeye atanan kaynak tablosunda doğrudan dizin oluşturma dışında, belirli bir kaynak değerine çözümlenemez.</span><span class="sxs-lookup"><span data-stu-id="e6efc-670">If a widget has been created but not yet displayed (i.e., has not been linked to any root window or other visible parent), any resource IDs associated with that widget cannot be resolved to a specific resource value other than by directly indexing into the resource table assigned to a specific display.</span></span> <span data-ttu-id="e6efc-671">Belirli bir kaynak tablosuna doğrudan erişim uygulama yazılımı tarafından güvenli bir şekilde yapılabilir, ancak iç Gux kitaplığı yazılımında hiçbir şekilde yapılmazlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-671">This direct access to a specific resource table can safely be done by the application software, but is never done in the internal GUIX library software.</span></span>

### <a name="widget-defaults"></a><span data-ttu-id="e6efc-672">Pencere öğesi Varsayılanları</span><span class="sxs-lookup"><span data-stu-id="e6efc-672">Widget Defaults</span></span> 

<span data-ttu-id="e6efc-673">GUX görüntü bileşeni ayrıca çeşitli pencere öğesi öznitelikleri için varsayılan tanımlar sağlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-673">The GUIX display component also provides default definitions for various widget attributes.</span></span> <span data-ttu-id="e6efc-674">Aksi takdirde uygulama tarafından belirtilmediği takdirde, pencere öğeleri/pencereler bu sistem öznitelikleriyle oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-674">Unless otherwise specified by the application, widgets/windows are created with these system attributes.</span></span> <span data-ttu-id="e6efc-675">Bu sistem öznitelikleri, genellikle sistem kaynak tablolarında tutulan yazı tiplerinin, renklerin ve Bit eşlemlerin birleşiminden oluşur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-675">These system attributes are mainly composed of fonts, colors, and bitmaps maintained in the system resource tables.</span></span> <span data-ttu-id="e6efc-676">Varsayılan ScrollBar görünümü görünümleri için ek öznitelikler de Gux görüntüleme bileşeni tarafından korunur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-676">Additional attributes for default scrollbar appearance are also maintained by the GUIX display component.</span></span>

<span data-ttu-id="e6efc-677">Varsayılan renk ayarları, her bir ekran için atanan renk tablosu ve önceden tanımlanmış varsayılan renk kimliklerine göre tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-677">The default color settings are defined by the color table assigned to each display and the pre-defined default color IDs.</span></span> <span data-ttu-id="e6efc-678">Bu varsayılan renk kimlikleri şunlardır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-678">These default color ids include the following.</span></span>

| <span data-ttu-id="e6efc-679">Renk KIMLIĞI</span><span class="sxs-lookup"><span data-stu-id="e6efc-679">Color ID</span></span> | <span data-ttu-id="e6efc-680">Açıklama</span><span class="sxs-lookup"><span data-stu-id="e6efc-680">Description</span></span> |
| ------------------ | -------------------------------------------------------------------------------------------------------------------------------- |
| <span data-ttu-id="e6efc-681">GX_COLOR_ID_CANVAS</span><span class="sxs-lookup"><span data-stu-id="e6efc-681">GX_COLOR_ID_CANVAS</span></span> | <span data-ttu-id="e6efc-682">Varsayılan tuval (örn. arka plan ekran) rengi</span><span class="sxs-lookup"><span data-stu-id="e6efc-682">Default canvas (i.e. display background) color</span></span> |
| <span data-ttu-id="e6efc-683">GX_COLOR_ID_WIDGET_FILL</span><span class="sxs-lookup"><span data-stu-id="e6efc-683">GX_COLOR_ID_WIDGET_FILL</span></span> | <span data-ttu-id="e6efc-684">Varsayılan pencere öğesi dolgusu rengi</span><span class="sxs-lookup"><span data-stu-id="e6efc-684">Default widget fill color</span></span> |
| <span data-ttu-id="e6efc-685">GX_COLOR_ID_WINDOW_FILL</span><span class="sxs-lookup"><span data-stu-id="e6efc-685">GX_COLOR_ID_WINDOW_FILL</span></span> | <span data-ttu-id="e6efc-686">Varsayılan pencere dolgusu rengi</span><span class="sxs-lookup"><span data-stu-id="e6efc-686">Default window fill color</span></span> |
| <span data-ttu-id="e6efc-687">GX_COLOR_ID_DISABLED_FILL</span><span class="sxs-lookup"><span data-stu-id="e6efc-687">GX_COLOR_ID_DISABLED_FILL</span></span> | <span data-ttu-id="e6efc-688">Varsayılan devre dışı pencere öğesi dolgusu rengi</span><span class="sxs-lookup"><span data-stu-id="e6efc-688">Default disabled widget fill color</span></span> |
| <span data-ttu-id="e6efc-689">GX_COLOR_ID_DEFAULT_BORDER</span><span class="sxs-lookup"><span data-stu-id="e6efc-689">GX_COLOR_ID_DEFAULT_BORDER</span></span> | <span data-ttu-id="e6efc-690">Varsayılan pencere öğesi kenarlık rengi</span><span class="sxs-lookup"><span data-stu-id="e6efc-690">Default widget border color</span></span> |
| <span data-ttu-id="e6efc-691">GX_COLOR_ID_WINDOW_BORDER</span><span class="sxs-lookup"><span data-stu-id="e6efc-691">GX_COLOR_ID_WINDOW_BORDER</span></span> | <span data-ttu-id="e6efc-692">Varsayılan pencere kenarlığı rengi</span><span class="sxs-lookup"><span data-stu-id="e6efc-692">Default window border color</span></span> |
| <span data-ttu-id="e6efc-693">GX_COLOR_ID_TEXT</span><span class="sxs-lookup"><span data-stu-id="e6efc-693">GX_COLOR_ID_TEXT</span></span> | <span data-ttu-id="e6efc-694">Varsayılan metin rengi</span><span class="sxs-lookup"><span data-stu-id="e6efc-694">Default text color</span></span> |
| <span data-ttu-id="e6efc-695">GX_COLOR_ID_SELECTED_TEXT</span><span class="sxs-lookup"><span data-stu-id="e6efc-695">GX_COLOR_ID_SELECTED_TEXT</span></span> | <span data-ttu-id="e6efc-696">Varsayılan seçili metin rengi</span><span class="sxs-lookup"><span data-stu-id="e6efc-696">Default selected text color</span></span> |
| <span data-ttu-id="e6efc-697">GX_COLOR_ID_DISABLED_TEXT</span><span class="sxs-lookup"><span data-stu-id="e6efc-697">GX_COLOR_ID_DISABLED_TEXT</span></span> | <span data-ttu-id="e6efc-698">Varsayılan devre dışı metin rengi</span><span class="sxs-lookup"><span data-stu-id="e6efc-698">Default disabled text color</span></span> |
| <span data-ttu-id="e6efc-699">GX_COLOR_ID_SELECTED_TEXT_FILL</span><span class="sxs-lookup"><span data-stu-id="e6efc-699">GX_COLOR_ID_SELECTED_TEXT_FILL</span></span> | <span data-ttu-id="e6efc-700">Varsayılan seçili metin dolgusu rengi</span><span class="sxs-lookup"><span data-stu-id="e6efc-700">Default selected text fill color</span></span> |
| <span data-ttu-id="e6efc-701">GX_COLOR_ID_READONLY_TEXT</span><span class="sxs-lookup"><span data-stu-id="e6efc-701">GX_COLOR_ID_READONLY_TEXT</span></span> | <span data-ttu-id="e6efc-702">Varsayılan salt okunur metin rengi</span><span class="sxs-lookup"><span data-stu-id="e6efc-702">Default readonly text color</span></span> |
| <span data-ttu-id="e6efc-703">GX_COLOR_ID_READONLY_FILL</span><span class="sxs-lookup"><span data-stu-id="e6efc-703">GX_COLOR_ID_READONLY_FILL</span></span> | <span data-ttu-id="e6efc-704">Varsayılan salt okunur metin dolgusu rengi</span><span class="sxs-lookup"><span data-stu-id="e6efc-704">Default readonly text fill color</span></span> |
| <span data-ttu-id="e6efc-705">GX_COLOR_ID_SCROLL_FILL</span><span class="sxs-lookup"><span data-stu-id="e6efc-705">GX_COLOR_ID_SCROLL_FILL</span></span> |    <span data-ttu-id="e6efc-706">ScrollBar dolgusu rengi</span><span class="sxs-lookup"><span data-stu-id="e6efc-706">Scrollbar fill color</span></span> |
| <span data-ttu-id="e6efc-707">GX_COLOR_ID_SCROLL_BUTTON</span><span class="sxs-lookup"><span data-stu-id="e6efc-707">GX_COLOR_ID_SCROLL_BUTTON</span></span> | <span data-ttu-id="e6efc-708">Kaydırma çubuğu düğme dolgusu rengi</span><span class="sxs-lookup"><span data-stu-id="e6efc-708">Scrollbar button fill color</span></span> |
| <span data-ttu-id="e6efc-709">GX_COLOR_ID_SHADOW</span><span class="sxs-lookup"><span data-stu-id="e6efc-709">GX_COLOR_ID_SHADOW</span></span> | <span data-ttu-id="e6efc-710">Varsayılan gölge rengi</span><span class="sxs-lookup"><span data-stu-id="e6efc-710">Default shadow color</span></span> |
| <span data-ttu-id="e6efc-711">GX_COLOR_ID_SHINE</span><span class="sxs-lookup"><span data-stu-id="e6efc-711">GX_COLOR_ID_SHINE</span></span> | <span data-ttu-id="e6efc-712">Varsayılan vurgu rengi</span><span class="sxs-lookup"><span data-stu-id="e6efc-712">Default highlight color</span></span> |
| <span data-ttu-id="e6efc-713">GX_COLOR_ID_BUTTON_BORDER</span><span class="sxs-lookup"><span data-stu-id="e6efc-713">GX_COLOR_ID_BUTTON_BORDER</span></span> | <span data-ttu-id="e6efc-714">Düğme pencere öğesi kenarlık rengi</span><span class="sxs-lookup"><span data-stu-id="e6efc-714">Button widget border color</span></span> |
| <span data-ttu-id="e6efc-715">GX_COLOR_ID_BUTTON_UPPER</span><span class="sxs-lookup"><span data-stu-id="e6efc-715">GX_COLOR_ID_BUTTON_UPPER</span></span> | <span data-ttu-id="e6efc-716">Düğme pencere öğesi üst dolgusu rengi</span><span class="sxs-lookup"><span data-stu-id="e6efc-716">Button widget upper fill color</span></span> |
| <span data-ttu-id="e6efc-717">GX_COLOR_ID_BUTTON_LOWER</span><span class="sxs-lookup"><span data-stu-id="e6efc-717">GX_COLOR_ID_BUTTON_LOWER</span></span> | <span data-ttu-id="e6efc-718">Düğme pencere öğesi alt Fill Color</span><span class="sxs-lookup"><span data-stu-id="e6efc-718">Button widget lower fill color</span></span> |
| <span data-ttu-id="e6efc-719">GX_COLOR_ID_BUTTON_TEXT</span><span class="sxs-lookup"><span data-stu-id="e6efc-719">GX_COLOR_ID_BUTTON_TEXT</span></span> | <span data-ttu-id="e6efc-720">Düğme pencere öğesi metin rengi</span><span class="sxs-lookup"><span data-stu-id="e6efc-720">Button widget text color</span></span> |
| <span data-ttu-id="e6efc-721">GX_COLOR_ID_TEXT_INPUT_TEXT</span><span class="sxs-lookup"><span data-stu-id="e6efc-721">GX_COLOR_ID_TEXT_INPUT_TEXT</span></span> | <span data-ttu-id="e6efc-722">Metin girişi pencere öğesi metin rengi</span><span class="sxs-lookup"><span data-stu-id="e6efc-722">Text input widget text color</span></span> |
| <span data-ttu-id="e6efc-723">GX_COLOR_ID_TEXT_INPUT_FILL</span><span class="sxs-lookup"><span data-stu-id="e6efc-723">GX_COLOR_ID_TEXT_INPUT_FILL</span></span> | <span data-ttu-id="e6efc-724">Metin girişi dolgusu rengi</span><span class="sxs-lookup"><span data-stu-id="e6efc-724">Text input fill color</span></span> |
| <span data-ttu-id="e6efc-725">GX_COLOR_ID_SLIDER_TICK</span><span class="sxs-lookup"><span data-stu-id="e6efc-725">GX_COLOR_ID_SLIDER_TICK</span></span> | <span data-ttu-id="e6efc-726">Kaydırıcı değer çizgilerini çizmek için kullanılan renk.</span><span class="sxs-lookup"><span data-stu-id="e6efc-726">Color used to draw slider tick marks.</span></span> |
| <span data-ttu-id="e6efc-727">GX_COLOR_ID_SLIDER_GROOVE_BOTTOM</span><span class="sxs-lookup"><span data-stu-id="e6efc-727">GX_COLOR_ID_SLIDER_GROOVE_BOTTOM</span></span> | <span data-ttu-id="e6efc-728">Kaydırıcı oluk çizmek için kullanılan renk</span><span class="sxs-lookup"><span data-stu-id="e6efc-728">Color used to draw slider groove</span></span> |
| <span data-ttu-id="e6efc-729">GX_COLOR_ID_SLIDER_NEEDLE_OUTLINE</span><span class="sxs-lookup"><span data-stu-id="e6efc-729">GX_COLOR_ID_SLIDER_NEEDLE_OUTLINE</span></span> | <span data-ttu-id="e6efc-730">İğne ana hattını çizmek için kullanılan renk</span><span class="sxs-lookup"><span data-stu-id="e6efc-730">Color used to draw needle outline</span></span> |
| <span data-ttu-id="e6efc-731">GX_COLOR_ID_SLIDER_NEEDLE_FILL</span><span class="sxs-lookup"><span data-stu-id="e6efc-731">GX_COLOR_ID_SLIDER_NEEDLE_FILL</span></span> | <span data-ttu-id="e6efc-732">Kaydırıcı iğne dolgusu için kullanılan renk</span><span class="sxs-lookup"><span data-stu-id="e6efc-732">Color used to fill slider needle</span></span> |
| <span data-ttu-id="e6efc-733">GX_COLOR_ID_SLIDER_NEEDLE_LINE1</span><span class="sxs-lookup"><span data-stu-id="e6efc-733">GX_COLOR_ID_SLIDER_NEEDLE_LINE1</span></span> | <span data-ttu-id="e6efc-734">İğne vurgulaması çizmek için kullanılan renk</span><span class="sxs-lookup"><span data-stu-id="e6efc-734">Color used to draw needle highlight</span></span> |
| <span data-ttu-id="e6efc-735">GX_COLOR_ID_SLIDER_NEEDLE_LINE2</span><span class="sxs-lookup"><span data-stu-id="e6efc-735">GX_COLOR_ID_SLIDER_NEEDLE_LINE2</span></span> | <span data-ttu-id="e6efc-736">İğne gölgesi çizmek için kullanılan renk</span><span class="sxs-lookup"><span data-stu-id="e6efc-736">Color used to draw needle shadow</span></span> |

<span data-ttu-id="e6efc-737">Bu renk KIMLIĞI değerleri, her bir görüntülemeye atanan renk tablosu tarafından tanımlanan belirli bir renk değerine eşlenir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-737">These color ID values are mapped to a specific color value as defined by the color table assigned to each display.</span></span> <span data-ttu-id="e6efc-738">Bu varsayılanlar, ***gx_display_color_table_set*** API işlevi çağırarak bir görüntüleme için Grup olarak değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-738">These defaults can be changed as a group for one display by calling the ***gx_display_color_table_set*** API function.</span></span> <span data-ttu-id="e6efc-739">GUIX Studio kullanıyorsanız, uygulamanız ***gx_studio_display_configure*** işlevini çağırdığında görüntüleme rengi tablosu otomatik olarak başlatılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-739">If you are using GUIX Studio, the display color table is automatically initialized when your application calls the ***gx_studio_display_configure*** function.</span></span>

<span data-ttu-id="e6efc-740">GUX görüntü bileşeni de varsayılan bir yazı tipi tablosu saklar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-740">The GUIX display component also maintains a default font table.</span></span> <span data-ttu-id="e6efc-741">Varsayılan yazı tipi tablosu, uygulama tarafından özel olarak belirtilmedikçe her pencere öğesi türü tarafından kullanılan yazı tipini tanımlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-741">The default font table defines the font used by each widget type unless specifically specified by the application.</span></span> <span data-ttu-id="e6efc-742">Önceden tanımlanmış görüntüleme yazı tipi tablo kimlikleri aşağıdaki değerleri içerir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-742">The pre-defined display font table IDs include the following values.</span></span>

| <span data-ttu-id="e6efc-743">Yazı tipi &nbsp; kimliği</span><span class="sxs-lookup"><span data-stu-id="e6efc-743">Font&nbsp;ID</span></span> | <span data-ttu-id="e6efc-744">Açıklama</span><span class="sxs-lookup"><span data-stu-id="e6efc-744">Description</span></span> |
| ------------------ | --------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="e6efc-745">GX_FONT_ID_DEFAULT</span><span class="sxs-lookup"><span data-stu-id="e6efc-745">GX_FONT_ID_DEFAULT</span></span> | <span data-ttu-id="e6efc-746">Belirli bir yazı tipi tanımlanmadığında kullanılan varsayılan yazı tipi</span><span class="sxs-lookup"><span data-stu-id="e6efc-746">Default font used when no specific font is defined</span></span> |
| <span data-ttu-id="e6efc-747">GX_FONT_ID_BUTTON</span><span class="sxs-lookup"><span data-stu-id="e6efc-747">GX_FONT_ID_BUTTON</span></span> | <span data-ttu-id="e6efc-748">Düğmelerdeki tüm metinler için kullanılan varsayılan yazı tipi</span><span class="sxs-lookup"><span data-stu-id="e6efc-748">Default font used for all text on buttons</span></span> |
| <span data-ttu-id="e6efc-749">GX_FONT_ID_TEXT_INPUT</span><span class="sxs-lookup"><span data-stu-id="e6efc-749">GX_FONT_ID_TEXT_INPUT</span></span> | <span data-ttu-id="e6efc-750">Metin düzenleme alanları için kullanılan varsayılan yazı tipi</span><span class="sxs-lookup"><span data-stu-id="e6efc-750">Default font used for text edit fields</span></span> |

<span data-ttu-id="e6efc-751">Herhangi bir metin türü pencere öğesi tarafından kullanılan yazı tipi KIMLIĞI, metin ile ilgili her pencere türü için belirtilen **gx_<widget_type>_font_set** API kullanılarak yeniden atanabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-751">The font ID used by any text type widget can be re-assigned by using the **gx_<widget_type>_font_set** API provided for each text-related widget type.</span></span> <span data-ttu-id="e6efc-752">Tüm yazı tipi tablosu **gx_display_font_table_set** API işlevi çağırarak yeniden atanabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-752">The entire font table can be re-assigned by calling the **gx_display_font_table_set** API function.</span></span>

### <a name="scrollbar-appearance"></a><span data-ttu-id="e6efc-753">Kaydırma çubuğu görünümü</span><span class="sxs-lookup"><span data-stu-id="e6efc-753">Scrollbar Appearance</span></span> 

<span data-ttu-id="e6efc-754">GUX ekranı Ayrıca bu görüntü için varsayılan kaydırma çubuğu görünüm ayarlarını korur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-754">GUIX Display also maintains default scrollbar appearance settings for that display.</span></span> <span data-ttu-id="e6efc-755">Bu ayarlar, aşağıda tanımlanan **GX_SCROLLBAR_APPEARANCE** yapısı tarafından tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-755">These settings are defined by the **GX_SCROLLBAR_APPEARANCE** structure which is defined below.</span></span> <span data-ttu-id="e6efc-756">GUX görünümü dikey kaydırma çubukları için bir ScrollBar görünümü ve yatay kaydırma çubuklarının ikinci yapısını tutar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-756">GUIX Display maintains one scrollbar appearance structure for vertical scrollbars and a second structure for horizontal scroll bars.</span></span> <span data-ttu-id="e6efc-757">Uygulama, bir **GX_SCROLLBAR_APPEARANCE** yapısını başlatarak ve apı işlevini ***gx_display_scroll_appearance_set*** çağırarak herhangi bir görüntü için varsayılan kaydırma çubuğu görünümünü değiştirebilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-757">The application can modify the default scrollbar appearance for any display by initializing a **GX_SCROLLBAR_APPEARANCE** structure and invoking the API function ***gx_display_scroll_appearance_set***.</span></span>

```c
typedef struct GX_SCROLLBAR_APPEARANCE_STRUCT
{
    GX_VALUE       gx_scroll_width;
    GX_VALUE       gx_scroll_thumb_width;
    GX_VALUE       gx_scroll_thumb_travel_min;
    GX_VALUE       gx_scroll_thumb_travel_max;
    GX_UBYTE       gx_scroll_thumb_border_style;
    GX_RESOURCE_ID gx_scroll_fill_pixelmap;
    GX_RESOURCE_ID gx_scroll_thumb_pixelmap;
    GX_RESOURCE_ID gx_scroll_up_pixelmap;
    GX_RESOURCE_ID gx_scroll_down_pixelmap;
    GX_RESOURCE_ID gx_scroll_thumb_color;
    GX_RESOURCE_ID gx_scroll_thumb_border_color;
    GX_RESOURCE_ID gx_scroll_button_color;
} GX_SCROLLBAR_APPEARANCE;
```
| <span data-ttu-id="e6efc-758">GX_SCROLLBAR_APPEARANCE yapısı üyesi</span><span class="sxs-lookup"><span data-stu-id="e6efc-758">GX_SCROLLBAR_APPEARANCE Structure Member</span></span> | <span data-ttu-id="e6efc-759">Açıklama</span><span class="sxs-lookup"><span data-stu-id="e6efc-759">Description</span></span> |
| --- | --- |
| <span data-ttu-id="e6efc-760">gx_scroll_width</span><span class="sxs-lookup"><span data-stu-id="e6efc-760">gx_scroll_width</span></span> | <span data-ttu-id="e6efc-761">Dikey kaydırma çubuğunun genişliği veya yatay kaydırma çubuğunun yüksekliği piksel cinsinden.</span><span class="sxs-lookup"><span data-stu-id="e6efc-761">Width of a vertical scrollbar or height of a horizontal scrollbar, in pixels.</span></span> |
| <span data-ttu-id="e6efc-762">gx_scroll_thumb_width</span><span class="sxs-lookup"><span data-stu-id="e6efc-762">gx_scroll_thumb_width</span></span> | <span data-ttu-id="e6efc-763">Asansör ve bitiş düğmelerinin piksel cinsinden genişliği.</span><span class="sxs-lookup"><span data-stu-id="e6efc-763">Width of the elevator and end buttons, in pixels.</span></span> |
| <span data-ttu-id="e6efc-764">gx_scroll_thumb_travel_max</span><span class="sxs-lookup"><span data-stu-id="e6efc-764">gx_scroll_thumb_travel_max</span></span> | <span data-ttu-id="e6efc-765">Kaydırma çubuğunun sonundan en fazla kaydırma düğmesi seyahat noktası arasındaki fark.</span><span class="sxs-lookup"><span data-stu-id="e6efc-765">Offset from the end of scroll bar to maximum thumb button travel point.</span></span> |
| <span data-ttu-id="e6efc-766">gx_scroll_fill_pixelmap</span><span class="sxs-lookup"><span data-stu-id="e6efc-766">gx_scroll_fill_pixelmap</span></span> | <span data-ttu-id="e6efc-767">Kaydırma arka planını doldurmanız için pixelmap kullanıldı.</span><span class="sxs-lookup"><span data-stu-id="e6efc-767">Pixelmap used to fill scroll background.</span></span> |
| <span data-ttu-id="e6efc-768">gx_scroll_thumb_pixelmap</span><span class="sxs-lookup"><span data-stu-id="e6efc-768">gx_scroll_thumb_pixelmap</span></span> | <span data-ttu-id="e6efc-769">Kaydırma parmak izi düğmesini çizmek için kullanılan pixelmap.</span><span class="sxs-lookup"><span data-stu-id="e6efc-769">Pixelmap used to draw scroll thumb button.</span></span> |
| <span data-ttu-id="e6efc-770">gx_scroll_up_pixelmap</span><span class="sxs-lookup"><span data-stu-id="e6efc-770">gx_scroll_up_pixelmap</span></span> | <span data-ttu-id="e6efc-771">Kaydırma düğmesini çizmek için kullanılan pixelmap.</span><span class="sxs-lookup"><span data-stu-id="e6efc-771">Pixelmap used to draw scroll up button.</span></span> |
| <span data-ttu-id="e6efc-772">gx_scroll_down_pixelmap</span><span class="sxs-lookup"><span data-stu-id="e6efc-772">gx_scroll_down_pixelmap</span></span> | <span data-ttu-id="e6efc-773">Kaydır aşağı kaydırma düğmesini çizmek için kullanılan pixelmap.</span><span class="sxs-lookup"><span data-stu-id="e6efc-773">Pixelmap used to draw scroll down button.</span></span> |
| <span data-ttu-id="e6efc-774">gx_scroll_fill_color</span><span class="sxs-lookup"><span data-stu-id="e6efc-774">gx_scroll_fill_color</span></span> | <span data-ttu-id="e6efc-775">Kaydırma çubuğu arka planını doldururken kullanılan rengin renk KIMLIĞI.</span><span class="sxs-lookup"><span data-stu-id="e6efc-775">Color ID of color used to fill scrollbar background.</span></span> |
| <span data-ttu-id="e6efc-776">gx_scroll_button_color</span><span class="sxs-lookup"><span data-stu-id="e6efc-776">gx_scroll_button_color</span></span> | <span data-ttu-id="e6efc-777">Kaydırma çubuğu düğmesini dolduracak şekilde kullanılan rengin renk KIMLIĞI.</span><span class="sxs-lookup"><span data-stu-id="e6efc-777">Color ID of color used to fill scrollbar thumb button.</span></span> |

<span data-ttu-id="e6efc-778">Yazı tipi, renk ve stiller için bu varsayılan ayarların yanı sıra, uygulama her bir pencere öğesi türü tarafından sağlanmış olan API 'YI kullanarak istediğiniz şekilde bir servis talebiyle ilgili parametrelerden herhangi birini belirtebilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-778">In addition to these default settings for fonts, color, and styles, the application may specify any of the parameters on a case by case basis as desired using API provided by each widget type.</span></span>

### <a name="skinning-and-themes"></a><span data-ttu-id="e6efc-779">Kaplama ve Temalar</span><span class="sxs-lookup"><span data-stu-id="e6efc-779">Skinning and Themes</span></span>

<span data-ttu-id="e6efc-780">Kaplama, GUıDX Pencere öğelerinin ve Windows 'un temel görünümlerini kolayca değiştirmesini sağlar, yani "Skin" ın tek bir yerde değiştirilmesi, ilişkili tüm pencere öğelerinin ve pencerelerin temel görünümünü değiştirir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-780">Skinning allows GUIX widgets and windows to easily change their base appearance, i.e., changing the “skin” in one place will change the base appearance of all associated widgets and windows.</span></span>

<span data-ttu-id="e6efc-781">GUX uygulamanızı yeniden kaplama için, GUıDX görüntüleme kaynak tablolarına yeni bir Color, font ve veya pixelmap tablosu sağlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-781">Re-skinning your GUIX application requires that you supply a new color, font and or pixelmap table to the GUIX Display resource tables.</span></span> <span data-ttu-id="e6efc-782">Tüm Gux pencere öğeleri, kaynak KIMLIĞINE göre rengine, bit eşlemlerine veya yazı tipine başvurduğundan, yeni bir kaynak tablosu sağlanması otomatik olarak tüm Gux Pencere öğelerinin, kendilerine istenen ekranda çizim yaparken yeni renklerinizi ve pixelmaps kullanmaya başlamasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-782">Since all GUIX widgets refer to their color, bitmap, or font by resource ID, providing a new resource table automatically causes all GUIX widgets to begin using your new colors and pixelmaps when they draw themselves to the desired display.</span></span>

<span data-ttu-id="e6efc-783">Etkileyici bir görünüm sağlamak için birlikte çalışmak üzere tasarlanan yeni bir yazı tipi, renk ve pixelmaps kümesi, *Tema* olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-783">A new set of fonts, colors, and pixelmaps that are designed to work together to provide an attractive appearance is called a *theme*.</span></span> <span data-ttu-id="e6efc-784">Bir tema, kaynak tablolarının bir kümesini ve her bir kaynak tablosunun boyutunu tanımlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-784">A theme defines a set of resource tables and the size of each resource table.</span></span> <span data-ttu-id="e6efc-785">Herhangi bir sayıda tema, GUıDX Studio uygulaması kullanılarak herhangi bir görüntü için tanımlanabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-785">Any number of themes can be defined for any display using the GUIX Studio application.</span></span> <span data-ttu-id="e6efc-786">Başlangıç teması dizinini, oluşturulan ekranda ilk temayı yükleyecek olan ***gx_studio_display_configure*** Gux Studio tarafından oluşturulan işleve geçirmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-786">You must pass the starting theme index to the GUIX Studio generated function ***gx_studio_display_configure***, which installs the initial theme into the created display.</span></span> <span data-ttu-id="e6efc-787">Herhangi bir ekran için etkin tema, ***gx_display_theme_install*** işlevi çağırarak herhangi bir zamanda değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-787">The active theme for any display can be changed at any time by calling the function ***gx_display_theme_install***.</span></span>

### <a name="root-window"></a><span data-ttu-id="e6efc-788">Kök pencere</span><span class="sxs-lookup"><span data-stu-id="e6efc-788">Root Window</span></span>

<span data-ttu-id="e6efc-789">Bir uygulama tarafından oluşturulan her görünebilir tuval için, uygulamanın Ayrıca bu tuval için bir kök pencere oluşturması gerekir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-789">For each visible canvas created by an application, the application must also create one Root Window for that canvas.</span></span> <span data-ttu-id="e6efc-790">Bu özel pencere, temel olarak tüm üst düzey uygulama pencereleri ve pencere öğeleri için bir kapsayıcı görevi görür.</span><span class="sxs-lookup"><span data-stu-id="e6efc-790">This special window basically acts as a container for all the top-level application windows and widgets.</span></span> <span data-ttu-id="e6efc-791">Kök pencere, tuval arka planını çizer ve kök pencere **GX_WINDOW** sınıftan türetildiğinden, kök pencerenin duvar kağıdı de olabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-791">The root window draws the canvas background, and since the root window is derived from the **GX_WINDOW** class the root window can also have wallpaper.</span></span> <span data-ttu-id="e6efc-792">Görüntü veya tuvaliniz arka plan rengini değiştirmek için, bu tuvale eklenmiş olan kök pencerenin Fill rengini değiştirmeniz yeterlidir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-792">To change the background color of your display or canvas, you simply change the fill color of the root window attached to that canvas.</span></span>

<span data-ttu-id="e6efc-793">Görüntülerinizi yapılandırmak için ***gx_studio_display_configure*** adlı Guıdx Studio generated işlevini kullanırsanız, bu başlatma işlevinin bir parçası olarak her bir ekran için tuval ve kök pencere oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-793">If you use the GUIX Studio generated function named ***gx_studio_display_configure*** to configure your displays, then the canvas and root window for each display are created for you as part of this initialization function.</span></span>

### <a name="anti-aliasing"></a><span data-ttu-id="e6efc-794">Kenar yumuşatma</span><span class="sxs-lookup"><span data-stu-id="e6efc-794">Anti-Aliasing</span></span> 

<span data-ttu-id="e6efc-795">Kenar yumuşatma, çizgileri, eğrileri ve yazı tiplerini düzgünleştirmek için kullanılan, GUıDX 'teki isteğe bağlı bir özelliktir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-795">Anti-Aliasing is an optional feature in GUIX that is used to smooth lines, curves, and fonts.</span></span> <span data-ttu-id="e6efc-796">Kenar yumuşatma yalnızca 16 BPP veya daha yüksek renk derinliğine sahip bir ekran sürücüsüyle çalışırken desteklenir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-796">Anti-aliasing is only supported when running with a display driver utilizing 16-bpp or higher color depth.</span></span>

<span data-ttu-id="e6efc-797">Etkin fırçayla **GX_BRUSH_ALIAS** flaş ayarlanarak, daha fazla diğer çizgi çizimi etkinleştirilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-797">Anti-aliased line drawing is enabled by setting the **GX_BRUSH_ALIAS** flash in the active brush.</span></span> <span data-ttu-id="e6efc-798">Bu, doğrudan çizilen çizgiler ve bir çokgen ya da dairenin kenarlığı olarak çizilen çizgiler için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-798">This applies to lines drawn directly as well as to lines drawn as the border of a polygon or circle.</span></span>

<span data-ttu-id="e6efc-799">Kenar yumuşatma uygulanmış metin çizimi, Gux Studio uygulaması tarafından üretilen, daha fazla ad olan bir yazı tipi kullanılarak etkinleştirilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-799">Anti-aliased text drawing is enabled by using an anti-aliased font which is produced by the GUIX studio application.</span></span> <span data-ttu-id="e6efc-800">Yazı tipini oluştururken bir yazı tipinin Antias veya binary olarak oluşturulup oluşturulmayacağını belirtirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e6efc-800">You specify whether a font should be generated as antialiased or binary when you create the font.</span></span>
<span data-ttu-id="e6efc-801">GUX 'teki kenar yumuşatma uygulanmış yazı tipleri her bir piksel için 16 düzeyde saydamlık kullanır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-801">Anti-aliased fonts in GUIX utilize 16 levels of transparency for each pixel.</span></span>

### <a name="clipping"></a><span data-ttu-id="e6efc-802">Kırpma</span><span class="sxs-lookup"><span data-stu-id="e6efc-802">Clipping</span></span> 

<span data-ttu-id="e6efc-803">Kırpma, Gux görüntüleme bileşeni tarafından dahili olarak ve pencere ve pencere öğesi katmanlarında Gux pencere öğeleri tarafından tutulan üst-alt mimarisine göre desteklenir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-803">Clipping is supported internally by the GUIX display component, and at the window and widget layers by the parent-child architecture maintained by GUIX widgets.</span></span> <span data-ttu-id="e6efc-804">Herhangi bir pencere veya pencere öğesinin, söz konusu pencere öğesinin alanının dışında çizim yapmasına izin verilmez ve bir pencere öğesinin, o pencere öğesinin üst alanının dışında hiçbir zaman çizilmesine izin verilmez.</span><span class="sxs-lookup"><span data-stu-id="e6efc-804">No window or widget is ever allowed to draw outside of that widget’s area, and a widget is never allowed to draw outside of the area of that widget’s parent.</span></span>

<span data-ttu-id="e6efc-805">Bu Ayrıca, pencere öğelerinin, büyük olasılıkla bellek bozulmasına veya bir sistem hatasına yol açabilecek tuval belleği dışına yerleşen piksel koordinatları çizmesini önler.</span><span class="sxs-lookup"><span data-stu-id="e6efc-805">This also prevents widgets from drawing at pixel coordinates that lay outside of the canvas memory which likely lead to memory corruption or a system failure.</span></span> <span data-ttu-id="e6efc-806">Pencere öğelerinin, pencere öğesinin alanının alanı, pencere öğesinin üst alanı veya tuval uzantısı dışında çizilmesine izin verilmez.</span><span class="sxs-lookup"><span data-stu-id="e6efc-806">Widgets are not allowed to draw outside of the widget’s area, the widget’s parent area, or beyond the canvas extent.</span></span>

<span data-ttu-id="e6efc-807">Ayrıca, pencere öğeleri yalnızca daha önce kirli olarak işaretlenmiş alanlara çizim yapabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-807">In addition, widgets can only draw to areas that have previously been marked as dirty.</span></span> <span data-ttu-id="e6efc-808">Bu, örneğin, pencerenin yalnızca bir köşesi gösterildiğinde tüm pencerenin çizilmesini önler.</span><span class="sxs-lookup"><span data-stu-id="e6efc-808">This prevents an entire window being drawn, for example, when only a corner of the window has been revealed.</span></span> <span data-ttu-id="e6efc-809">Yalnızca pencerenin yenilenmesi gereken kısmı kirli olarak işaretlenir ve bu nedenle pencere çizim işlevi yalnızca kirli alanındaki pikselleri gerçekten yeniler.</span><span class="sxs-lookup"><span data-stu-id="e6efc-809">Only the portion of the window that actually needs to be refreshed is marked as dirty, and so the window drawing function only truly refreshes pixels in the dirty area.</span></span>

<span data-ttu-id="e6efc-810">GUX görüntü bileşeni, sürücü düzeyi çizim işlevlerini çağırmadan önce bu kırpma algoritmalarını zorlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-810">The GUIX dispaly component enforces these clipping algorithms before invoking the driver level drawing functions.</span></span>

### <a name="views"></a><span data-ttu-id="e6efc-811">Görünümler</span><span class="sxs-lookup"><span data-stu-id="e6efc-811">Views</span></span> 

<span data-ttu-id="e6efc-812">GUX her bir kök pencere için bir görünüm kümesi ve kök penceresinin her bir alt penceresi için her zaman bir görünüm kümesi tutar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-812">GUIX always maintains a set of views for each root window and each child window of the root window.</span></span> <span data-ttu-id="e6efc-813">Görünümler, pencere konumu ve Z düzeni olarak değişen bir dinamik, çalışma zamanı belirlenmiş kırpma alanıdır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-813">Views are a dynamic, run-time determined clipping area that changes as window position and Z-order are modified.</span></span>
<span data-ttu-id="e6efc-814">GUIX, arka plandaki pencere veya pencere öğesinin ön planda bir pencere veya pencere öğesinin üzerine çizilmesini engellemek için görünümleri kullanır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-814">GUIX uses views to prevent a window or widget in the background from drawing on top of a window or widget in the foreground.</span></span> <span data-ttu-id="e6efc-815">Görünümler, Z sırası disiplini uygular.</span><span class="sxs-lookup"><span data-stu-id="e6efc-815">Views enforce Z-order discipline.</span></span> <span data-ttu-id="e6efc-816">Ayrıca, görünümler, arka plandaki bir pencerenin, çizmeyen tuvalin herhangi bir alanına çizilmesine engel olan verimlilik açısından önemlidir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-816">In addition, views are important for efficiency in that they prevent a window in the background from drawing to any area of the canvas that cannot be seen.</span></span> <span data-ttu-id="e6efc-817">Bir pencere başka bir pencereyle tamamen ele alınsa, kapsanan pencerenin, bu işlemi gerçekleştirmeye çalışıyor olsa bile, her seferinde tuvale çizilmesine izin verilmez.</span><span class="sxs-lookup"><span data-stu-id="e6efc-817">If a window is completely covered by another window, the covered window will not be allowed to draw to the canvas at all, even if it is attempting to do so.</span></span>

### <a name="display-driver-interface"></a><span data-ttu-id="e6efc-818">Sürücü arabirimini görüntüle</span><span class="sxs-lookup"><span data-stu-id="e6efc-818">Display Driver Interface</span></span> 

<span data-ttu-id="e6efc-819">GUX görüntüleme sürücüleri, temeldeki fiziksel ekranla tüm etkileşimlerden sorumludur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-819">GUIX display drivers are responsible for all interaction with the underlying physical screen.</span></span> <span data-ttu-id="e6efc-820">Görüntüleme sürücülerinde üç temel işlev vardır: başlatma, çizim ve çerçeve arabelleği görüntüleme.</span><span class="sxs-lookup"><span data-stu-id="e6efc-820">The display drivers have three basic functions: initialization, drawing, and frame buffer display.</span></span>
<span data-ttu-id="e6efc-821">Başlatma, fiziksel görüntü donanımının hazırlanmasından, fiziksel görüntü donanımının özelliklerinin bilgilendirilmesine ve belirli çizim işlevlerinin kullanılması gereken Gux 'e bildirmeden sorumludur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-821">Initialization is responsible for preparing the physical display hardware, informing GUIX of the properties of the physical display hardware, and for informing GUIX which specific drawing functions should be used.</span></span> <span data-ttu-id="e6efc-822">Ana görüntü sürücüsü başlatması Gux ***gx_display_create*** işlevinden çağrılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-822">The main display driver initialization is called from the GUIX ***gx_display_create*** function.</span></span> <span data-ttu-id="e6efc-823">Ayrıca, GUıDX iş parçacığı ayrıca iş parçacığı bağlamından ikincil bir görüntü sürücüsü başlatma işlemi çağırır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-823">In addition, the GUIX thread will also call a secondary display driver initialization from the thread context.</span></span> <span data-ttu-id="e6efc-824">Bu ikincil görüntü sürücüsü yalnızca, başlatma işlemi sırasında sürücü RTOS Hizmetleri gerektiriyorsa (örneğin, cihaz kesintileri veya başlatma işlemindeki adımlar arasında gecikme için istekler ***tx_thread_sleep*** ) gereklidir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-824">This secondary display driver is only needed if the driver requires RTOS services during its initialization, e.g., device interrupts or ***tx_thread_sleep*** requests for delay between steps in the initialization process.</span></span>

<span data-ttu-id="e6efc-825">Başlatma tamamlandıktan sonra, görüntü sürücüsü fiziksel görüntü donanımında yapılabilen herhangi bir doğrudan çizimden sorumludur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-825">Once initialization is complete, the display driver is responsible for any direct drawing that can be done in the physical display hardware.</span></span>
<span data-ttu-id="e6efc-826">Son olarak, görüntü sürücüsü çerçeve arabelleğinin görüntülenmesini sağlamaktan sorumludur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-826">Finally, the display driver is responsible for displaying the frame buffer.</span></span>

## <a name="guix-widget-component"></a><span data-ttu-id="e6efc-827">GUX pencere öğesi bileşeni</span><span class="sxs-lookup"><span data-stu-id="e6efc-827">GUIX Widget Component</span></span>

<span data-ttu-id="e6efc-828">Bir Gux pencere öğesi görünür bir grafik öğesidir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-828">A GUIX widget is a visible graphical element.</span></span> <span data-ttu-id="e6efc-829">Süreölçerler ve Math yardımcı program işlevleri gibi görünür olmayan Gux bileşenleri vardır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-829">There are GUIX components which are not visible, such as timers and math utility functions.</span></span>
<span data-ttu-id="e6efc-830">Ancak, tüm görünür bileşenler temel Gux pencere öğesi bileşeninden türetilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-830">However all visible components are derived from the basic GUIX widget component.</span></span> <span data-ttu-id="e6efc-831">Bir Gux pencere öğesi, GUıDX görüntüleme bloğunun birincil yapı taşıdır; diğer tüm grafik öğeleri temel pencere öğesi işlevlerinden türetilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-831">A GUIX widget is the primary building block of the GUIX display – all other graphic elements are derived from the base widget functionality.</span></span>

<span data-ttu-id="e6efc-832">GUX pencere öğeleri, devralmanın tam desteğiyle birlikte nesne yönelimli bir şekilde uygulanır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-832">GUIX widgets are implemented in an object oriented manner with full support of inheritance.</span></span> <span data-ttu-id="e6efc-833">Bu, mümkün olan en küçük bellek ve işleme gereksinimlerine neden olan ANSI C kullanılarak gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-833">This is accomplished using ANSI C, which results in the smallest possible memory and processing requirements.</span></span> <span data-ttu-id="e6efc-834">**GX_BUTTON** gibi belirli bir pencere öğesinin konuşduğumuz, temel **GX_WIDGET** gibi başka bir pencere *öğesinden türetilmekte* olduğu anlamı olan **GX_BUTTON** denetim yapısının, **GX_BUTTON** özgü bazı ek değişkenlerle birlikte **GX_WIDGET** tüm üye değişkenlerini ve işlev işaretçilerini içerdikleridir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-834">When we speak of one particular widget, such as **GX_BUTTON**, being *derived from* another widget, such as the base **GX_WIDGET**, what we mean is that the **GX_BUTTON** control structure contains all of the member variables and function pointers of **GX_WIDGET**, with some additional variables that are specific to **GX_BUTTON**.</span></span> <span data-ttu-id="e6efc-835">GUX, daha karmaşık Pencere öğelerinin her zaman daha basit bir pencere öğesine dayanmasını sağlamak üzere Pencere öğelerinin katmanlarını bu biçimde oluşturur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-835">GUIX builds up layers of widgets in this fashion, so that more complex widgets are always based on a simpler widget before them.</span></span> <span data-ttu-id="e6efc-836">Bu hiyerarşik model, pencere öğesi parametrelerini değiştirmek için kullanılan API 'Leri öğrenmenizi kolaylaştırır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-836">This hierarchical model of derivation makes it easier to learn the APIs used to modify widget parameters.</span></span> <span data-ttu-id="e6efc-837">Bir düğmenin rengini değiştirmek istiyorsanız, bir pencere öğesinin rengini değiştirmek için kullandığınız API 'yi kullanırsınız, yani ***gx_widget_fill_color_set***.</span><span class="sxs-lookup"><span data-stu-id="e6efc-837">If you want to modify the color of a button, you use the same API you use to modify the color of a widget, namely ***gx_widget_fill_color_set***.</span></span>

<span data-ttu-id="e6efc-838">Görünür pencere öğelerinin organizasyonu, alt pencere öğelerini üst öğeleri ile bağlayan ağaç yapılandırılmış listeler kullanılarak üst-alt öğe olarak korunur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-838">The organization of visible widgets is maintained in a parent-child manner using tree structured lists linking child widgets to their parents.</span></span> <span data-ttu-id="e6efc-839">Alt öğeler, çizdikleri görünümler ve çizdikleri tuvaller gibi üst öğelerinden Özellikler devralır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-839">The children inherit characteristics from their parents such as the views into which they can draw and the canvas on which they draw.</span></span>
<span data-ttu-id="e6efc-840">Alt pencere öğeleri kendi alt pencere öğeleri içerebilir ve üst öğeden çeşitli özellikleri devralabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-840">Child widgets may have their own child widgets, again inheriting various characteristics from the parent.</span></span> <span data-ttu-id="e6efc-841">Herhangi bir pencere öğesinin özellikleri, çeşitli GUıDX API çağrıları aracılığıyla açıkça yeniden tanımlanabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-841">The characteristics of any widget may be explicitly redefined via various GUIX API calls.</span></span>

### <a name="widget-creation"></a><span data-ttu-id="e6efc-842">Pencere öğesi oluşturma</span><span class="sxs-lookup"><span data-stu-id="e6efc-842">Widget Creation</span></span> 

<span data-ttu-id="e6efc-843">Pencere parçacıklarının yürütülmesi sırasında veya herhangi bir zamanda, bir pencere öğesi nesnesi oluşturulabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-843">A widget object can be created during initialization or anytime during the execution of application threads.</span></span> <span data-ttu-id="e6efc-844">Bir uygulama tarafından oluşturulabilen pencere öğesi nesnelerinin sayısında bir sınır yoktur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-844">There is no limit on the number of widget objects that can be created by an application.</span></span> <span data-ttu-id="e6efc-845">Ayrıca, hedef donanımınızın bellek sınırları içinde herhangi bir pencere öğesinin sahip olabileceği alt öğe sayısı için bir sınır yoktur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-845">There is also no limit on the number of children any widget may have, within the memory limits of your target hardware.</span></span>

<span data-ttu-id="e6efc-846">Her pencere öğesi türü, \***gx_button_create** _ veya _ *_gx_prompt_create_* \* gibi kendi oluşturma işlevine sahiptir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-846">Each widget type has its own create function, such as ***gx_button_create** _ or _*_gx_prompt_create_\*\*.</span></span> <span data-ttu-id="e6efc-847">Bu işlevlerin ilk üç parametresi her zaman aynıdır, yani pencere öğesi denetim yapısına yönelik bir işaretçi, pencere öğesi adına bir dize işaretçisi ve pencere öğesinin üst öğesi için bir işaretçi.</span><span class="sxs-lookup"><span data-stu-id="e6efc-847">The first three parameters to these functions are always the same, namely a pointer to the widget control structure, a string pointer to the widget name, and a pointer to the widget’s parent.</span></span> <span data-ttu-id="e6efc-848">Her oluşturma işlevi, söz konusu pencere öğesi türünün gereksinimlerine bağlı olarak herhangi bir sayıda ek parametreye sahip olabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-848">Each create function may have any number of additional parameters depending on the requirements of that particular widget type.</span></span>

### <a name="widget-control-block"></a><span data-ttu-id="e6efc-849">Pencere öğesi denetim bloğu</span><span class="sxs-lookup"><span data-stu-id="e6efc-849">Widget Control Block</span></span> 

<span data-ttu-id="e6efc-850">Her pencere öğesi nesnesinin özellikleri, denetim bloğunda **GX_WIDGET** bulunur ve **_gx_api. h_** içinde tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-850">The characteristics of each widget object are found in its control block **GX_WIDGET** and are defined in **_gx_api.h_**.</span></span> <span data-ttu-id="e6efc-851">Pencere öğesi nesnesi için gereken bellek, uygulama tarafından sağlanır ve bellekte herhangi bir yerde bulunabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-851">The memory required for a widget object is provided by the application and can be located anywhere in memory.</span></span> <span data-ttu-id="e6efc-852">Ancak, her bir işlevin kapsamı dışında tanımlayarak pencere öğesi nesne denetimi 'nin genel yapıyı engellemesini sağlamak en yaygın olarak kullanılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-852">However, it is most common to make the widget object control block a global structure by defining it outside the scope of any function.</span></span> <span data-ttu-id="e6efc-853">GUIX Studio kullanıyorsanız, pencere öğesi denetim bloklarınız, Studio tarafından oluşturulan belirtimlerinizin içinde statik olarak ayrılabilir veya uygulamanız tarafından dinamik olarak tahsis edilebilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-853">If you are using GUIX Studio, your widget control blocks can be statically allocated within your Studio generated specifications file, or they can be dynamically allocated by your application.</span></span>

### <a name="dynamic-widget-control-block-allocation-and-de-allocation"></a><span data-ttu-id="e6efc-854">Dinamik pencere öğesi denetim bloğu ayırma ve ayırmayı kaldırma</span><span class="sxs-lookup"><span data-stu-id="e6efc-854">Dynamic Widget Control Block Allocation and De-allocation</span></span> 

<span data-ttu-id="e6efc-855">Dinamik denetim bloğu ayırması kullanıyorsanız, GUIX 'in pencere öğesi Denetim bloklarında gereken belleği ayırmak ve serbest bırakmak için kullanacağı iki işlev tanımlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-855">If you are using dynamic control block allocation, you will need to define two functions that GUIX will use to allocate and free the memory required for your widget control blocks.</span></span> <span data-ttu-id="e6efc-856">Bellek yönetimi işlevleriniz, ***gx_system_memory_allocator_set*** API işlevi aracılığıyla Gux sistem bileşenine geçirilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-856">Your functions for memory management are passed to the GUIX system component via the ***gx_system_memory_allocator_set*** API function.</span></span> <span data-ttu-id="e6efc-857">Bu işlev, GUıDX 'e iki işlev işaretçisi geçirmenize olanak sağlar: ilki bir bellek ayırma işlevine yönelik bir işaretçidir ve ikincisi ise bellek boş işlevine yönelik bir işaretçidir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-857">This function allows you to pass two function pointers into GUIX: the first is a pointer to a memory allocation function, and the second is a pointer to a memory free function.</span></span> <span data-ttu-id="e6efc-858">Çoğu zaman, bu işlevleri ThreadX Byte havuzlarını kullanarak uygulayacaksınız, ancak Gux tasarımı, istediğiniz şekilde dinamik bellek yönetimi uygulamanıza olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-858">Most often, you will implement these functions using ThreadX byte pools, but the design of GUIX allows you to implement dynamic memory management in whatever way you prefer.</span></span>

<span data-ttu-id="e6efc-859">Dinamik pencere öğesi ayırma, Studio pencere öğesi özellikleri alanında "dinamik olarak ayrılmış" seçeneğini belirlediğinizde, genellikle Studio tarafından oluşturulan uygulama belirtimleri dosyası içinde kullanılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-859">Dynamic widget allocation is most often employed within your Studio generated application specifications file, when you select the “dynamically allocated” option in the Studio widget properties field.</span></span> <span data-ttu-id="e6efc-860">Ancak, uygulamanızda dinamik denetim bloğu ayırmayı de kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e6efc-860">However, you can also use dynamic control block allocation within your application.</span></span> <span data-ttu-id="e6efc-861">Uygulamanızda dinamik denetim bloğu ayırmayı kullanırsanız, pencere öğesi denetim bloğunu ayırmak için \***gx_widget_allocate** _ API işlevini çağırmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-861">If you use dynamic control block allocation within your application, you should invoke the \***gx_widget_allocate** _ API function to allocate the widget control block.</span></span> <span data-ttu-id="e6efc-862">Sonra, pencere öğesini oluşturduğunuzda, _ *GX_WIDGET_STYLE_DYNAMICALLY_ALLOCATED*\* stil bayrağını (diğer tüm gerekli stil bayraklarıyla birlikte) pencere öğesi oluşturma işlevine iletmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-862">Next, when you create the widget, make certain you pass the _ *GX_WIDGET_STYLE_DYNAMICALLY_ALLOCATED*\* style flag (along with any other needed style flags) to the widget create function.</span></span> <span data-ttu-id="e6efc-863">Bu bayrak pencere öğesi durum alanında dinamik olarak ayrıldığı pencere öğesini işaretlemek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-863">This flag is used to mark the widget as being dynamically allocated in the widget status field.</span></span> <span data-ttu-id="e6efc-864">Pencere öğesi daha sonra **_gx_widget_delete_** kullanılarak siliniyorsa, guıdx bu durum alanını denetler ve bellek sızıntıları olmadığından bellek ayırıcı işlevinizi otomatik olarak çağırır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-864">When and if the widget is later deleted using **_gx_widget_delete_**, GUIX will check this status field and automatically call your memory de-allocator function to insure there are no memory leaks.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="e6efc-865">Dinamik olarak ayrılan denetim bloğu kullanılarak oluşturulan bir pencere öğesinin bellek kaybını engellemek için **GX_WIDGET_STYLE_DYNAMICALLY_ALLOCATED** stili bayrağıyla oluşturulması gerekir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-865">A widget created using a dynamically allocated control block must be created with the **GX_WIDGET_STYLE_DYNAMICALLY_ALLOCATED** style flag to prevent memory loss.</span></span>

### <a name="types"></a><span data-ttu-id="e6efc-866">Türler</span><span class="sxs-lookup"><span data-stu-id="e6efc-866">Types</span></span>

<span data-ttu-id="e6efc-867">GUIX, yerleşik Pencere öğelerinin zengin ve tamamen işlevsel bir kümesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-867">GUIX provides a rich, fully functional set of built-in widgets.</span></span> <span data-ttu-id="e6efc-868">Daha önce belirtildiği gibi, tüm özelleşmiş pencere öğeleri temel pencere öğesi öğesinden türetilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-868">As mentioned previously, all specialized widgets are derived from the base widget.</span></span> <span data-ttu-id="e6efc-869">Aşağıda, GUıDX 'teki yerleşik Pencere öğelerinin listesi verilmiştir:</span><span class="sxs-lookup"><span data-stu-id="e6efc-869">Following is a list of the built-in widgets in GUIX:</span></span>

<span data-ttu-id="e6efc-870">**GX_TYPE_WIDGET**</span><span class="sxs-lookup"><span data-stu-id="e6efc-870">**GX_TYPE_WIDGET**</span></span>

<span data-ttu-id="e6efc-871">**GX_TYPE_BUTTON**</span><span class="sxs-lookup"><span data-stu-id="e6efc-871">**GX_TYPE_BUTTON**</span></span>

<span data-ttu-id="e6efc-872">**GX_TYPE_TEXT_BUTTON**</span><span class="sxs-lookup"><span data-stu-id="e6efc-872">**GX_TYPE_TEXT_BUTTON**</span></span>

<span data-ttu-id="e6efc-873">**GX_TYPE_MULTI_LINE_TEXT_BUTTON**</span><span class="sxs-lookup"><span data-stu-id="e6efc-873">**GX_TYPE_MULTI_LINE_TEXT_BUTTON**</span></span>

<span data-ttu-id="e6efc-874">**GX_TYPE_RADIO_BUTTON**</span><span class="sxs-lookup"><span data-stu-id="e6efc-874">**GX_TYPE_RADIO_BUTTON**</span></span>

<span data-ttu-id="e6efc-875">**GX_TYPE_CHECKBOX**</span><span class="sxs-lookup"><span data-stu-id="e6efc-875">**GX_TYPE_CHECKBOX**</span></span>

<span data-ttu-id="e6efc-876">**GX_TYPE_PIXELMAP_BUTTON**</span><span class="sxs-lookup"><span data-stu-id="e6efc-876">**GX_TYPE_PIXELMAP_BUTTON**</span></span>

<span data-ttu-id="e6efc-877">**GX_TYPE_ICON_BUTTON**</span><span class="sxs-lookup"><span data-stu-id="e6efc-877">**GX_TYPE_ICON_BUTTON**</span></span>

<span data-ttu-id="e6efc-878">**GX_TYPE_ICON**</span><span class="sxs-lookup"><span data-stu-id="e6efc-878">**GX_TYPE_ICON**</span></span>

<span data-ttu-id="e6efc-879">**GX_TYPE_SPRITE**</span><span class="sxs-lookup"><span data-stu-id="e6efc-879">**GX_TYPE_SPRITE**</span></span>

<span data-ttu-id="e6efc-880">**GX_TYPE_SLIDER**</span><span class="sxs-lookup"><span data-stu-id="e6efc-880">**GX_TYPE_SLIDER**</span></span>

<span data-ttu-id="e6efc-881">**GX_TYPE_PIXELMAP_SLIDER**</span><span class="sxs-lookup"><span data-stu-id="e6efc-881">**GX_TYPE_PIXELMAP_SLIDER**</span></span>

<span data-ttu-id="e6efc-882">**GX_TYPE_VERTICAL_SCROLL**</span><span class="sxs-lookup"><span data-stu-id="e6efc-882">**GX_TYPE_VERTICAL_SCROLL**</span></span>

<span data-ttu-id="e6efc-883">**GX_TYPE_HORIZONTAL_SCROLL**</span><span class="sxs-lookup"><span data-stu-id="e6efc-883">**GX_TYPE_HORIZONTAL_SCROLL**</span></span>

<span data-ttu-id="e6efc-884">**GX_TYPE_PROGRESS_BAR**</span><span class="sxs-lookup"><span data-stu-id="e6efc-884">**GX_TYPE_PROGRESS_BAR**</span></span>

<span data-ttu-id="e6efc-885">**GX_TYPE_PROMPT**</span><span class="sxs-lookup"><span data-stu-id="e6efc-885">**GX_TYPE_PROMPT**</span></span>

<span data-ttu-id="e6efc-886">**GX_TYPE_NUMERIC_PROMPT**</span><span class="sxs-lookup"><span data-stu-id="e6efc-886">**GX_TYPE_NUMERIC_PROMPT**</span></span>

<span data-ttu-id="e6efc-887">**GX_TYPE_PIXELMAP_PROMPT**</span><span class="sxs-lookup"><span data-stu-id="e6efc-887">**GX_TYPE_PIXELMAP_PROMPT**</span></span>

<span data-ttu-id="e6efc-888">**GX_TYPE_NUMERIC_PIXELMAP_PROMPT**</span><span class="sxs-lookup"><span data-stu-id="e6efc-888">**GX_TYPE_NUMERIC_PIXELMAP_PROMPT**</span></span>

<span data-ttu-id="e6efc-889">**GX_TYPE_SINGLE_LINE_TEXT_INPUT**</span><span class="sxs-lookup"><span data-stu-id="e6efc-889">**GX_TYPE_SINGLE_LINE_TEXT_INPUT**</span></span>

<span data-ttu-id="e6efc-890">**GX_TYPE_MULTI_LINE_TEXT_VIEW**</span><span class="sxs-lookup"><span data-stu-id="e6efc-890">**GX_TYPE_MULTI_LINE_TEXT_VIEW**</span></span>

<span data-ttu-id="e6efc-891">**GX_TYPE_MULTI_LINE_TEXT_INPUT**</span><span class="sxs-lookup"><span data-stu-id="e6efc-891">**GX_TYPE_MULTI_LINE_TEXT_INPUT**</span></span>

<span data-ttu-id="e6efc-892">**GX_TYPE_WINDOW**</span><span class="sxs-lookup"><span data-stu-id="e6efc-892">**GX_TYPE_WINDOW**</span></span>

<span data-ttu-id="e6efc-893">**GX_TYPE_ROOT_WINDOW**</span><span class="sxs-lookup"><span data-stu-id="e6efc-893">**GX_TYPE_ROOT_WINDOW**</span></span>

<span data-ttu-id="e6efc-894">**GX_TYPE_VERTICAL_LIST**</span><span class="sxs-lookup"><span data-stu-id="e6efc-894">**GX_TYPE_VERTICAL_LIST**</span></span>

<span data-ttu-id="e6efc-895">**GX_TYPE_HORIZONTAL_LIST**</span><span class="sxs-lookup"><span data-stu-id="e6efc-895">**GX_TYPE_HORIZONTAL_LIST**</span></span>

<span data-ttu-id="e6efc-896">**GX_TYPE_POPUP_LIST**</span><span class="sxs-lookup"><span data-stu-id="e6efc-896">**GX_TYPE_POPUP_LIST**</span></span>

<span data-ttu-id="e6efc-897">**GX_TYPE_DROP_LIST**</span><span class="sxs-lookup"><span data-stu-id="e6efc-897">**GX_TYPE_DROP_LIST**</span></span>

<span data-ttu-id="e6efc-898">**GX_TYPE_LINE_CHART**</span><span class="sxs-lookup"><span data-stu-id="e6efc-898">**GX_TYPE_LINE_CHART**</span></span>

<span data-ttu-id="e6efc-899">**GX_TYPE_DIALOG**</span><span class="sxs-lookup"><span data-stu-id="e6efc-899">**GX_TYPE_DIALOG**</span></span>

<span data-ttu-id="e6efc-900">**GX_TYPE_KEYBOARD**</span><span class="sxs-lookup"><span data-stu-id="e6efc-900">**GX_TYPE_KEYBOARD**</span></span>

<span data-ttu-id="e6efc-901">**GX_TYPE_SCROLL_WHEEL**</span><span class="sxs-lookup"><span data-stu-id="e6efc-901">**GX_TYPE_SCROLL_WHEEL**</span></span>

<span data-ttu-id="e6efc-902">**GX_TYPE_TEXT_SCROLL_WHEEL**</span><span class="sxs-lookup"><span data-stu-id="e6efc-902">**GX_TYPE_TEXT_SCROLL_WHEEL**</span></span>

<span data-ttu-id="e6efc-903">**GX_TYPE_STRING_SCROLL_WHEEL**</span><span class="sxs-lookup"><span data-stu-id="e6efc-903">**GX_TYPE_STRING_SCROLL_WHEEL**</span></span>

<span data-ttu-id="e6efc-904">**GX_TYPE_NUMERIC_SCROLL_WHEEL**</span><span class="sxs-lookup"><span data-stu-id="e6efc-904">**GX_TYPE_NUMERIC_SCROLL_WHEEL**</span></span>

<span data-ttu-id="e6efc-905">**GX_TYPE_CIRCULAR_GAUGE**</span><span class="sxs-lookup"><span data-stu-id="e6efc-905">**GX_TYPE_CIRCULAR_GAUGE**</span></span>

<span data-ttu-id="e6efc-906">**GX_TYPE_RADIAL_PROGRESS_BAR**</span><span class="sxs-lookup"><span data-stu-id="e6efc-906">**GX_TYPE_RADIAL_PROGRESS_BAR**</span></span>

<span data-ttu-id="e6efc-907">**GX_TYPE_RADIAL_SLIDER**</span><span class="sxs-lookup"><span data-stu-id="e6efc-907">**GX_TYPE_RADIAL_SLIDER**</span></span>

<span data-ttu-id="e6efc-908">**GX_TYPE_MENU_LIST**</span><span class="sxs-lookup"><span data-stu-id="e6efc-908">**GX_TYPE_MENU_LIST**</span></span>

<span data-ttu-id="e6efc-909">**GX_TYPE_MENU**</span><span class="sxs-lookup"><span data-stu-id="e6efc-909">**GX_TYPE_MENU**</span></span>

<span data-ttu-id="e6efc-910">**GX_TYPE_ACCORDION_MENU**</span><span class="sxs-lookup"><span data-stu-id="e6efc-910">**GX_TYPE_ACCORDION_MENU**</span></span>

<span data-ttu-id="e6efc-911">**GX_TYPE_TREE_VIEW**</span><span class="sxs-lookup"><span data-stu-id="e6efc-911">**GX_TYPE_TREE_VIEW**</span></span>


### <a name="styles"></a><span data-ttu-id="e6efc-912">Stiller</span><span class="sxs-lookup"><span data-stu-id="e6efc-912">Styles</span></span>

<span data-ttu-id="e6efc-913">Pencere öğesi stilleri, daha önce listelendiği gibi belirli pencere öğesi türlerinin özelliklerini ve kenarlık özellikleri (yükseltilen, recessed, ince, kalın veya hiç Boarder) gibi işlemlerden oluşur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-913">Widget styles consist of things like border properties (raised, recessed, thin, thick, or no boarder at all) as well as properties for specific widget types, as listed previously.</span></span> <span data-ttu-id="e6efc-914">Pencere öğesi stil bayrakları, herhangi bir pencere öğesinin görünümünü değiştirmek için en basit yöntemi sunar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-914">The widget style flags offer the simplest method for modifying the appearance of any widget.</span></span>
<span data-ttu-id="e6efc-915">İlk pencere öğesi stili her zaman pencere öğesi türüne özgü oluşturma işlevine geçirilen bir parametredir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-915">The initial widget style is always a parameter passed to the widget type specific create function.</span></span>

### <a name="colors"></a><span data-ttu-id="e6efc-916">Renkler</span><span class="sxs-lookup"><span data-stu-id="e6efc-916">Colors</span></span> 

<span data-ttu-id="e6efc-917">Pencere öğeleri, sistem renk tablosunda tanımlanan renkleri kullanarak kendilerini çizer.</span><span class="sxs-lookup"><span data-stu-id="e6efc-917">Widgets draw themselves using colors defined in the system color table.</span></span>
<span data-ttu-id="e6efc-918">Renk kimlikleri, tuval arka planı, varsayılan pencere öğesi dolgusu rengi, düğme dolgusu rengi, metin pencere öğesi dolgusu rengi, pencere dolgusu rengi ve diğer birçok varsayılan renk değeri için tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-918">Color IDs are defined for canvas background, default widget fill color, button fill color, text widget fill color, window fill color, and several other default color values.</span></span> <span data-ttu-id="e6efc-919">Ayrıca, **GX_WINDOW** nesneler, pencere istemcisi doldurulduğundan bir bit eşlem veya duvar kağıdı görüntülemeyi destekler.</span><span class="sxs-lookup"><span data-stu-id="e6efc-919">In addition, **GX_WINDOW** objects support displaying a bitmap or wallpaper as the window client is filled.</span></span>

<span data-ttu-id="e6efc-920">Varsayılan renk şemasını değiştirmenin en basit yöntemi, Gux Studio 'Yu kullanmaktır ve gereksinimlerinizi karşılayan bir renk şeması oluşturur veya tanımlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-920">The simplest method of changing the default color scheme is to use GUIX Studio and create or define a color scheme that meets your requirements.</span></span>
<span data-ttu-id="e6efc-921">Ayrıca, GX_COLOR değerler dizisi oluşturarak ve gx_system_color_table_set API işlevini çağırarak renk düzeninizi el ile tanımlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e6efc-921">You can also define your color scheme manually by creating an array of GX_COLOR values and invoking the gx_system_color_table_set API function.</span></span>

### <a name="event-notification"></a><span data-ttu-id="e6efc-922">Olay bildirimi</span><span class="sxs-lookup"><span data-stu-id="e6efc-922">Event Notification</span></span> 

<span data-ttu-id="e6efc-923">GUX olayları, Kullanıcı girişi ve iç sistem durumu değişikliklerinin pencere öğelerini bilgilendirmek için bir veya daha fazla pencere öğesine yapılan isteklerdir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-923">GUIX events are requests made to one or more widgets to perform a particular action and notifications to notify widgets of user input and internal system status changes.</span></span> <span data-ttu-id="e6efc-924">Örneğin, bir pencere öğesi odağı aldığında, **GX_EVENT_FOCUS_GAINED** pencere öğesine ***gx_system_event_send*** API hizmeti aracılığıyla gönderilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-924">For example, when a widget gains focus, the **GX_EVENT_FOCUS_GAINED** is sent to the widget via the ***gx_system_event_send*** API service.</span></span>

<span data-ttu-id="e6efc-925">Olaylar Gux olay sırasından geçirilir ve her olay **GX_EVENT** veri yapısının bir örneğidir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-925">Events are passed through the GUIX event queue, and each event is an instance of the **GX_EVENT** data structure.</span></span> <span data-ttu-id="e6efc-926">**GX_EVENT** veri yapısı ***gx_api. h*** içinde tanımlanmıştır, ancak yapının en önemli alanları **gx_event_type**, **gx_event_sender**, **gx_event_target** ve **gx_event_payload**.</span><span class="sxs-lookup"><span data-stu-id="e6efc-926">The **GX_EVENT** data structure is defined in ***gx_api.h***, however the most important fields of the structure are the **gx_event_type**, **gx_event_sender**, **gx_event_target**, and **gx_event_payload**.</span></span>

<span data-ttu-id="e6efc-927">**Gx_event_type** alanı, belirli olay sınıfını tanımlamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-927">The **gx_event_type** field is used to identify the particular event class.</span></span> <span data-ttu-id="e6efc-928">Olay türü, örneğin **GX_EVENT_PEN_DOWN** bir olay veya **GX_EVENT_TIMER** bir olay olduğunu gösterir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-928">The event type indicates if this is, for example, a **GX_EVENT_PEN_DOWN** event or a **GX_EVENT_TIMER** event.</span></span> <span data-ttu-id="e6efc-929">**Gx_event_payload** çeşitli veri alanlarının bir birleşimidir ve hepsi her olay türü için geçerli değildir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-929">The **gx_event_payload** is a union of various data fields, and they are not all valid for every event type.</span></span>
<span data-ttu-id="e6efc-930">Diğer olay verileri alanlarını incelemeden önce olay türü alanını kullanın.</span><span class="sxs-lookup"><span data-stu-id="e6efc-930">You use the event type field first, before examining the other event data fields.</span></span>

<span data-ttu-id="e6efc-931">**Gx_event_sender** alanı, olay bir alt pencere öğesi bildirimidir olayı oluşturan pencere öğesinin kimliğini içerir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-931">The **gx_event_sender** field contains the ID of the widget that generated the event if the event is a child-widget notification.</span></span>

<span data-ttu-id="e6efc-932">**Gx_event_target** alanı, Kullanıcı tanımlı olayları belirli bir pencere veya pencere öğesine yönlendirmek için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-932">The **gx_event_target** field can be used to route user-defined events to a particular window or widget.</span></span> <span data-ttu-id="e6efc-933">Belirli bir pencereye bir olay göndermek istiyorsanız, pencereye benzersiz bir kimlik değeri (pozitif olarak tanımlanabilmesi için) vermeniz ve olay oluşturulurken **gx_event_target** alanına pencere kimliği değeri yerleştirmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-933">If you want to send an event to a particular window, you should give the window a unique Id value (so that it can be positively identified), and when building the event place the window Id value in the **gx_event_target** field.</span></span> <span data-ttu-id="e6efc-934">Hedef kimliği bilmiyorsanız veya olayın yalnızca giriş odaklı bir pencere öğesine yönlendirilmesini istiyorsanız, **gx_event_target** alanını 0 olarak ayarladığınızdan emin olun.</span><span class="sxs-lookup"><span data-stu-id="e6efc-934">If you don’t know the target Id or if you just want the event to be routed to the widget that has input focus, make sure to set the **gx_event_target** field to 0.</span></span>

<span data-ttu-id="e6efc-935">Son olarak, **gx_event_payload** alanı çeşitli veri türlerinin bir birleşimidir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-935">Finally, the **gx_event_payload** field is a union of various data types.</span></span> <span data-ttu-id="e6efc-936">**GX_EVENT_PEN_DOWN** ve **GX_EVENT_PEN_UP** olaylar için **gx_event_pointdata** alanı, kalemin konumunu koordine eden x, y pikseli içerir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-936">For **GX_EVENT_PEN_DOWN** and **GX_EVENT_PEN_UP** events, the **gx_event_pointdata** field contains the x,y pixel coordinate the pen position.</span></span> <span data-ttu-id="e6efc-937">Zamanlayıcı olayları için **gx_event_timer_id** alanı, süre dolma SÜREÖLÇERININ kimliğini içerir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-937">For timer events, the **gx_event_timer_id** field contains the ID of the expired timer.</span></span> <span data-ttu-id="e6efc-938">Diğer yük verisi alanları diğer olay türleri için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-938">Other payload data fields are utilized for other event types.</span></span> <span data-ttu-id="e6efc-939">Önceden tanımlanmış olay türlerinin tam listesi ve yük alanları [ek E-Gux olay açıklamalarında](appendix-e.md)tanımlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-939">The complete list of pre-defined event types and their payload fields is defined in [Appendix E - GUIX Event Descriptions](appendix-e.md).</span></span>

<span data-ttu-id="e6efc-940">Uygulama, sabit **GX_FIRST_APP_EVENT** sonra sayısal olarak başlayacak şekilde kendi özel olaylarını da ekleyebilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-940">The application can also add its own custom events, starting numerically after the constant **GX_FIRST_APP_EVENT**.</span></span> <span data-ttu-id="e6efc-941">Bu sabitten sonraki tüm olay numaraları, uygulamanın kullanımı için ayrılmıştır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-941">All event numbers after this constant are reserved for the application’s use.</span></span> <span data-ttu-id="e6efc-942">Kuşkusuz, uygulamanın pencere öğesi olay işleyicisinin bu tür uygulama olayları için işlenmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-942">Of course, the application’s widget event handler must have processing for such application events.</span></span>

### <a name="event-processing"></a><span data-ttu-id="e6efc-943">Olay Işleme</span><span class="sxs-lookup"><span data-stu-id="e6efc-943">Event Processing</span></span> 

<span data-ttu-id="e6efc-944">Her ve her pencere öğesi için varsayılan pencere öğesi olay işleme işlevi vardır; ***gx_<pencere öğesi türü>_event_process***.</span><span class="sxs-lookup"><span data-stu-id="e6efc-944">There is a default widget event processing function for each and every widget, named ***gx_<widget-type>_event_process***.</span></span> <span data-ttu-id="e6efc-945">Çoğu durumda, uygulamanın herhangi bir söz konusu pencere öğesinin olay işlemesi hakkında endişelenmek zorunda kalmaz.</span><span class="sxs-lookup"><span data-stu-id="e6efc-945">In most cases, the application won’t need to worry about the event handling of any given widget.</span></span> <span data-ttu-id="e6efc-946">Ancak, uygulamanın özel veya ek olay işleme gerektirdiği durumlarda, uygulama varsayılan işleme işlevini Gux API ***gx_widget_event_process_set*** aracılığıyla kendi kendine geçersiz kılabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-946">However, in situations where the application requires custom or supplemental event processing, the application may override the default processing function with its own via the GUIX API ***gx_widget_event_process_set***.</span></span> <span data-ttu-id="e6efc-947">Bu işlev, API 'de belirtilen olay işlevi işleme işlevi ile varsayılan olay işleme işlevini geçersiz kılar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-947">This function overrides the default event processing function with the event function processing function specified in the API.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="e6efc-948">Uygulama olay işleme işlevleri yalnızca varsayılan ***gx_widget_event_process*** işlemesini doğrudan çağırarak varsayılan işlemenin avantajlarından yararlanabilir (yani, işleme çoğaltma değil).</span><span class="sxs-lookup"><span data-stu-id="e6efc-948">Application event processing functions can take advantage (i.e., not duplicate the processing) of the default processing by simply calling the default ***gx_widget_event_process*** processing directly.</span></span>

<span data-ttu-id="e6efc-949">Olay işleme yalnızca iç Gux sistem iş parçacığı bağlamından çağrılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-949">Event processing is called exclusively from the context of the internal GUIX system thread.</span></span> <span data-ttu-id="e6efc-950">Bu şekilde, olay işlemesini işlemek için yığın gereksinimleri yalnızca Gux iş parçacığı için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-950">In this way, the stack requirements to process the event handling only applies to the GUIX thread.</span></span>

### <a name="implementing-custom-event-processing-example"></a><span data-ttu-id="e6efc-951">Özel olay Işleme uygulama (örnek)</span><span class="sxs-lookup"><span data-stu-id="e6efc-951">Implementing Custom Event Processing (example)</span></span> 

<span data-ttu-id="e6efc-952">GUX sisteminde herhangi bir pencere öğesi veya pencere için kendi olay işleme işlevinizi sağlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e6efc-952">You can provide your own event processing function for any widget or window in the GUIX system.</span></span> <span data-ttu-id="e6efc-953">Kendi özel pencere öğesi türünü oluşturuyorsanız, normalde özel olay işleyicinizi pencere öğesi oluşturma işlevine yüklersiniz.</span><span class="sxs-lookup"><span data-stu-id="e6efc-953">If you are creating your own custom widget type, you will normally install your custom event handler in the widget creation function.</span></span> <span data-ttu-id="e6efc-954">Yalnızca var olan bir pencere öğesinin veya pencerenin işlemini genişletmeniz veya değiştiriyorsanız, pencere öğesi veya pencere oluşturulduktan sonra gx_widget_event_process_set API işlevini çağırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e6efc-954">If you are just extending or modifying the operation of an existing widget or window, you can call the gx_widget_event_process_set API function after the widget or window has been created.</span></span> <span data-ttu-id="e6efc-955">Alt denetimleriniz tarafından oluşturulan olayları işlemek için, en üst düzey pencereler (ekranlar da denir) için neredeyse her zaman kendi olay işleme sağlarsınız.</span><span class="sxs-lookup"><span data-stu-id="e6efc-955">You will almost always provide your own event handling for your top-level windows (also called Screens) in order to process events generated by your child controls.</span></span> <span data-ttu-id="e6efc-956">Ekranın alt denetimleri tarafından oluşturulan işleme olayı, Gux uygulamanıza işlevsellik eklemenin ana yöntemidir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-956">Processing event generated by the child controls of a screen is the main way you add functionality to your GUIX application.</span></span>

<span data-ttu-id="e6efc-957">Örnek olarak, "main_menu" adlı bir üst düzey ekran tanımladığınızı varsayalım.</span><span class="sxs-lookup"><span data-stu-id="e6efc-957">As an example, suppose you define a top-level screen named “main_menu”.</span></span>
<span data-ttu-id="e6efc-958">Bu ekran, GUıDX Studio kullanılarak tanımlanabilir veya bu ekranı uygulama kodunuzda oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e6efc-958">This screen might be defined using GUIX Studio, or you might create this screen in your application code.</span></span> <span data-ttu-id="e6efc-959">Ekranı Gux Studio içinde tanımlarsanız, bu ekran için Studio özellikleri alanına olay işleyicinizin adını yazmanız yeterlidir ve Studio tarafından oluşturulan belirtim kodu olay işleyicinizi otomatik olarak yükler.</span><span class="sxs-lookup"><span data-stu-id="e6efc-959">If you define the screen within GUIX Studio, you simply type the name of your event handler in the Studio properties field for that screen, and the Studio generated specifications code will automatically install your event handler.</span></span> <span data-ttu-id="e6efc-960">Bu durumda, özel olay işleyicisi ***main_menu_event_handler*** çağıracağız ve aşağıdaki gibi kodlanmış olmalıdır:</span><span class="sxs-lookup"><span data-stu-id="e6efc-960">In this case, we will call the custom event handler ***main_menu_event_handler*** and it should be coded like this:</span></span>

```C
int main_menu_item; /* example: variable to keep track of selected item */

UINT main_menu_event_handler(GX_WINDOW *main_screen, GX_EVENT *event_ptr)
{
    UINT status = GX_SUCCESS;

    switch(event_ptr->gx_event_type)
    {
    /* this is an example for catching events from a child button */
    case GX_SIGNAL(IDB_CHILD_BUTTON, GX_EVENT_CLICKED):
        /* insert your button handler code here */
        break;

    case GX_EVENT_SHOW:
        /* add functionality to the show event handler */
        /* first, do default processing */
        status = gx_window_event_process(main_screen, event_ptr); /* note 1 */

        /* now add my own processing */
        main_menu_item = 0;
        break;

    default:
        /* pass all other events to base processing function */
        status = gx_window_event_process(main_screen, event_ptr); /* note 1 */
        break;
    }
    return status;
}
```

<span data-ttu-id="e6efc-961">Yukarıdaki örnekte, **GX_EVENT_SHOW** gibi sistem olayları (bir durum değişikliğinin bir pencere öğesine bildirmek için dahili olarak oluşturulan olaylar) hakkında fark edilmesi önemlidir. uygulamanın, normal işlemenin meydana geldiğinden emin olmak için bu olayları temel pencere öğesi olay işleme işlevine iletmesinin gerekir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-961">In the example above, it is important to notice that for system events like **GX_EVENT_SHOW** (events generated internally to notify a widget of a status change), the application must pass those events to the base widget event processing function to insure that the normal processing occurs.</span></span> <span data-ttu-id="e6efc-962">Uygulama daha sonra istediğiniz gibi ek mantık ekleyebilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-962">The application can then add additional logic as desired.</span></span> <span data-ttu-id="e6efc-963">Uygulama tarafından işlenmemiş olan tüm olaylar (yukarıdaki varsayılan durum) Ayrıca temel olay işleme işlevine geçirilmelidir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-963">All events that are not handled by the application (the default case above) should also be passed to the base event processing function.</span></span> <span data-ttu-id="e6efc-964">Bu örnek **GX_WINDOW** tabanlı en üst düzey bir ekran olduğundan, varsayılan olay işleme işlevi gx_window_event_process.</span><span class="sxs-lookup"><span data-stu-id="e6efc-964">Since this example was for a top-level screen based on **GX_WINDOW**, the default event processing function is gx_window_event_process.</span></span>

### <a name="drawing-function"></a><span data-ttu-id="e6efc-965">Çizim Işlevi</span><span class="sxs-lookup"><span data-stu-id="e6efc-965">Drawing Function</span></span> 

<span data-ttu-id="e6efc-966">Tüm pencere öğesi çizimi olay işlemesinden ayrı olarak gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-966">All widget drawing is performed separately from the event handling.</span></span> <span data-ttu-id="e6efc-967">Bu daha verimlidir çünkü çizim genellikle CPU döngüleri bakımından pahalıdır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-967">This is more efficient because drawing is usually expensive in terms of CPU cycles.</span></span> <span data-ttu-id="e6efc-968">Ertelenmiş bir çizim algoritması uygulayarak, tüm bekleyen olaylar ve ilgili ekran değişiklikleri, herhangi bir çizim yapılmadan önce tamamlanabilir ve bu nedenle, boşa harcanan bir çizim yapılamaz.</span><span class="sxs-lookup"><span data-stu-id="e6efc-968">By implementing a deferred drawing algorithm, all of the outstanding events and associated display changes can be completed before any drawing is done, thus eliminating wasted drawing.</span></span> <span data-ttu-id="e6efc-969">Olay işlemeye benzer şekilde, ***gx_<pencere öğesi türü>_draw*** adında, her pencere öğesi için varsayılan bir pencere öğesi çizim işlevi vardır; burada XXX pencere öğesi türüdür.</span><span class="sxs-lookup"><span data-stu-id="e6efc-969">Similar to event processing, there is a default widget drawing function for most widgets, named ***gx_<widget-type>_draw***, where xxx is the widget type.</span></span> <span data-ttu-id="e6efc-970">Çoğu durumda, uygulamanın herhangi bir söz konusu pencere öğesinin çizim işleviyle uğraşmak zorunda kalmaz.</span><span class="sxs-lookup"><span data-stu-id="e6efc-970">In most cases, the application won’t need to worry about the drawing function of any given widget.</span></span> <span data-ttu-id="e6efc-971">Ancak, uygulamanın özel veya ek çizim gerektiren durumlarda, uygulama varsayılan çizim işlevini Gux API ***gx_widget_draw_set*** aracılığıyla kendi kendine geçersiz kılabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-971">However, in situations where the application requires custom or supplemental drawing, the application may override the default drawing function with its own via the GUIX API ***gx_widget_draw_set***.</span></span> <span data-ttu-id="e6efc-972">Bu işlev, uygulamanın herhangi bir pencere öğesi için kendi özelleştirilmiş çizim işlevini sağlamasına izin verir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-972">This function allows the application to provide its own customized drawing function for any widget.</span></span> <span data-ttu-id="e6efc-973">Bu, uygulamanın tüm yeni pencere öğesi türlerini tanımlamasına olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-973">This further allows the application to define entire new widget types.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="e6efc-974">Uygulama çizim işlevleri, doğrudan geçersiz kılınan çizim işlevinden çağırarak, varsayılan çizimin avantajlarından yararlanabilir (yani, kodlama yinelememez).</span><span class="sxs-lookup"><span data-stu-id="e6efc-974">Application drawing functions can take advantage (i.e., not duplicate the coding) of the default drawing by simply calling it directly from the overridden drawing function.</span></span>

<span data-ttu-id="e6efc-975">Pencere öğesi çizimi, iç Gux sistem iş parçacığı bağlamından özel olarak çağırılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-975">Widget drawing is called exclusively from the context of the internal GUIX system thread.</span></span> <span data-ttu-id="e6efc-976">Bu şekilde, çizimi gerçekleştirmeye yönelik zamanlama ve yığın gereksinimleri yalnızca Gux iş parçacığı için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-976">In this way, the timing and stack requirements to perform the drawing only apply to the GUIX thread.</span></span>

### <a name="implementing-custom-drawing-example"></a><span data-ttu-id="e6efc-977">Özel çizim uygulama (örnek)</span><span class="sxs-lookup"><span data-stu-id="e6efc-977">Implementing Custom Drawing (example)</span></span> 

<span data-ttu-id="e6efc-978">Herhangi bir pencere öğesinin çizim işlevine, GX_WIDGET denetim bloğunun üyesi olan bir dolaylı işlev işaretçisi aracılığıyla başvurulur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-978">The drawing function for any widget is referenced through an indirect function pointer which is a member of the GX_WIDGET control block.</span></span> <span data-ttu-id="e6efc-979">Pencere öğesini tanımlamak için Gux Studio kullanırsanız, yalnızca işlevinizin adını pencere öğesi özelliklerinin "çizim Işlevi" parametresine yazarak kendi işlev işaretçinizi yükleyebilirsiniz ve Studio, pencere öğesi oluşturulduğunda işlev işaretçinizi sizin için yükler.</span><span class="sxs-lookup"><span data-stu-id="e6efc-979">If you use GUIX Studio to define your widget, you can install your own function pointer simply by typing the name of your function in the “Drawing Function” parameter of the widget properties, and Studio will install your function pointer for you when the widget is created.</span></span> <span data-ttu-id="e6efc-980">Uygulama kodunuzda pencere öğesini oluşturursanız, pencere öğesi oluşturulduktan sonra özel çizim işlevinizi yüklemek için ***gx_widget_draw_set*** API işlevini kullanmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-980">If you create the widget in your application code, you must use the ***gx_widget_draw_set*** API function to install your custom drawing function after the widget has been created.</span></span>

<span data-ttu-id="e6efc-981">Bu örnekte, bir düğmenin görünümünü özelleştirmek istediğinizi varsayalım.</span><span class="sxs-lookup"><span data-stu-id="e6efc-981">For this example, let’s assume that you want to customize the appearance of a button.</span></span> <span data-ttu-id="e6efc-982">Düğme, bir **GX_TEXT_BUTTON** benzer şekilde görünecektir, ancak düğmeye basıldığında düğmenin sağ orta kısmına küçük bir yeşil "LED_ON" bit eşlem ekler ve düğmeye basıldığında küçük "LED_OFF" bit eşlemi ekleyeceğiz.</span><span class="sxs-lookup"><span data-stu-id="e6efc-982">The button will look very much like a **GX_TEXT_BUTTON**, but we will add drawing a small green “LED_ON” bitmap in the middle-right portion of the button when the button is pressed, and small “LED_OFF” bitmap when the button is not pressed.</span></span> <span data-ttu-id="e6efc-983">Aşağıdaki çizimler gibi görünen bir düğme oluşturmak istiyoruz.</span><span class="sxs-lookup"><span data-stu-id="e6efc-983">We want to create a button that looks like the illustrations below.</span></span>

![Açık için yeşil düğmenin ekran görüntüsü.](./media/guix/image4.jpg) <span data-ttu-id="e6efc-985">özel düğme "açık"</span><span class="sxs-lookup"><span data-stu-id="e6efc-985">custom button “on”</span></span>

![Kapalı kırmızı düğmesinin ekran görüntüsü.](./media/guix/image5.jpg) <span data-ttu-id="e6efc-987">özel düğme "kapalı"</span><span class="sxs-lookup"><span data-stu-id="e6efc-987">custom button “off”</span></span>

<span data-ttu-id="e6efc-988">Bu durumda, aşağıdakine benzer bir düğme çizim işlevi yazacağız.</span><span class="sxs-lookup"><span data-stu-id="e6efc-988">In this case, we would write a button drawing function that looks something like the following.</span></span>

```C
UINT my_button_draw(GX_TEXT_BUTTON *button)
{
    GX_PIXELMAP *map;
    ULONG button_style;
    INT xpos;
    INT ypos;

    /* first, do the normal text button drawing */
    gx_text_button_draw(button);

    /* now add our extra pixelmap */

    gx_widget_style_get(button, &button_style);

    if (button_style & GX_STYLE_BUTTON_PUSHED)
    {
        /* use the ON pixelmap */
        gx_context_pixelmap_get(GX_PIXELMAP_ID_LED_ON, &map);
    }
    else
    {
        /* use the OFF pixelmap */
        gx_context_pixelmap_get(GX_PIXELMAP_ID_LED_OFF, &map);
    }
    if (map)
    {
        /* draw it 20 pixels in from right edge */
        xpos = button->gx_widget_size.gx_rectangle_right;
        xpos -= map->gx_pixelmap_width + 20;

        /* and draw 10 pixels from the top edge */
        ypos = button->gx_widget_size.gx_rectangle_top + 10;

        /* draw the extra pixelmap on top of the button */
        gx_canvas_pixelmap_draw(xpos, ypos, map);
    }
}
```

## <a name="guix-drawing-context-component"></a><span data-ttu-id="e6efc-989">GUX çizim bağlamı bileşeni</span><span class="sxs-lookup"><span data-stu-id="e6efc-989">GUIX Drawing Context Component</span></span> 

<span data-ttu-id="e6efc-990">Çizim bağlamı, çalışma zamanında dinamik olarak oluşturulur ve Gux, her tuval yenileme işlemini gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-990">The drawing context is created dynamically, at runtime, as GUIX performs each canvas refresh operation.</span></span> <span data-ttu-id="e6efc-991">Çizim bağlamı, geçerli çizim işlemlerini gerçekleştirmek için kullanılan tuvali, ekran sürücüsünü ve fırçayı birlikte kullanır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-991">The drawing context ties together the canvas, screen driver, and brush being used to perform the current drawing operations.</span></span>

<span data-ttu-id="e6efc-992">Çizim bağlamı **GX_DRAW_CONTEXT** yapısı tarafından tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-992">The drawing context is defined by the **GX_DRAW_CONTEXT** structure.</span></span>
<span data-ttu-id="e6efc-993">Bu yapı, geçerli çizim işleminin kırpılmasını ve görünümünü tanımlayan değişkenleri içerir, geçerli tuvali tanımlar ve kullanımda olan geçerli ekran sürücüsünü tanımlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-993">This structure contains variables that define the clipping and view of the current drawing operation, define the current canvas, and define the current screen driver in use.</span></span> <span data-ttu-id="e6efc-994">**GX_DRAW_CONTEXT** yapısı, çizim için kullanılan fırçayı de barındırır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-994">The **GX_DRAW_CONTEXT** structure also holds the brush being used for drawing.</span></span> <span data-ttu-id="e6efc-995">Çiz bağlam fırçası, doğrudan özel çizim işlevleriniz içinde çalışeceğiniz üyesidir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-995">The draw context brush is the member that you will work directly with in your custom drawing functions.</span></span> <span data-ttu-id="e6efc-996">Fırça yapısı aşağıdaki kodda gösterildiği gibi tanımlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-996">The brush structure is defined as shown in the code below.</span></span>

```C
typedef struct GX_BRUSH_STRUCT
{
    GX_PIXELMAP *gx_brush_pixelmap;
    GX_FONT     *gx_brush_font;
    ULONG        gx_brush_line_pattern;
    ULONG        gx_brush_pattern_mask;
    GX_COLOR     gx_brush_fill_color;  
    GX_COLOR     gx_brush_line_color;  
    UINT         gx_brush_style;
    GX_VALUE     gx_brush_width;
    UCHAR        gx_brush_alpha;  
} GX_BRUSH;
```

<span data-ttu-id="e6efc-997">**Gx_brush_pixelmap** alanı, dikdörtgen ve çokgen dolguları için kullanılacak bir pixelmap tanımlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-997">The **gx_brush_pixelmap** field defines a pixelmap to use for rectangle and polygon fills.</span></span> <span data-ttu-id="e6efc-998">**Gx_brush_style** , **GX_BRUSH_PIXELMAP** stilini içermiyorsa, bu üye kullanılmaz.</span><span class="sxs-lookup"><span data-stu-id="e6efc-998">This member is not used unless the **gx_brush_style** is includes the **GX_BRUSH_PIXELMAP** style.</span></span>

<span data-ttu-id="e6efc-999">**Gx_brush_font** üyesi metin çiziminde kullanılan yazı tipini tanımlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-999">The **gx_brush_font** member defines the font used for text drawing.</span></span>
<span data-ttu-id="e6efc-1000">**Gx_brush_line_pattern** üyesi, kesikli çizgiler için kullanılan kalıbı tanımlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1000">The **gx_brush_line_pattern** member defines the pattern used for dashed lines.</span></span>
<span data-ttu-id="e6efc-1001">**Gx_brush_style** üyesi, fırça özniteliklerini tamamen tanımlamak için bır arada veya ile birlikte olabilecek bir stil bayrakları kümesidir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1001">The **gx_brush_style** member is a set of style flags that can be OR’d together to fully define the brush attributes.</span></span> <span data-ttu-id="e6efc-1002">Kullanılabilir fırça stili bayrakları aşağıdakileri içerir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1002">The available brush style flags include the following.</span></span>

<span data-ttu-id="e6efc-1003">**GX_BRUSH_OUTLINE**</span><span class="sxs-lookup"><span data-stu-id="e6efc-1003">**GX_BRUSH_OUTLINE**</span></span>  
<span data-ttu-id="e6efc-1004">**GX_BRUSH_SOLID_FILL**</span><span class="sxs-lookup"><span data-stu-id="e6efc-1004">**GX_BRUSH_SOLID_FILL**</span></span>  
<span data-ttu-id="e6efc-1005">**GX_BRUSH_PIXELMAP_FILL**</span><span class="sxs-lookup"><span data-stu-id="e6efc-1005">**GX_BRUSH_PIXELMAP_FILL**</span></span>  
<span data-ttu-id="e6efc-1006">**GX_BRUSH_ALIAS**</span><span class="sxs-lookup"><span data-stu-id="e6efc-1006">**GX_BRUSH_ALIAS**</span></span>  
<span data-ttu-id="e6efc-1007">**GX_BRUSH_UNDERLINE**</span><span class="sxs-lookup"><span data-stu-id="e6efc-1007">**GX_BRUSH_UNDERLINE**</span></span>  
<span data-ttu-id="e6efc-1008">**GX_BRUSH_ROUND**</span><span class="sxs-lookup"><span data-stu-id="e6efc-1008">**GX_BRUSH_ROUND**</span></span>

<span data-ttu-id="e6efc-1009">**Gx_brush_width** üyesi çizgi çizimi için satırı veya özetlenen şekil çiziminin ana hat genişliğini tanımlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1009">The **gx_brush_width** member defines the line with for line drawing, or the outline width for outlined shape drawing.</span></span>

<span data-ttu-id="e6efc-1010">**Gx_brush_line_color** üyesi, çizgi çiziminin ve metin çiziminin ön plan rengini tanımlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1010">The **gx_brush_line_color** member defines the foreground color for line drawing and for text drawing.</span></span>

<span data-ttu-id="e6efc-1011">**Gx_brush_fill_color** üyesi, şekil doldurma için kullanılan düz doldurma rengini tanımlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1011">The **gx_brush_fill_color** member defines the solid fill color used for shape filling.</span></span> <span data-ttu-id="e6efc-1012">GUX bağlam bileşeni, etkin bağlam içindeki geçerli fırçayı değiştirmek çok kolay hale getirmek için tasarlanan bir API kümesi sağlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1012">The GUIX context component provides a set of APIs designed to make it very easy to modify the current brush within the active context.</span></span> <span data-ttu-id="e6efc-1013">Bu API 'Ler **gx_context_brush_define**, **gx_context_line_color_set**, **gx_context_fill_color_set**, **gx_context_font_set** ve diğer birçok tane içerir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1013">These APIs include **gx_context_brush_define**, **gx_context_line_color_set**, **gx_context_fill_color_set**, **gx_context_font_set**, and many others.</span></span>

<span data-ttu-id="e6efc-1014">Üst nesnenin çizim bağlamı nesneler alt öğesi tarafından devralınır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1014">The draw context of a parent object is inherited by the objects children.</span></span> <span data-ttu-id="e6efc-1015">Aslında, ana çizim bağlamının bir kopyası, çizim işlevleri çağrıldığında alt nesneler tarafından devralınır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1015">Actually, a clone of the parent drawing context is inherited by the child objects when their drawing functions are invoked.</span></span> <span data-ttu-id="e6efc-1016">Alt öğe, üst çizimi etkilemeden bağlamı değiştirebilir, ancak isterseniz fırça rengi ve stili gibi üst öğeden bilgileri de miras alabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1016">The child can modify the context without affecting the parent drawing, but it can also inherit information from the parent such as brush color and style if desired.</span></span>

## <a name="guix-window-component"></a><span data-ttu-id="e6efc-1017">GUX pencere bileşeni</span><span class="sxs-lookup"><span data-stu-id="e6efc-1017">GUIX Window Component</span></span> 

<span data-ttu-id="e6efc-1018">Pencere bileşeni, Gux 'teki tüm pencere işlemeden sorumludur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1018">The window component is responsible for all window processing in GUIX.</span></span> <span data-ttu-id="e6efc-1019">Bir Gux penceresi, bir veya daha fazla alt pencere öğesi içerebilen ayrı bir görüntüleme alanıdır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1019">A GUIX window is fundamentally a distinct display area that may contain one or more child widgets.</span></span> <span data-ttu-id="e6efc-1020">GUX 'te, pencere aslında yalnızca temel pencere öğesi nesnesinin özel bir biçimidir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1020">In GUIX, the window is actually just a special form of the fundamental widget object.</span></span>

<span data-ttu-id="e6efc-1021">GUX pencereleri, devralmanın tam desteğiyle birlikte nesne yönelimli bir şekilde uygulanır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1021">GUIX windows are implemented in an object oriented manner with full support of inheritance.</span></span> <span data-ttu-id="e6efc-1022">Bu, mümkün olan en küçük bellek ve işleme gereksinimlerine neden olan ANSI C kullanılarak gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1022">This is accomplished using ANSI C, which results in the smallest possible memory and processing requirements.</span></span>

<span data-ttu-id="e6efc-1023">GUX Windows, yatay ve dikey kaydırma desteği ekleyerek Gux pencere öğesinin işlevselliğini esas olarak genişletir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1023">GUIX windows extend the functionality of the GUIX widget primarily by adding support for horizontal and vertical scrolling.</span></span> <span data-ttu-id="e6efc-1024">GUX pencere nesneleri otomatik olarak, kaydırma çubukları oluşturup görüntüleyebilir ve kaydırma çubuğu girişine yanıt verebilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1024">GUIX window objects can automatically create and display scroll bars and respond to scroll bar input.</span></span> <span data-ttu-id="e6efc-1025">Taşınabilir pencereler Ayrıca pencerenin kalem girişi olaylarına göre taşınmasına veya sürüklenip bırakılmasına izin vermek için yerleşik olay işleme de sahiptir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1025">Movable windows also have built in event handling to allow the window to be moved or dragged based on pen input events.</span></span>
<span data-ttu-id="e6efc-1026">Son olarak, Gux penceresi, pencereyi pencerenin Z düzeninin önüne taşıyarak giriş odağını almaya yanıt verir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1026">Finally, GUIX window responds to receiving input focus by moving the window to the front of the window Z-order.</span></span>

<span data-ttu-id="e6efc-1027">GUX penceresi, Pencere kenarlıkları ve kaydırma çubukları gibi istemci olmayan nesneler kullanılabilir alandan kaldırıldığında pencerenin iç bölümü olan *istemci alanı* kavramını korur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1027">GUIX window maintains the concept of *client area*, which is the inner portion of the window once the window borders and non-client objects such as scrollbars are removed from the available area.</span></span> <span data-ttu-id="e6efc-1028">İstemci alanı alt öğeleri pencere istemci alanına kırpılıp, kaydırma çubukları gibi istemci olmayan alt öğelerin, istemci alanının dışında çizim yapmasına izin verilir, ancak hala pencerenin dış boyutlarına kırpılmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1028">Client area child widgets are clipped to the window client area, while non-client children such as scroll bars are allowed to draw outside of the client area, but are still clipped to the window outer dimensions.</span></span>

<span data-ttu-id="e6efc-1029">Pencereler bir üst-alt biçimde tutulur ve bu, alt öğelerin özellikleri üst öğelerinden devraldığı yerdir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1029">Windows are maintained in a parent-child manner, where the children inherit characteristics from their parent.</span></span> <span data-ttu-id="e6efc-1030">Alt Windows 'un kendi alt pencereleri olabilir, bu da üst öğeden çeşitli özellikleri devralabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1030">Children windows may have their own child windows, again inheriting various characteristics from the parent.</span></span> <span data-ttu-id="e6efc-1031">Herhangi bir pencerenin özellikleri, çeşitli GUıDX API çağrıları aracılığıyla açıkça yeniden tanımlanabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1031">The characteristics of any window may be explicitly redefined via various GUIX API calls.</span></span>

### <a name="window-creation"></a><span data-ttu-id="e6efc-1032">Pencere oluşturma</span><span class="sxs-lookup"><span data-stu-id="e6efc-1032">Window Creation</span></span> 

<span data-ttu-id="e6efc-1033">Başlatma sırasında veya uygulama iş parçacıklarının yürütülmesi sırasında her zaman bir pencere nesnesi oluşturulabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1033">A window object can be created during initialization or anytime during the execution of application threads.</span></span> <span data-ttu-id="e6efc-1034">Bir uygulama tarafından oluşturulabilen pencere nesnelerinin sayısında bir sınır yoktur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1034">There is no limit on the number of window objects that can be created by an application.</span></span> <span data-ttu-id="e6efc-1035">Ayrıca herhangi bir pencerenin sahip olabileceği alt öğe sayısı için bir sınır yoktur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1035">There is also no limit on the number of children any window may have.</span></span>

### <a name="window-control-block"></a><span data-ttu-id="e6efc-1036">Pencere denetim bloğu</span><span class="sxs-lookup"><span data-stu-id="e6efc-1036">Window Control Block</span></span> 

<span data-ttu-id="e6efc-1037">Her pencere nesnesinin özellikleri, denetim bloğunda **GX_WINDOW** bulunur ve **_gx_api. h_** içinde tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1037">The characteristics of each window object are found in its control block **GX_WINDOW** and are defined in **_gx_api.h_**.</span></span> <span data-ttu-id="e6efc-1038">Bir pencere nesnesi için gereken bellek, uygulama tarafından sağlanır ve belleğin herhangi bir yerinden bulunabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1038">The memory required for a window object is provided by the application and can be located anywhere in memory.</span></span> <span data-ttu-id="e6efc-1039">Ancak, herhangi bir işlevin kapsamı dışında tanımlayarak pencere nesne denetimi 'nin genel yapıyı engellemesini sağlamak en yaygın olarak kullanılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1039">However, it is most common to make the window object control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="root-window"></a><span data-ttu-id="e6efc-1040">Kök pencere</span><span class="sxs-lookup"><span data-stu-id="e6efc-1040">Root Window</span></span> 

<span data-ttu-id="e6efc-1041">GUX, her tuval için kök pencere olarak adlandırılan bir değer gerektirir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1041">GUIX requires what is called a root window for each canvas.</span></span> <span data-ttu-id="e6efc-1042">Kök pencere Kenarlıksız ve eklendiği tuvalle aynı boyutlara sahiptir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1042">The root window is borderless and has the same dimensions as the canvas to which it is attached.</span></span> <span data-ttu-id="e6efc-1043">Birincil olarak ilk düzey pencere öğeleri ve pencereler için bir kapsayıcı olarak kullanılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1043">It is used primarily as a container for all first-level widgets and windows.</span></span> <span data-ttu-id="e6efc-1044">Kök pencere, genellikle ekran ve tuval oluşturulduktan sonra ***GX_WINDOW_ROOT_CREATE*** API işlevi aracılığıyla uygulama tarafından oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1044">The root window is typically created by the application via the API function ***gx_window_root_create***, shortly after the creation of the screen and canvas.</span></span> <span data-ttu-id="e6efc-1045">Studio tarafından oluşturulan işlevi gx_studio_display_configure kullanırsanız, kök pencerenin adresi bu işleve son parametre olarak geçirilen konumda döndürülebilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1045">If you use the Studio generated function gx_studio_display_configure, the address of the root window can be returned in the location passed as the last parameter to this function.</span></span>

<span data-ttu-id="e6efc-1046">Kök pencere, varsayılan olarak taşınamayacak ve en basit durumda kök pencere tuvalin boyutudur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1046">A root window defaults to being un-moveable, and in the simplest case the root window is the size of the canvas.</span></span> <span data-ttu-id="e6efc-1047">Etkin kök pencere, ekran arka planını çizer, bu nedenle ekran arka plan rengini değiştirmek veya arka plan duvar kağıdını göstermek için kök pencereye bir renk veya duvar kağıdı atamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1047">The root window in effect draws the display background, so to change the display background color or to display background wallpaper you would assign a color or wallpaper to the root window.</span></span>

<span data-ttu-id="e6efc-1048">Bir kök pencere taşınabilir ise, alt pencere yaptığı, ancak tuvalin kendisini hareket ettirerek tuval üzerinde konumunu değiştirerek bu, hareket etmez.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1048">If a root window is moveable, it moves not by changing its position on the canvas as a child window would do, but by moving the canvas itself.</span></span>
<span data-ttu-id="e6efc-1049">Bu özellik, Gux kök penceresinin, donanım fark kayıtları olan birden çok çerçeve arabelleğini destekleyen donanımdan yararlanmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1049">This feature allows the GUIX root window to leverage hardware that supports multiple frame buffers with hardware offset registers.</span></span>

### <a name="background"></a><span data-ttu-id="e6efc-1050">Arka Plan</span><span class="sxs-lookup"><span data-stu-id="e6efc-1050">Background</span></span> 

<span data-ttu-id="e6efc-1051">Pencere arka planları düz renkler veya bit eşlem görüntüleridir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1051">Window backgrounds are either solid colors or bitmap images.</span></span> <span data-ttu-id="e6efc-1052">Sistem düzeyinde, ilk Windows kümesi için varsayılan değer sağlayan bir pencere arka planı vardır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1052">There is a default window background at the system level which provides the default for the initial set of windows.</span></span> <span data-ttu-id="e6efc-1053">Kuşkusuz, tüm pencere arka planı Gux API 'SI aracılığıyla değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1053">Of course, any window background can be changed via the GUIX API.</span></span>

<span data-ttu-id="e6efc-1054">Pencerenin düz renk arka planını değiştirmek için ***gx_widget_fill_color_set*** API 'sini kullanın.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1054">To change the solid color background of a window, use the ***gx_widget_fill_color_set*** API.</span></span> <span data-ttu-id="e6efc-1055">Bir pencereye arka plan duvar kağıdı atamak için ***gx_window_wallpaper_set*** API 'sini kullanın.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1055">To assign a background wallpaper to a window, use the ***gx_window_wallpaper_set*** API.</span></span>

### <a name="scrolling"></a><span data-ttu-id="e6efc-1056">Kaydırma</span><span class="sxs-lookup"><span data-stu-id="e6efc-1056">Scrolling</span></span> 

<span data-ttu-id="e6efc-1057">Window alt öğelerini göstermek için gereken alan, pencerenin geçerli boyutunu (yatay ve/veya dikey olarak aşarsa), GUıDX standart pencere kaydırmayı destekler.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1057">GUIX supports standard window scrolling when area required to display the window children exceeds the current size of the window – horizontally and/or vertically.</span></span> <span data-ttu-id="e6efc-1058">Kaydırmayı etkinleştirmek için uygulama, istenen kaydırma çubuklarını oluşturmalı ve pencereye iliştirmelidir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1058">To enable scrolling, the application must create the desired scroll bars and attach them to the window.</span></span>

<span data-ttu-id="e6efc-1059">GUX pencere bileşeni, pencere istemci alanının boyutunu ve tüm alt pencere öğelerinin kapsamını temel alan varsayılan bir kayan uygulama sağlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1059">The GUIX window component provides a default scrolling implementation based on the size of the window client area and the extent of the all child widgets.</span></span> <span data-ttu-id="e6efc-1060">Uygulamalar, belirli bir pencerenin ***gx_window_scroll_info_get*** işlevini geçersiz kılarak kendi kaydırma uygulaması ve yorumlamasını de sağlayabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1060">Applications can also provide their own scrolling implementation and interpretation by overriding the ***gx_window_scroll_info_get*** function for a particular window.</span></span>

### <a name="event-notification"></a><span data-ttu-id="e6efc-1061">Olay bildirimi</span><span class="sxs-lookup"><span data-stu-id="e6efc-1061">Event Notification</span></span> 

<span data-ttu-id="e6efc-1062">Varsayılan pencere olay işleme işlevi, birincil olarak kaydırma ve boyutlandırma olaylarının işlendiği GX_WIDGET olay işlemeden farklıdır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1062">The default window event processing function differs from the GX_WIDGET event processing primarily in the handling of scrolling and sizing events.</span></span> <span data-ttu-id="e6efc-1063">GX_WINDOW, kaydırma ve boyutlandırma olayları için defalt işleyicileri sağladı.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1063">GX_WINDOW provided defalt handlers for scrolling and sizing events.</span></span>

<span data-ttu-id="e6efc-1064">Uygulama, sabit **GX_FIRST_APP_EVENT** sonra sayısal olarak başlayacak şekilde kendi özel olaylarını da ekleyebilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1064">The application can also add its own custom events, starting numerically after the constant **GX_FIRST_APP_EVENT**.</span></span> <span data-ttu-id="e6efc-1065">Bu sabitten sonraki tüm olay numaraları, uygulamanın kullanımı için ayrılmıştır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1065">All event numbers after this constant are reserved for the application’s use.</span></span> <span data-ttu-id="e6efc-1066">Kuşkusuz, uygulamanın pencere olay işleyicisinin bu tür uygulama olayları için işleme sahip olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1066">Of course, the application’s window event handler must have processing for such application events.</span></span>

### <a name="event-processing"></a><span data-ttu-id="e6efc-1067">Olay Işleme</span><span class="sxs-lookup"><span data-stu-id="e6efc-1067">Event Processing</span></span> 

<span data-ttu-id="e6efc-1068">Diğer tüm pencere öğesi türlerinde olduğu gibi, ***gx_window_event_process*** adlı her pencere için varsayılan bir pencere olay işleme işlevi vardır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1068">Just like all other widget types, there is a default window event processing function for every window, named ***gx_window_event_process***.</span></span> <span data-ttu-id="e6efc-1069">Bu olay işleme işlevini genellikle oluşturduğunuz Windows 'da kendi olay işleyiciniz ile geçersiz kılacaksınız.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1069">You will usually override this event handling function with your own event handler in the windows that you create.</span></span> <span data-ttu-id="e6efc-1070">Bu, olaylara yanıt vermek ve pencere alt denetimleri tarafından oluşturulan olaylara göre işlem yapmak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1070">This is how you will respond to events and take action based on events generated by the window child controls.</span></span>

<span data-ttu-id="e6efc-1071">Bu olay işleyicisini geçersiz kıldıysanız, varsayılan olay işlemenin olay işleyicisine eklediğiniz herhangi bir eyleme ek olarak oluşmasına izin vermek için, bu olay işleyicisini geçersiz kıldıysanız, GUıDX sistem olayları için temel ***gx_window_event_process*** işlevinin çağrılmasını unutmamak önemlidir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1071">It is important to remember to invoke the base ***gx_window_event_process*** function for GUIX system events if you override that event handler, to allow the default event handling to occur in addition to whatever action you are adding to the event handler.</span></span> <span data-ttu-id="e6efc-1072">Örneğin, **GX_EVENT_SHOW** olayı için özel bir işleyici sağlar ve bu olayı ***gx_window_event_process*** olarak iletmezseniz, pencereniz hiçbir şekilde görünmez olmaz.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1072">For example if you provide a custom handler for the **GX_EVENT_SHOW** event, and do not pass this event to ***gx_window_event_process***, your window will never become visible.</span></span>
<span data-ttu-id="e6efc-1073">Bir pencere için özel bir olay işleyicisi sağlamak üzere, olay işleyicinizin adresini tanımlamak için ***gx_widget_event_process_set*** işlevini kullanın.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1073">To provide a custom event handler for a window, use the ***gx_widget_event_process_set*** function to define the address of your event handler.</span></span> <span data-ttu-id="e6efc-1074">Bu işlev, API 'de belirtilen olay işlevi işleme işlevi ile varsayılan olay işleme işlevini geçersiz kılar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1074">This function overrides the default event processing function with the event function processing function specified in the API.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="e6efc-1075">Uygulama olay işleme işlevleri yalnızca varsayılan ***gx_window_event_process*** doğrudan çağırarak varsayılan işlemenin avantajlarından yararlanabilir (yani, işleme uygulanmaz).</span><span class="sxs-lookup"><span data-stu-id="e6efc-1075">Application event processing functions can take advantage (i.e., not duplicate the processing) of the default processing by simply calling the default ***gx_window_event_process*** directly.</span></span>

<span data-ttu-id="e6efc-1076">Olay işleme yalnızca iç Gux sistem iş parçacığı bağlamından çağrılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1076">Event processing is called exclusively from the context of the internal GUIX system thread.</span></span> <span data-ttu-id="e6efc-1077">Bu şekilde, olay işlemesini işlemek için yığın gereksinimleri yalnızca Gux iş parçacığı için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1077">In this way, the stack requirements to process the event handling only applies to the GUIX thread.</span></span>

## <a name="guix-image-reader-component"></a><span data-ttu-id="e6efc-1078">GUX görüntü okuyucu bileşeni</span><span class="sxs-lookup"><span data-stu-id="e6efc-1078">GUIX Image Reader Component</span></span> 

<span data-ttu-id="e6efc-1079">Görüntü okuyucu bileşeni, sıkıştırılmış ham sıkıştırılmış görüntüleri GUıDX pixelmap biçimine kadar açmak için yardımcı programları ve API işlevlerini sağlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1079">The image reader component provides utilities and API functions to decompress raw compressed images to GUIX pixelmap format.</span></span> <span data-ttu-id="e6efc-1080">JPEG ve PNG biçimli Ham görüntü verileri, gelecek sürümler için ayrılmış ek biçimler ile desteklenir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1080">JPEG and PNG format raw image data are supported, with additional formats reserved for future releases.</span></span>

<span data-ttu-id="e6efc-1081">GUX uygulamalarının büyük çoğunluğu için Gux görüntü okuyucu bileşeni gerekli değildir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1081">Note that for the vast majority of GUIX applications, the GUIX Image Reader component is not required.</span></span> <span data-ttu-id="e6efc-1082">Çoğu uygulama, JPEG ve PNG formatı grafik varlıklarını Gux uyumlu **GX_PIXELMAP** kaynaklarına dönüştürmek için Gux Studio uygulamasını kullanır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1082">Most applications rely on the GUIX Studio application to convert JPEG and PNG format graphics assets into GUIX compatible **GX_PIXELMAP** resources.</span></span> <span data-ttu-id="e6efc-1083">GUX görüntü okuyucu bileşeni, ham grafik varlıkları yalnızca çalışma zamanında bilindiğinde veya sistem depolama kısıtlamaları kaynakların **GX_PIXELMAP** biçimde depolanmasını engelliyorsa kullanılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1083">The GUIX image reader component is utilized when the raw graphics assets are known only at runtime, or when the system storage constraints prevent storing resources in **GX_PIXELMAP** format.</span></span> <span data-ttu-id="e6efc-1084">JPEG ve PNG biçimli resim verileri genellikle **GX_PIXELMAP** biçiminden daha küçüktür. ancak, bu görüntü türlerini dinamik olarak açma ve renk alanı dönüştürme işlemlerini gerçekleştirmeyle ilişkili önemli çalışma zamanı ek yükü vardır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1084">JPEG and PNG format image data is generally more compact than **GX_PIXELMAP** format, however there is considerable runtime overhead associated with performing decompression and color space conversion of these image types dynamically.</span></span>

<span data-ttu-id="e6efc-1085">Ham biçim JPEG veya PNG görüntüleri gx_canvas_pixelmap_draw API işlevine geçirilirse, GUıDX dinamik olarak JPEG veya PNG verilerini açar ve çizer.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1085">If raw format JPEG or PNG images are passed to the gx_canvas_pixelmap_draw API function, GUIX dynamically decompresses and draws the JPEG or PNG data.</span></span> <span data-ttu-id="e6efc-1086">Bu, çalışma zamanı çizim hızında önemli bir olumsuz etkiye sahip olacağını ve ham biçim görüntü verilerinin gx_canvas_pixelmap_draw işlevine geçirilmesini, donanım yardımlı JPEG veya PNG 'yi açmayı destekleyen bir donanım hedefi kullanmadığınız durumlar önerilmez.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1086">Note that this will have a significant negative impact on runtime drawing speed, and passing RAW format image data to the gx_canvas_pixelmap_draw function is not recommended unless you are using a hardware target that supports hardware assisted JPEG or PNG decompression.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="e6efc-1087">Ham JPEG veya PNG biçimli görüntülerin gx_canvas_pixelmap_draw API 'sine geçirilmesi, çoğu hedef donanım için önemli çalışma zamanı ek yüküne neden olur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1087">Passing raw JPEG or PNG formatted images to the gx_canvas_pixelmap_draw API incurs significant runtime overhead for most target hardware.</span></span>

<span data-ttu-id="e6efc-1088">Alternatif olarak, ham JPEG ve PNG verileri, görüntü okuyucu bileşeni kullanılarak çalışma zamanında GX_PIXELMAP biçime dönüştürülebilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1088">As an alternative, raw JPEG and PNG data may be converted to GX_PIXELMAP format at runtime using the Image Reader component.</span></span>
<span data-ttu-id="e6efc-1089">Bu şekilde üretilen pixelmaps, tıpkı Studio tarafından üretilen ve kaynak dosyanızda bulunan pixelmaps gibi kullanılabilir ve çizilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1089">Pixelmaps produced in this way can be used and drawn just like pixelmaps produced by Studio and contained within your resource file.</span></span> <span data-ttu-id="e6efc-1090">Bu, uygulamanızın görüntü her çizildiğinde bu işlemleri gerçekleştirmek yerine bir kez (genellikle program başlangıcında) görüntü açma, titreme ve renk alanı dönüştürme işlemini gerçekleştirmesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1090">This allows your application to perform the image decompression, dithering, and color space conversion one time (usually during program startup) rather than performing these operations each time the image is drawn.</span></span>

<span data-ttu-id="e6efc-1091">Görüntü okuyucu bileşeni işlevleri şunları içerir:</span><span class="sxs-lookup"><span data-stu-id="e6efc-1091">The Image Reader component functions include:</span></span>

<span data-ttu-id="e6efc-1092">***gx_image_reader_create***</span><span class="sxs-lookup"><span data-stu-id="e6efc-1092">***gx_image_reader_create***</span></span>  
<span data-ttu-id="e6efc-1093">***gx_image_reader_palette_set***</span><span class="sxs-lookup"><span data-stu-id="e6efc-1093">***gx_image_reader_palette_set***</span></span>  
<span data-ttu-id="e6efc-1094">***gx_image_reader_start***</span><span class="sxs-lookup"><span data-stu-id="e6efc-1094">***gx_image_reader_start***</span></span>

## <a name="guix-animation-component"></a><span data-ttu-id="e6efc-1095">GUX animasyon bileşeni</span><span class="sxs-lookup"><span data-stu-id="e6efc-1095">GUIX Animation Component</span></span> 

<span data-ttu-id="e6efc-1096">GUX animasyon bileşeni, ekran ve pencere öğesi geçiş otomatikleştirmelerini otomatikleştirmek için kullanılan bir işlevler ve hizmetler kümesidir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1096">The GUIX Animation component is a set of functions and services used to automate screen and widget transition automations.</span></span> <span data-ttu-id="e6efc-1097">GUX animasyon bileşeni, herhangi bir pencere öğesi türünün soldurma, soldurma ve taşıma ya da slayt türü animasyonlarını destekler.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1097">The GUIX Animation component supports fading in, fading out, and movement or slide type animations of any widget type.</span></span>

<span data-ttu-id="e6efc-1098">Zayıflatma türü animasyonları, soldurma Pencere öğelerinin iç alfa değeri ( **GX_BRUSH_ALPHA_SUPPORT** etkinse) veya herhangi bir pencere öğesinin herhangi bir koleksiyonunu ayrı bir bellek tuvaline çizerek, daha sonra arka planla karışarak desteklenebilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1098">Fade type animations can be supported either by varying the fading widget(s) internal alpha value (if **GX_BRUSH_ALPHA_SUPPORT** is enabled), or by drawing any collection of widgets to a separate memory canvas when is then blended with the background.</span></span> <span data-ttu-id="e6efc-1099">Birden çok donanım grafik katmanını destekleyen donanım hedefleri için, bu tuval karıştırma yaklaşımının kullanılması en iyi şekilde, genellikle çok az çekirdekli CPU bant genişliğine sahip olmak için desteklenir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1099">For hardware targets that support multiple hardware graphics layers, support for smooth fading effects is best accomplished using this canvas blending approach, often with very little core CPU bandwidth required.</span></span> <span data-ttu-id="e6efc-1100">Birden çok grafik katmanını desteklemeyen donanım hedefleri için, 16 BPP ve daha yüksek renk derinliğinde çalışırken Gux fırçası Alpha değeri kullanılarak karıştırma desteklenir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1100">For hardware targets that do not support multiple graphics layers, blending using the GUIX brush alpha value is supported when running at 16 bpp and higher color depths.</span></span>

<span data-ttu-id="e6efc-1101">Bir animasyonun ayrı bir çizim tuvali kullanması gerekiyorsa, Gux animasyon bileşeni bu amaçla API hizmeti gx_animation_canvas_define sağlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1101">If an animation should use a separate drawing canvas, the GUIX Animation component provides the API service gx_animation_canvas_define for this purpose.</span></span> <span data-ttu-id="e6efc-1102">Diğer animasyon türleri ayrı bir tuval gerektirmez, ancak varsa onu kullanır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1102">Other animation types do not require a separate canvas, but they will utilize it if it is available.</span></span> <span data-ttu-id="e6efc-1103">Bu, birden çok donanım için temel alınan donanım desteğinin en iyi kullanımını mümkün kılar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1103">This makes the best possible use of any underlying hardware support for multiple hardware surfaces.</span></span>

<span data-ttu-id="e6efc-1104">Bir animasyonu denetleyen değişkenler iki denetim bloğu tarafından tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1104">The variables controlling an animation are defined by two control blocks.</span></span> <span data-ttu-id="e6efc-1105">İlk olarak, animasyon denetleyicisini tanımlayan **GX_ANIMATION** denetim bloğu.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1105">First, the **GX_ANIMATION** control block which defines the animation controller.</span></span> <span data-ttu-id="e6efc-1106">Animasyon denetleyicisi, tanımladığınız animasyon dizisini yürüten itici altyapısıdır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1106">The animation controller is the driving engine that executes the animation sequence you define.</span></span> <span data-ttu-id="e6efc-1107">Tek bir animasyon denetleyicisi, birçok farklı animasyon dizisini çalıştırmak için bir kaç kez yeniden kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1107">A single animation controller can be re-used many times to run many different animation sequences.</span></span> <span data-ttu-id="e6efc-1108">Birden çok animasyon dizisini eşzamanlı olarak çalıştırmanız gerekirse, birden çok **GX_ANIMATION** animasyon denetleyicisi oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1108">If you need to run multiple animation sequences simultaneously, you can create multiple **GX_ANIMATION** animation controllers.</span></span>

<span data-ttu-id="e6efc-1109">GUX sistem bileşeni, ve animasyon gerektiğinde uygulama tarafından istenen ve animasyon sırası tamamlandığında otomatik olarak sistem havuzuna döndürülen **GX_ANIMATION** denetim yapıları için yeniden kullanılabilir bir blok sağlayabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1109">The GUIX system component can provide a re-usable block of **GX_ANIMATION** control structures, which can be requested by the application when and animation is needed and are automatically returned to the system pool when the animation sequence is completed.</span></span> <span data-ttu-id="e6efc-1110">Bu, uygulamayı, uygulanabilir her animasyon için statik olarak bir **GX_ANIMATION** yapısını tanımlayarak serbest bırakır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1110">This frees the application from statically defining a **GX_ANIMATION** structure for every animation that might be implemented.</span></span> <span data-ttu-id="e6efc-1111">Bu **GX_ANIMATION** yapıları havuzunun boyutu, varsayılan olarak 6 ' ya kadar, varsayılan 6 ' nın varsayılan olarak 6 ' ya kadar eşzamanlı animasyonların, sistem havuzundan ayrılabileceği şekilde **GX_ANIMATION_POOL_SIZE** tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1111">The size of this pool of **GX_ANIMATION** structures is defined by the constant **GX_ANIMATION_POOL_SIZE**, which defaults to 6, meaning that by default 6 simultaneous animations can be allocated from the system pool.</span></span> <span data-ttu-id="e6efc-1112">Bu sabit, gx_user. h üstbilgi dosyasında daha fazla eşzamanlı animasyon olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1112">This constant can of course be re-defined in the gx_user.h header file is more simultaneous animations are required.</span></span> <span data-ttu-id="e6efc-1113">**GX_ANIMATION_POOL_SIZE** sıfır olarak ayarlandıysa, guıdx sistem bileşeni bir animasyon havuzu veya ilgili hizmetler sağlamaz.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1113">If **GX_ANIMATION_POOL_SIZE** is set to zero, then the GUIX system component does not provide an animation pool or related services.</span></span>

<span data-ttu-id="e6efc-1114">Bir animasyonu tanımlamak için kullanılan ikinci denetim bloğu veya yapısı **GX_ANIMATION_INFO** yapısıdır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1114">The second control block or structure used to define an animation is the **GX_ANIMATION_INFO** structure.</span></span> <span data-ttu-id="e6efc-1115">Bu yapı, belirli bir animasyon sırasını tanımlamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1115">This structure is used to define one particular animation sequence.</span></span> <span data-ttu-id="e6efc-1116">Bu bilgi yapısını, gx_animation_start API hizmetini kullanarak bir animasyon sırası başlatmak için animasyon denetleyicinize geçirirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1116">You pass this information structure to your animation controller to initiate an animation sequence using the gx_animation_start API service.</span></span> <span data-ttu-id="e6efc-1117">**GX_ANIMATION_INFO** yapısı aşağıdaki alanları içerir:</span><span class="sxs-lookup"><span data-stu-id="e6efc-1117">The **GX_ANIMATION_INFO** structure contains the following fields:</span></span>

```C
typedef struct GX_ANIMATION_INFO_STRUCT
{
    GX_WIDGET *gx_animation_target;
    GX_WIDGET *gx_animation_parent;
    GX_WIDGET *gx_animation_screen_list;
    USHORT gx_animation_style;
    USHORT gx_animation_id;
    USHORT gx_animation_start_delay;
    USHORT gx_animation_frame_interval;
    GX_POINT gx_animation_start_position;
    GX_POINT gx_animation_end_position;
    GX_UBYTE gx_animation_start_alpha;
    GX_UBYTE gx_animation_end_alpha;
    GX_UBYTE gx_animation_steps;
} GX_ANIMATION_INFO;
```

<span data-ttu-id="e6efc-1118">**Gx_animation_target** üyesi, animasyon denetleyicisinin üzerinde işlem yapması için hedef pencere öğesini tanımlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1118">The **gx_animation_target** member defines the target widget that the animation controller will act upon.</span></span>

<span data-ttu-id="e6efc-1119">**Gx_animation_parent** üyesi, varsa, hedef pencere öğesinin animasyon sırası tamamlandığında eklendiği üst pencere öğesini tanımlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1119">The **gx_animation_parent** member defines the parent widget, if any, to which the target widget will be attached when the animation sequence is complete.</span></span> <span data-ttu-id="e6efc-1120">Gx_animation_parent Ayrıca, bir animasyon tamamlandığında oluşturulan GX_ANIMATION_COMPLETE olayının alıcıdır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1120">The gx_animation_parent is also the recipient of the GX_ANIMATION_COMPLETE event that is generated when an animation is completed.</span></span>

<span data-ttu-id="e6efc-1121">**Gx_animation_screen_list** üyesi, kalem girişi temelli ekran slayt animasyonları için pencere öğesi listesini tanımlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1121">The **gx_animation_screen_list** member defines a widget list for pen-input-driven screen slide animations.</span></span> <span data-ttu-id="e6efc-1122">Widge listesinin GX_NULL işaretçiyle sonlandırılması gerekir ve listedeki her pencere öğesi gx_animation_parent aynı x, y boyutlarına sahip olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1122">The widge list should be terminated with GX_NULL pointer, and each widget in the list should have the same x,y dimensions as the gx_animation_parent.</span></span>

<span data-ttu-id="e6efc-1123">**Gx_animation_style** , gerçekleştirilecek animasyon türünü ve ilişkili seçenekleri tanımlayan bir bit dır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1123">The **gx_animation_style** is a bitmask defining the type of animation to be performed and associated options.</span></span> <span data-ttu-id="e6efc-1124">Animasyon stili bayrakları aşağıdakileri içerir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1124">The animation style flags include the following.</span></span>

| <span data-ttu-id="e6efc-1125">Animasyon &nbsp; stili &nbsp; bayrağı</span><span class="sxs-lookup"><span data-stu-id="e6efc-1125">Animation&nbsp;Style&nbsp;Flag</span></span> | <span data-ttu-id="e6efc-1126">Açıklama</span><span class="sxs-lookup"><span data-stu-id="e6efc-1126">Description</span></span> |
| --- | --- |
| <span data-ttu-id="e6efc-1127">GX_ANIMATION_TRANSLATE</span><span class="sxs-lookup"><span data-stu-id="e6efc-1127">GX_ANIMATION_TRANSLATE</span></span> | <span data-ttu-id="e6efc-1128">Bir slayt veya belirme türü animasyonu isteyin.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1128">Request a slide or fade type animation.</span></span> |
| <span data-ttu-id="e6efc-1129">GX_ANIMATION_SCREEN_DRAG</span><span class="sxs-lookup"><span data-stu-id="e6efc-1129">GX_ANIMATION_SCREEN_DRAG</span></span> | <span data-ttu-id="e6efc-1130">Kalem girişi temelli ekran sürükleme animasyonu isteme.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1130">Request a pen-input driven screen drag animation.</span></span> |

<span data-ttu-id="e6efc-1131">Aşağıdaki bayraklar **SCREEN_DRAG** türü animasyonlarla birlikte kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1131">The following flags can be used in combination with **SCREEN_DRAG** type animations.</span></span>

| <span data-ttu-id="e6efc-1132">Ekran &nbsp; sürükleme &nbsp; bayrakları</span><span class="sxs-lookup"><span data-stu-id="e6efc-1132">Screen&nbsp;Drag&nbsp;Flags</span></span> | <span data-ttu-id="e6efc-1133">Açıklama</span><span class="sxs-lookup"><span data-stu-id="e6efc-1133">Description</span></span> |
| --- | --- |
| <span data-ttu-id="e6efc-1134">GX_ANIMATION_WRAP</span><span class="sxs-lookup"><span data-stu-id="e6efc-1134">GX_ANIMATION_WRAP</span></span> | <span data-ttu-id="e6efc-1135">Ekran listesi baştan itibaren başa doğru kaydırılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1135">The screen list should wrap from end back to start.</span></span> |
| <span data-ttu-id="e6efc-1136">GX_ANIMATION_HORIZONTAL</span><span class="sxs-lookup"><span data-stu-id="e6efc-1136">GX_ANIMATION_HORIZONTAL</span></span> | <span data-ttu-id="e6efc-1137">Yatay yönde ekran sürüklemeye izin verildi.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1137">Screen drag allowed in horizontal direction.</span></span>  |
| <span data-ttu-id="e6efc-1138">GX_ANIMATION_VERTICAL</span><span class="sxs-lookup"><span data-stu-id="e6efc-1138">GX_ANIMATION_VERTICAL</span></span> | <span data-ttu-id="e6efc-1139">Dikey yönde ekran sürüklemeye izin verildi.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1139">Screen drag allowed in vertical direction.</span></span> |

<span data-ttu-id="e6efc-1140">Aşağıdaki bayrak, animasyonları çevir ile birlikte kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1140">The following flag can be used in combination with translate animations.</span></span>

| <span data-ttu-id="e6efc-1141">&nbsp;Animasyon &nbsp; bayraklarını çevir</span><span class="sxs-lookup"><span data-stu-id="e6efc-1141">Translate&nbsp;Animations&nbsp;Flags</span></span> | <span data-ttu-id="e6efc-1142">Açıklama</span><span class="sxs-lookup"><span data-stu-id="e6efc-1142">Description</span></span> |
| --- | --- |
| <span data-ttu-id="e6efc-1143">GX_ANIMATION_DETACH</span><span class="sxs-lookup"><span data-stu-id="e6efc-1143">GX_ANIMATION_DETACH</span></span> | <span data-ttu-id="e6efc-1144">Animasyon tamamlandığında animasyon hedefini animasyon üst öğesinden ayırın.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1144">Detach the animation target from the animation parent when the animation is completed.</span></span> <span data-ttu-id="e6efc-1145">Hedef, Gux Studio tarafından oluşturulan otomatik olay işleme tarafından dinamik olarak ayrılmışsa ve oluşturulduysa, hedef ayrıldıktan sonra silinir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1145">If the target was dynamically allocated and created by the GUIX Studio generated automated event handling, the target will be deleted after it is detached.</span></span> |
| <span data-ttu-id="e6efc-1146">GX_ANIMATION_TRANSLATE</span><span class="sxs-lookup"><span data-stu-id="e6efc-1146">GX_ANIMATION_TRANSLATE</span></span> | <span data-ttu-id="e6efc-1147">Animasyon türleri Zamanlayıcı odaklı animasyonlardır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1147">Animation types are timer driven animations.</span></span> <span data-ttu-id="e6efc-1148">Uygulama, hedef pencere öğesi için başlangıç ve bitiş konumunu ve başlangıç ve bitiş değerini tanımlar ve animasyon Yöneticisi, işlem yapmak için bir zamanlayıcı oluşturur ve bu işlem, animasyonu yürütmeye zorlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1148">The application defines the starting and ending position and starting and ending alpha value for the target widget, and the animation manager creates a timer to serve and as the driving force to execute the animation.</span></span>
| <span data-ttu-id="e6efc-1149">GX_ANIMATION_SCREEN_DRAG</span><span class="sxs-lookup"><span data-stu-id="e6efc-1149">GX_ANIMATION_SCREEN_DRAG</span></span> | <span data-ttu-id="e6efc-1150">Bu animasyon türünün kalem giriş olayları tarafından çalıştırılmaları için **çeviri** animasyonlarından farklıdır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1150">Differs from the **TRANSLATE** animations in that this animation type is driven by pen input events.</span></span> <span data-ttu-id="e6efc-1151">Bu animasyon, Kullanıcı giriş dokunmatik ekranında bir kalem veya ekran kalemi sürüklediği için, hedef pencere öğesini çekerek dokunmatik ekran girişi ile birlikte izler.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1151">This animation type tracks along with the touch screen input to swipe the target widget as the user drags a pen or stylus across the input touch screen.</span></span> <span data-ttu-id="e6efc-1152">Bu tür bir animasyon kullanmak için, uygulamanın bu animasyonu etkinleştirmek üzere **_gx_animation_drag_enable_** API 'sini çağırması gerekir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1152">To utilize this type of animation, the application should call the **_gx_animation_drag_enable_** API to enable this animation.</span></span> |

<span data-ttu-id="e6efc-1153">**Gx_animation_id** değeri, **GX_ANIMATION_COMPLETE** olayının Event.gx_event_sender alanındaki animasyon üst öğesine geri geçirilir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1153">The **gx_animation_id** value is passed back to the animation parent in the event.gx_event_sender field of the **GX_ANIMATION_COMPLETE** event.</span></span> <span data-ttu-id="e6efc-1154">Bu değer, büyük olasılıkla çok sayıda alt animasyonun ne olduğunu raporlamak için animasyon üst öğesi tarafından kullanılır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1154">This value is used by the animation parent to determine which of possibly several child animations is reporting completion.</span></span> <span data-ttu-id="e6efc-1155">Bu değer 0 olabilir ve KIMLIK değeri 0 olan bir animasyon, **ANIMATION_COMPLETE** bir olay oluşturmaz.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1155">This value can be 0, and an animation with ID value 0 will not generate an **ANIMATION_COMPLETE** event at all.</span></span>

<span data-ttu-id="e6efc-1156">**Gx_animation_start_delay** değeri, ***animasyonu gerçekten yürütmeden önce gx_animation_start _ çağrıldıktan sonra gecikme süresi sayısını belirten bir Guix değer sayısıdır. Değer, _ gx_animation_start çağrıldıktan hemen sonra animasyonu başlatmak için 0 olabilir***.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1156">The **gx_animation_start_delay** value is a GUIX tick count indicating the number of timer ticks to delay after **_gx_animation_start_*_ is called before actually executing the animation. The value can be 0 to start the animation immediately upon calling _*_gx_animation_start_**.</span></span>

<span data-ttu-id="e6efc-1157">**Gx_animation_frame_interval** alanı, animasyon dizisinin her bir çerçevesi arasında gecikmeye izin vermek için Gux Zamanlayıcı çentiklerinin sayısını (temeldeki işletim sistemi işaret hızının bir katı) tanımlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1157">The **gx_animation_frame_interval** field defines the number of GUIX timer ticks (a multiple of the underlying OS tick rate) to delay between each frame of the animation sequence.</span></span> <span data-ttu-id="e6efc-1158">En küçük değer 1 ' dir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1158">The minimum value is 1.</span></span>

<span data-ttu-id="e6efc-1159">**Gx_animation_start_position** , çeviri animasyonları için hedef pencere öğesi için sol üst başlangıç noktasını tanımlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1159">The **gx_animation_start_position** defines the top-left starting point for the target widget for translation animations.</span></span>

<span data-ttu-id="e6efc-1160">**Gx_animation_end_position** , çeviri türü animasyonları için hedef pencere öğesinin üst sol bitiş konumunu tanımlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1160">The **gx_animation_end_position** defines the top-left ending position for the target widget for translation type animations.</span></span>

<span data-ttu-id="e6efc-1161">**Gx_animation_start_alpha** alanı, çeviri türü animasyonları için başlangıç tuvali Alfa değerini tanımlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1161">The **gx_animation_start_alpha** field defines the starting canvas alpha value for translation type animations.</span></span>

<span data-ttu-id="e6efc-1162">**Gx_animation_end_alpha** alanı, çeviri türü animasyonları için bitiş tuvali Alfa değerini tanımlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1162">The **gx_animation_end_alpha** field defines the ending canvas alpha value for translation type animations.</span></span>

<span data-ttu-id="e6efc-1163">**Gx_animation_steps** alanı, denetleyicinin çeviri animasyonları için kaç adım veya kare yürütmesi gerektiğini tanımlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1163">The **gx_animation_steps** field defines how many steps or frames the controller should execute for translation animations.</span></span> <span data-ttu-id="e6efc-1164">Daha fazla sayıda adım daha yumuşak bir slayt ve/veya Soldur görünümü üretir, ancak aynı zamanda daha fazla sistem bant genişliği gerektirir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1164">A larger number of steps produces a smoother slide and/or fade appearance, but also requires greater system bandwidth.</span></span>

<span data-ttu-id="e6efc-1165">Uygulamanızda animasyon efektlerini uygulamak için, önce animasyon denetleyicinizi başlatmak üzere ***gx_animation_create*** çağırmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1165">To implement animation effects in your application, you must first call ***gx_animation_create*** to initialize your animation controller.</span></span> <span data-ttu-id="e6efc-1166">Animasyonunuz ikincil bir tuval kullanacaksanız, gx_animation_canvas_define çağırarak bu tuvali başlatın.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1166">If your animation will be using a secondary canvas, initialize this canvas by calling gx_animation_canvas_define.</span></span> <span data-ttu-id="e6efc-1167">Daha sonra, gerçekleştirilecek belirli animasyon türünü ve diğer animasyon parametrelerini tanımlamak için **GX_ANIMATION_INFO** yapısını başlatmalısınız.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1167">Next, you should initialize the **GX_ANIMATION_INFO** structure to define the specific type of animation to be performed and the other animation parameters.</span></span> <span data-ttu-id="e6efc-1168">Son olarak, Animasyon sırasını tetiklemek için gx_animation_start çağırın.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1168">Finally, call gx_animation_start to trigger the animation sequence.</span></span>

<span data-ttu-id="e6efc-1169">Animasyon denetleyicisi bir animasyon sırasını tamamladığında, bir **GX_ANIMATION_COMPLETE** olayını üst pencere öğesine gönderir ve bu sırada animasyon tuvalinin istenen Temizleme işleminin bu sırada yapılmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1169">When the animation controller completes an animation sequence, it sends an **GX_ANIMATION_COMPLETE** event to the parent widget, allowing the any desired cleanup of the animation canvas to be done at that time.</span></span>

## <a name="guix-utility-component"></a><span data-ttu-id="e6efc-1170">GUIX yardımcı program bileşeni</span><span class="sxs-lookup"><span data-stu-id="e6efc-1170">GUIX Utility Component</span></span> 

<span data-ttu-id="e6efc-1171">Yardımcı program bileşeni, Gux 'teki tüm ortak yardımcı program işlevlerinden sorumludur.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1171">The utility component is responsible for all common utility functions in GUIX.</span></span> <span data-ttu-id="e6efc-1172">Bunlar, yararlı yardımcı programlar olan ve uygulamanın herhangi bir yerinden veya iç Gux kodunda çağrılabilen yaygın işlevlerdir.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1172">These are common functions that are useful utilities and can be invoked from anywhere in the application or the internal GUIX code.</span></span> <span data-ttu-id="e6efc-1173">Yardımcı program bileşeni işlevleri şunlardır.</span><span class="sxs-lookup"><span data-stu-id="e6efc-1173">The utility component functions include the following.</span></span>

<span data-ttu-id="e6efc-1174">***gx_utility_canvas_to_bmp***</span><span class="sxs-lookup"><span data-stu-id="e6efc-1174">***gx_utility_canvas_to_bmp***</span></span>

<span data-ttu-id="e6efc-1175">***gx_utility_circle_point_get***</span><span class="sxs-lookup"><span data-stu-id="e6efc-1175">***gx_utility_circle_point_get***</span></span>

<span data-ttu-id="e6efc-1176">***gx_utility_alphamap_create***</span><span class="sxs-lookup"><span data-stu-id="e6efc-1176">***gx_utility_alphamap_create***</span></span>

<span data-ttu-id="e6efc-1177">***gx_utility_gradient_create***</span><span class="sxs-lookup"><span data-stu-id="e6efc-1177">***gx_utility_gradient_create***</span></span>

<span data-ttu-id="e6efc-1178">***gx_utility_gradient_delete***</span><span class="sxs-lookup"><span data-stu-id="e6efc-1178">***gx_utility_gradient_delete***</span></span>

<span data-ttu-id="e6efc-1179">***gx_utlity_ltoa***</span><span class="sxs-lookup"><span data-stu-id="e6efc-1179">***gx_utlity_ltoa***</span></span>

<span data-ttu-id="e6efc-1180">***gx_utility_math_acos***</span><span class="sxs-lookup"><span data-stu-id="e6efc-1180">***gx_utility_math_acos***</span></span>

<span data-ttu-id="e6efc-1181">***gx_utility_math_asin***</span><span class="sxs-lookup"><span data-stu-id="e6efc-1181">***gx_utility_math_asin***</span></span>

<span data-ttu-id="e6efc-1182">***gx_utility_math_cos***</span><span class="sxs-lookup"><span data-stu-id="e6efc-1182">***gx_utility_math_cos***</span></span>

<span data-ttu-id="e6efc-1183">***gx_utility_math_sin***</span><span class="sxs-lookup"><span data-stu-id="e6efc-1183">***gx_utility_math_sin***</span></span>

<span data-ttu-id="e6efc-1184">***gx_utility_math_sqrt***</span><span class="sxs-lookup"><span data-stu-id="e6efc-1184">***gx_utility_math_sqrt***</span></span>

<span data-ttu-id="e6efc-1185">***gx_utility_pixelmap_resize***</span><span class="sxs-lookup"><span data-stu-id="e6efc-1185">***gx_utility_pixelmap_resize***</span></span>

<span data-ttu-id="e6efc-1186">***gx_utility_pixelmap_rotate***</span><span class="sxs-lookup"><span data-stu-id="e6efc-1186">***gx_utility_pixelmap_rotate***</span></span>

<span data-ttu-id="e6efc-1187">***gx_utility_pixelmap_simple_rotate***</span><span class="sxs-lookup"><span data-stu-id="e6efc-1187">***gx_utility_pixelmap_simple_rotate***</span></span>

<span data-ttu-id="e6efc-1188">***gx_utility_rectangle_center***</span><span class="sxs-lookup"><span data-stu-id="e6efc-1188">***gx_utility_rectangle_center***</span></span>

<span data-ttu-id="e6efc-1189">***gx_utility_rectangle_center_find***</span><span class="sxs-lookup"><span data-stu-id="e6efc-1189">***gx_utility_rectangle_center_find***</span></span>

<span data-ttu-id="e6efc-1190">***gx_utility_rectangle_combine***</span><span class="sxs-lookup"><span data-stu-id="e6efc-1190">***gx_utility_rectangle_combine***</span></span>

<span data-ttu-id="e6efc-1191">***gx_utility_rectangle_compare***</span><span class="sxs-lookup"><span data-stu-id="e6efc-1191">***gx_utility_rectangle_compare***</span></span>

<span data-ttu-id="e6efc-1192">***gx_utility_rectangle_define***</span><span class="sxs-lookup"><span data-stu-id="e6efc-1192">***gx_utility_rectangle_define***</span></span>

<span data-ttu-id="e6efc-1193">***gx_utility_rectangle_overlap_detect***</span><span class="sxs-lookup"><span data-stu-id="e6efc-1193">***gx_utility_rectangle_overlap_detect***</span></span>

<span data-ttu-id="e6efc-1194">***gx_utility_rectangle_point_detect***</span><span class="sxs-lookup"><span data-stu-id="e6efc-1194">***gx_utility_rectangle_point_detect***</span></span>

<span data-ttu-id="e6efc-1195">***gx_utility_rectangle_resize***</span><span class="sxs-lookup"><span data-stu-id="e6efc-1195">***gx_utility_rectangle_resize***</span></span>

<span data-ttu-id="e6efc-1196">***gx_utility_rectangle_shift***</span><span class="sxs-lookup"><span data-stu-id="e6efc-1196">***gx_utility_rectangle_shift***</span></span>

<span data-ttu-id="e6efc-1197">***gx_utility_string_to_alphamap***</span><span class="sxs-lookup"><span data-stu-id="e6efc-1197">***gx_utility_string_to_alphamap***</span></span>
