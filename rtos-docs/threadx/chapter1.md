---
title: Bölüm 1-Azure RTOS ThreadX 'e giriş
description: Bu bölümde, Azure RTOS ThreadX 'e giriş ve uygulamalarının ve avantajlarından ilgili bir açıklama yer almaktadır.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 83718ddf5469238e2429855908be2ea5d405f874
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/22/2021
ms.locfileid: "104826579"
---
# <a name="chapter-1---introduction-to-azure-rtos-threadx"></a><span data-ttu-id="220da-103">Bölüm 1-Azure RTOS ThreadX 'e giriş</span><span class="sxs-lookup"><span data-stu-id="220da-103">Chapter 1 - Introduction to Azure RTOS ThreadX</span></span>

<span data-ttu-id="220da-104">Azure RTOS ThreadX, özellikle eklenmiş uygulamalar için tasarlanan yüksek performanslı bir gerçek zamanlı çekirlüdür.</span><span class="sxs-lookup"><span data-stu-id="220da-104">Azure RTOS ThreadX is a high-performance real-time kernel designed specifically for embedded applications.</span></span> <span data-ttu-id="220da-105">Bu bölümde, ürüne giriş ve uygulamaların ve avantajlarının açıklaması yer almaktadır.</span><span class="sxs-lookup"><span data-stu-id="220da-105">This chapter contains an introduction to the product and a description of its applications and benefits.</span></span>

## <a name="threadx-unique-features"></a><span data-ttu-id="220da-106">ThreadX benzersiz özellikleri</span><span class="sxs-lookup"><span data-stu-id="220da-106">ThreadX Unique Features</span></span>

<span data-ttu-id="220da-107">Diğer gerçek zamanlı kernels uygulamalarından farklı olarak, ThreadX, güçlü CIC, RıSC ve DSP işlemcileri kullanan küçük mikro denetleyici tabanlı uygulamalar arasında kolayca ölçeklendirip çok yönlü olacak şekilde tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="220da-107">Unlike other real-time kernels, ThreadX is designed to be versatile—easily scaling among small microcontroller-based applications through those that use powerful CISC, RISC, and DSP processors.</span></span>

<span data-ttu-id="220da-108">ThreadX, temel mimarisine göre ölçeklenebilir.</span><span class="sxs-lookup"><span data-stu-id="220da-108">ThreadX is scalable based on its underlying architecture.</span></span> <span data-ttu-id="220da-109">ThreadX Hizmetleri bir C Kitaplığı olarak uygulandığından, yalnızca uygulama tarafından kullanılan hizmetler çalışma zamanı görüntüsüne getirilir.</span><span class="sxs-lookup"><span data-stu-id="220da-109">Because ThreadX services are implemented as a C library, only those services actually used by the application are brought into the run-time image.</span></span> <span data-ttu-id="220da-110">Bu nedenle, ThreadX gerçek boyutu uygulama tarafından tamamen belirlenir.</span><span class="sxs-lookup"><span data-stu-id="220da-110">Hence, the actual size of ThreadX is completely determined by the application.</span></span> <span data-ttu-id="220da-111">Çoğu uygulama için, ThreadX yönerge görüntüsü, boyutu 2 Kbayt ile 15 kilobayt arasında değişir.</span><span class="sxs-lookup"><span data-stu-id="220da-111">For most applications, the instruction image of ThreadX ranges between 2 KBytes and 15 KBytes in size.</span></span>

### <a name="picokerneltrade-architecture"></a><span data-ttu-id="220da-112">*picokernel &trade; mimarisi*</span><span class="sxs-lookup"><span data-stu-id="220da-112">*picokernel&trade; Architecture*</span></span>

<span data-ttu-id="220da-113">Kernel işlevlerini geleneksel *mikro çekirdek* mimarileri gibi birbirlerine göre katmanlama yerine, threadx Hizmetleri doğrudan kendi çekirdeğine takılır.</span><span class="sxs-lookup"><span data-stu-id="220da-113">Instead of layering kernel functions on top of each other like traditional *microkernel* architectures, ThreadX services plug directly into its core.</span></span> <span data-ttu-id="220da-114">Bu, en hızlı olası bağlam değiştirme ve hizmet çağrısı performansına neden olur.</span><span class="sxs-lookup"><span data-stu-id="220da-114">This results in the fastest possible context switching and service call performance.</span></span> <span data-ttu-id="220da-115">Bu katmansız tasarımı bir *picokernel* mimarisi olarak çağırıyoruz.</span><span class="sxs-lookup"><span data-stu-id="220da-115">We call this non-layering design a *picokernel* architecture.</span></span>

### <a name="ansi-c-source-code"></a><span data-ttu-id="220da-116">ANSI C kaynak kodu</span><span class="sxs-lookup"><span data-stu-id="220da-116">ANSI C Source Code</span></span>

<span data-ttu-id="220da-117">ThreadX, birincil olarak ANSI C 'de yazılmıştır. Çekirdeği temeldeki hedef işlemciye uyarlamak için küçük miktarda derleme dili gerekir.</span><span class="sxs-lookup"><span data-stu-id="220da-117">ThreadX is written primarily in ANSI C. A small amount of assembly language is needed to tailor the kernel to the underlying target processor.</span></span> <span data-ttu-id="220da-118">Bu tasarım, ThreadX 'in (genellikle hafta içinde) çok kısa bir süre içinde yeni bir işlemci ailesine bağlantı noktası kullanmasını mümkün kılar.</span><span class="sxs-lookup"><span data-stu-id="220da-118">This design makes it possible to port ThreadX to a new processor family in a very short time—usually within weeks!</span></span>

### <a name="advanced-technology"></a><span data-ttu-id="220da-119">Gelişmiş teknoloji</span><span class="sxs-lookup"><span data-stu-id="220da-119">Advanced Technology</span></span>

<span data-ttu-id="220da-120">Aşağıda, ThreadX gelişmiş teknolojisinin önemli noktaları verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="220da-120">The following are highlights of the ThreadX advanced technology.</span></span>
- <span data-ttu-id="220da-121">Basit *picokernel* mimarisi</span><span class="sxs-lookup"><span data-stu-id="220da-121">Simple *picokernel* architecture</span></span>
- <span data-ttu-id="220da-122">Otomatik ölçeklendirme (küçük ayak izi)</span><span class="sxs-lookup"><span data-stu-id="220da-122">Automatic scaling (small footprint)</span></span>
- <span data-ttu-id="220da-123">Belirleyici işleme</span><span class="sxs-lookup"><span data-stu-id="220da-123">Deterministic processing</span></span>
- <span data-ttu-id="220da-124">Hızlı gerçek zamanlı performans</span><span class="sxs-lookup"><span data-stu-id="220da-124">Fast real-time performance</span></span>
- <span data-ttu-id="220da-125">PreEmptive ve işbirlikçi zamanlaması</span><span class="sxs-lookup"><span data-stu-id="220da-125">Preemptive and cooperative scheduling</span></span>
- <span data-ttu-id="220da-126">Esnek iş parçacığı önceliği desteği</span><span class="sxs-lookup"><span data-stu-id="220da-126">Flexible thread priority support</span></span>
- <span data-ttu-id="220da-127">Dinamik sistem nesnesi oluşturma</span><span class="sxs-lookup"><span data-stu-id="220da-127">Dynamic system object creation</span></span>
- <span data-ttu-id="220da-128">Sınırsız sayıda sistem nesnesi</span><span class="sxs-lookup"><span data-stu-id="220da-128">Unlimited number of system objects</span></span>
- <span data-ttu-id="220da-129">İyileştirilmiş kesme işleme</span><span class="sxs-lookup"><span data-stu-id="220da-129">Optimized interrupt handling</span></span>
- <span data-ttu-id="220da-130">Önalım-eşik&trade;</span><span class="sxs-lookup"><span data-stu-id="220da-130">Preemption-threshold&trade;</span></span>
- <span data-ttu-id="220da-131">Öncelikli devralma</span><span class="sxs-lookup"><span data-stu-id="220da-131">Priority inheritance</span></span>
- <span data-ttu-id="220da-132">Olay zincirleme&trade;</span><span class="sxs-lookup"><span data-stu-id="220da-132">Event-chaining&trade;</span></span>
- <span data-ttu-id="220da-133">Hızlı yazılım zamanlayıcılarını</span><span class="sxs-lookup"><span data-stu-id="220da-133">Fast software timers</span></span>
- <span data-ttu-id="220da-134">Çalışma zamanı bellek yönetimi</span><span class="sxs-lookup"><span data-stu-id="220da-134">Run-time memory management</span></span>
- <span data-ttu-id="220da-135">Çalışma zamanı performans izleme</span><span class="sxs-lookup"><span data-stu-id="220da-135">Run-time performance monitoring</span></span>
- <span data-ttu-id="220da-136">Çalışma zamanı yığın Analizi</span><span class="sxs-lookup"><span data-stu-id="220da-136">Run-time stack analysis</span></span>
- <span data-ttu-id="220da-137">Yerleşik sistem izleme</span><span class="sxs-lookup"><span data-stu-id="220da-137">Built-in system trace</span></span>
- <span data-ttu-id="220da-138">Büyük işlemci desteği</span><span class="sxs-lookup"><span data-stu-id="220da-138">Vast processor support</span></span>
- <span data-ttu-id="220da-139">Büyük geliştirme aracı desteği</span><span class="sxs-lookup"><span data-stu-id="220da-139">Vast development tool support</span></span>
- <span data-ttu-id="220da-140">Tamamen endian nötr</span><span class="sxs-lookup"><span data-stu-id="220da-140">Completely endian neutral</span></span>

### <a name="not-a-black-box"></a><span data-ttu-id="220da-141">Siyah kutu değil</span><span class="sxs-lookup"><span data-stu-id="220da-141">Not A Black Box</span></span>

<span data-ttu-id="220da-142">ThreadX dağıtımları, tam C kaynak kodunu ve işlemciye özgü derleme dilini içerir.</span><span class="sxs-lookup"><span data-stu-id="220da-142">Most distributions of ThreadX include the complete C source code as well as the processor-specific assembly language.</span></span> <span data-ttu-id="220da-143">Bu, çok sayıda ticari kerels ile oluşan "kara kutu" sorunlarını ortadan kaldırır.</span><span class="sxs-lookup"><span data-stu-id="220da-143">This eliminates the "black-box" problems that occur with many commercial kernels.</span></span> <span data-ttu-id="220da-144">ThreadX ile uygulama geliştiricileri, tam olarak çekirdeğin ne yaptığını görebilir; herhangi bir gizleyebilmektir!</span><span class="sxs-lookup"><span data-stu-id="220da-144">With ThreadX, application developers can see exactly what the kernel is doing—there are no mysteries!</span></span>

<span data-ttu-id="220da-145">Kaynak kodu uygulamaya özgü değişikliklere de olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="220da-145">The source code also allows for application specific modifications.</span></span> <span data-ttu-id="220da-146">Önerilmese de, kesinlikle gerekliyse çekirdeği değiştirme imkanına kesinlikle yarar vardır.</span><span class="sxs-lookup"><span data-stu-id="220da-146">Although not recommended, it is certainly beneficial to have the ability to modify the kernel if it is absolutely required.</span></span>

<span data-ttu-id="220da-147">Bu özellikler özellikle, kendi *Şirket içi çekirdekleri* ile çalışmaya alışkın olan geliştiricilere Comforting.</span><span class="sxs-lookup"><span data-stu-id="220da-147">These features are especially comforting to developers accustomed to working with their own *in-house kernels*.</span></span> <span data-ttu-id="220da-148">Kaynak kodu ve çekirdeği değiştirme yeteneğinin olmasını bekler.</span><span class="sxs-lookup"><span data-stu-id="220da-148">They expect to have source code and the ability to modify the kernel.</span></span> <span data-ttu-id="220da-149">ThreadX, bu tür geliştiriciler için en son çekirdedir.</span><span class="sxs-lookup"><span data-stu-id="220da-149">ThreadX is the ultimate kernel for such developers.</span></span>

### <a name="the-rtos-standard"></a><span data-ttu-id="220da-150">RTOS standart</span><span class="sxs-lookup"><span data-stu-id="220da-150">The RTOS Standard</span></span>

<span data-ttu-id="220da-151">Çok yönlülük, yüksek performanslı *picokernel* mimarisi, gelişmiş teknoloji ve gösterilen taşınabilirlik nedeniyle, threadx bugün 2.000.000.000 ' den fazla cihazda dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="220da-151">Because of its versatility, high-performance *picokernel* architecture, advanced technology, and demonstrated portability, ThreadX is deployed in more than two-billion devices today.</span></span> <span data-ttu-id="220da-152">Bu, derin eklenmiş uygulamalar için ThreadX 'i RTOS standardını etkin hale getirir.</span><span class="sxs-lookup"><span data-stu-id="220da-152">This effectively makes ThreadX the RTOS standard for deeply embedded applications.</span></span>

## <a name="safety-certifications"></a><span data-ttu-id="220da-153">Güvenlik sertifikaları</span><span class="sxs-lookup"><span data-stu-id="220da-153">Safety Certifications</span></span>

### <a name="tv-certification"></a><span data-ttu-id="220da-154">TÜV Sertifikası</span><span class="sxs-lookup"><span data-stu-id="220da-154">TÜV Certification</span></span>

<span data-ttu-id="220da-155">ThreadX, SGS-TÜV Saar tarafından, IEC61508 ve ıEC-62304 ' e göre güvenlik açısından kritik sistemlerde kullanılmak üzere sertifikalandırilmiştir.</span><span class="sxs-lookup"><span data-stu-id="220da-155">ThreadX has been certified by SGS-TÜV Saar for use in safety-critical systems, according to IEC61508 and IEC-62304.</span></span> <span data-ttu-id="220da-156">Sertifika, "elektrik, elektronik ve programlanabilir elektronik güvenliği ile ilgili sistemlerin Işlevsel güvenliği" için Uluslararası Elektroteknik Komisyonu (ıEC) 61508 ve ıEC 62304 ' nin en yüksek güvenlik bütünlüğü düzeylerine yönelik güvenlik ile ilgili yazılımların geliştirilmesi için, ThreadX 'in kullanılabilir olduğunu onaylar.</span><span class="sxs-lookup"><span data-stu-id="220da-156">The certification confirms that ThreadX can be used in the  development of safety related software for the highest safety integrity levels of the International Electrotechnical Commission (IEC) 61508 and IEC 62304, for the "Functional Safety of electrical, electronic, and programmable electronic safety-related systems."</span></span> <span data-ttu-id="220da-157">Almanya 'nun sgsgroup ve TÜV Saarland 'ın bir Joint girişim aracılığıyla oluşturulan SGS-TÜV Saar, dünya çapındaki güvenlikle ilgili sistemler için katıştırılmış yazılımları test etmek, denetlemek, doğrulamak ve sertifika almak için önde gelen acalacak, bağımsız şirket haline geldi.</span><span class="sxs-lookup"><span data-stu-id="220da-157">SGS-TÜV Saar, formed through a joint venture of Germany's SGSGroup and TÜV Saarland, has become the leading accredited, independent company for testing, auditing, verifying, and certifying embedded software for safety-related systems worldwide.</span></span> <span data-ttu-id="220da-158">Endüstriyel güvenlik standardı IEC 61508 ve bundan türetilmiş tüm standartlar, 62304 IEC, elektronik ve programlanabilir elektronik güvenliği ile ilgili tıbbi cihazların, işlem denetim sistemlerinin, endüstriyel makinelerin ve demiryolu denetim sistemlerinin işlevsel güvenliğini güvence altına almak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="220da-158">The industrial safety standard IEC 61508, and all standards that are derived from it, including IEC 62304, are used to assure the functional safety of electrical, electronic, and programmable electronic safety-related medical devices, process control systems, industrial machinery, and railway control systems.</span></span>

<span data-ttu-id="220da-159">SGS-TÜV Saar, ISO 26262 standardına göre güvenlik açısından kritik bir oto dili sisteminde kullanılmak üzere sertifikalı ThreadX 'e sahiptir.</span><span class="sxs-lookup"><span data-stu-id="220da-159">SGS-TÜV Saar has certified ThreadX to be used in safety-critical automotive systems, according to the ISO 26262 standard.</span></span> <span data-ttu-id="220da-160">Ayrıca, ThreadX, en yüksek ISO 26262 sertifikası düzeyini temsil eden, g/v güvenlik bütünlüğü düzeyi (asıl) D 'ye sertifikalı değildir.</span><span class="sxs-lookup"><span data-stu-id="220da-160">Furthermore, ThreadX is certified to Automotive Safety Integrity Level (ASIL) D, which represents the highest level of ISO 26262 certification.</span></span>

<span data-ttu-id="220da-161">Ayrıca, SGS-TÜV Saar, güvenlik açısından kritik demiryolu uygulamalarında kullanılmak üzere sertifikalı threadx 'e sahiptir ve en fazla 50128 standart, en fazla ' a kadar.</span><span class="sxs-lookup"><span data-stu-id="220da-161">In addition, SGS-TÜV Saar has certified ThreadX to be used in safety-critical railway applications, meeting to the EN 50128 standard up to SW-SIL 4.</span></span>

![TÜV Sertifikası](./media/overview-threadx/partener-logo-sgs-tuv-saar-2.png)

* <span data-ttu-id="220da-163">IEC 61508, SIL 4 ' e kadar</span><span class="sxs-lookup"><span data-stu-id="220da-163">IEC 61508 up to SIL 4</span></span>

* <span data-ttu-id="220da-164">IEC 62304 en fazla SW güvenlik sınıfı C</span><span class="sxs-lookup"><span data-stu-id="220da-164">IEC 62304 up to SW safety Class C</span></span>

* <span data-ttu-id="220da-165">ISO 26262 ASIL D</span><span class="sxs-lookup"><span data-stu-id="220da-165">ISO 26262 ASIL D</span></span>

* <span data-ttu-id="220da-166">EN 50128 SW-SıL 4</span><span class="sxs-lookup"><span data-stu-id="220da-166">EN 50128 SW-SIL 4</span></span>

> [!NOTE]
> <span data-ttu-id="220da-167">*Tüm ThreadX sürümleri için TÜV veya test raporlarının, sertifikaların ve ilişkili belgelerin kullanılabilirliği hakkında daha fazla bilgi için lütfen bizimle iletişime geçin.*</span><span class="sxs-lookup"><span data-stu-id="220da-167">*Please contact us for more information on which version(s) of ThreadX have been certified by TÜV or for the availability of test reports, certificates, and associated documentation.*</span></span>

### <a name="misra-c-compliant"></a><span data-ttu-id="220da-168">MISRA C uyumlu</span><span class="sxs-lookup"><span data-stu-id="220da-168">MISRA C Compliant</span></span>

<span data-ttu-id="220da-169">MISRA C, C programlama dilini kullanan kritik sistemler için bir programlama yönergeleri kümesidir.</span><span class="sxs-lookup"><span data-stu-id="220da-169">MISRA C is a set of programming guidelines for critical systems using the C programming language.</span></span> <span data-ttu-id="220da-170">Özgün MISRA C yönergeleri öncelikli olarak, ilk olarak bir oto ve uygulamaları hedeflenmiştir; Ancak, MISRA C artık tüm güvenlik açısından kritik uygulamalar için geçerli olduğu kadar büyük ölçüde tanınır.</span><span class="sxs-lookup"><span data-stu-id="220da-170">The original MISRA C guidelines were primarily targeted toward automotive applications; however, MISRA C is now widely recognized as being applicable to any safety critical application.</span></span> <span data-ttu-id="220da-171">ThreadX, MISRA-C:2004 ve MISRA c:2012'nin tüm "zorunlu" ve "zorunlu" kuralları ile uyumludur.</span><span class="sxs-lookup"><span data-stu-id="220da-171">ThreadX is compliant with all "required" and "mandatory" rules of MISRA-C:2004 and MISRA C:2012.</span></span> <span data-ttu-id="220da-172">ThreadX, üç "Danışmanlık" kurallarıyla da uyumludur.</span><span class="sxs-lookup"><span data-stu-id="220da-172">ThreadX is also compliant with all but three "advisory" rules.</span></span> <span data-ttu-id="220da-173">Daha fazla ayrıntı için ***ThreadX_MISRA_Compliance.pdf*** belgesine bakın.</span><span class="sxs-lookup"><span data-stu-id="220da-173">Refer to the ***ThreadX_MISRA_Compliance.pdf*** document for more details.</span></span>

### <a name="ul-certification"></a><span data-ttu-id="220da-174">UL sertifikası</span><span class="sxs-lookup"><span data-stu-id="220da-174">UL Certification</span></span>

<span data-ttu-id="220da-175">Bkz. ThreadX, UL 60730-1 Ek H, CSA E60730-1 Ek H, ıEC 60730-1 Ek H, UL 60335-1 ek R, ıEC 60335-1 ek R 1998 ve programlanabilir.</span><span class="sxs-lookup"><span data-stu-id="220da-175">ThreadX has been certified by UL for compliance with UL 60730-1 Annex H, CSA E60730-1 Annex H, IEC 60730-1 Annex H, UL 60335-1 Annex R, IEC 60335-1 Annex R, and UL 1998 safety standards for software in programmable components.</span></span> <span data-ttu-id="220da-176">Ek H 'de "yazılım kullanan denetimler" için gereksinimleri olan ıEC/UL 60730-1 ile birlikte ıEC 60335-1 standardı, ek R. ıEC 60730 ek H ve ıEC 60335-1 ek R içindeki "programlanabilir elektronik devreler" için gereksinimleri açıklar. Örneğin, yıkama makineleri, dishörler, kurutma, kurutıcılar, freezers ve ovens gibi gereçlerde kullanılan MCU donanım ve yazılımlarının güvenliğini ele.</span><span class="sxs-lookup"><span data-stu-id="220da-176">Along with IEC/UL 60730-1, which has requirements for "Controls Using Software" in its Annex H, the IEC 60335-1 standard describes the requirements for "Programmable Electronic Circuits" in its Annex R. IEC 60730 Annex H and IEC 60335-1 Annex R address the safety of MCU hardware and software used in appliances such as washing machines, dishwashers, dryers, refrigerators, freezers, and ovens.</span></span>

![UL sertifikası](./media/overview-threadx/partener-logo-c-ru-us-2.png)

<span data-ttu-id="220da-178">*UL/ıEC 60730, UL/ıEC 60335, UL 1998*</span><span class="sxs-lookup"><span data-stu-id="220da-178">*UL/IEC 60730, UL/IEC 60335, UL 1998*</span></span>

> [!NOTE]
> <span data-ttu-id="220da-179">*Hangi ThreadX sürümleri TÜV veya test raporlarının, sertifikaların ve ilişkili belgelerin kullanılabilirliği hakkında daha fazla bilgi için lütfen Microsoft 'a başvurun.*</span><span class="sxs-lookup"><span data-stu-id="220da-179">*Please contact Microsoft for more information on which version(s) of ThreadX have been certified by TÜV or for the availability of test reports, certificates, and associated documentation.*</span></span>

### <a name="certification-pack"></a><span data-ttu-id="220da-180">Sertifika paketi</span><span class="sxs-lookup"><span data-stu-id="220da-180">Certification Pack</span></span>

<span data-ttu-id="220da-181">ThreadX sertifika paketi, &trade; threadx tabanlı ürünü, güvenlik açısından kritik meydan, tıp ve endüstriyel sistemler için gereken en yüksek güvenilirlik ve önem düzeyi düzeylerine göre onaylamak veya başarıyla göndermek için gereken tüm threadx kanıtını sağlayan, sektöre özgü, tek başına 100 bir pakettir.</span><span class="sxs-lookup"><span data-stu-id="220da-181">The ThreadX Certification Pack&trade; is a 100% complete, turnkey, industry-specific, stand-alone package that provides all of the ThreadX evidence needed to certify or successfully submit the ThreadX-based product to the highest reliability and criticality levels required for safety-critical Aviation, Medical, and Industrial systems.</span></span> <span data-ttu-id="220da-182">Desteklenen sertifika sertifikaları şunlardır-178B, ED-12B, DO-278, FDA510 (k), IEC62304, ıEC-60601, ISO-14971, UL-1998, ıEC-61508, CENELEC EN50128, BS50128 ve 49CFR236.</span><span class="sxs-lookup"><span data-stu-id="220da-182">Certifications supported include DO-178B, ED-12B, DO-278, FDA510(k), IEC62304, IEC-60601, ISO-14971, UL-1998, IEC-61508, CENELEC EN50128, BS50128, and 49CFR236.</span></span> <span data-ttu-id="220da-183">Sertifika paketi hakkında daha fazla bilgi için lütfen Microsoft 'a başvurun.</span><span class="sxs-lookup"><span data-stu-id="220da-183">Please contact Microsoft for more information on Certification Pack.</span></span>

## <a name="embedded-applications"></a><span data-ttu-id="220da-184">Katıştırılmış uygulamalar</span><span class="sxs-lookup"><span data-stu-id="220da-184">Embedded Applications</span></span>

<span data-ttu-id="220da-185">Katıştırılmış uygulamalar, kablosuz iletişim cihazları, Otomobil motorları, lazer yazıcılar, tıbbi cihazlar vb. gibi ürünlerde bulunan mikro işlemcilerde yürütülür. Katıştırılmış uygulamaların başka bir şekilde ayrımı, yazılım ve donanımının özel bir amaca sahip olması olabilir.</span><span class="sxs-lookup"><span data-stu-id="220da-185">Embedded applications execute on microprocessors buried within products such as wireless communication devices, automobile engines, laser printers, medical devices, etc. Another distinction of embedded applications is that their software and hardware have a dedicated purpose.</span></span>

### <a name="real-time-software"></a><span data-ttu-id="220da-186">Gerçek zamanlı yazılım</span><span class="sxs-lookup"><span data-stu-id="220da-186">Real-time Software</span></span>

<span data-ttu-id="220da-187">Uygulama yazılımına zaman kısıtlamaları eklendiğinde, *gerçek* zamanlı yazılım olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="220da-187">When time constraints are imposed on the application software, it is called the *real-time* software.</span></span> <span data-ttu-id="220da-188">Gömülü uygulamalar, dış olaylarla kendi kendine ait etkileşimlerinden dolayı neredeyse her zaman gerçek zamanlı olarak gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="220da-188">Embedded applications are almost always real-time because of their inherent interaction with external events.</span></span>

### <a name="multitasking"></a><span data-ttu-id="220da-189">Çok görevli</span><span class="sxs-lookup"><span data-stu-id="220da-189">Multitasking</span></span>

<span data-ttu-id="220da-190">Belirtildiği gibi, katıştırılmış uygulamaların adanmış bir amacı vardır.</span><span class="sxs-lookup"><span data-stu-id="220da-190">As mentioned, embedded applications have a dedicated purpose.</span></span> <span data-ttu-id="220da-191">Bu amacı karşılamak için, yazılımın çeşitli *Görevler* gerçekleştirmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="220da-191">To fulfill this purpose, the software must perform a variety of *tasks*.</span></span> <span data-ttu-id="220da-192">Görev, uygulamanın belirli bir vergileri yürüten yarı bir bağımsız bölümüdür.</span><span class="sxs-lookup"><span data-stu-id="220da-192">A task is a semi-independent portion of the application that carries out a specific duty.</span></span> <span data-ttu-id="220da-193">Ayrıca, bazı görevlerin diğerlerinden daha önemli olması da mümkündür.</span><span class="sxs-lookup"><span data-stu-id="220da-193">It is also the case that some tasks are more important than others.</span></span> <span data-ttu-id="220da-194">Katıştırılmış bir uygulamadaki önemli zorluklardaki bir tane, işlemcinin çeşitli uygulama görevleri arasında ayrılması.</span><span class="sxs-lookup"><span data-stu-id="220da-194">One of the major difficulties in an embedded application is the allocation of the processor between the various application tasks.</span></span> <span data-ttu-id="220da-195">Rekabet görevleri arasında bu işleme ayırma, ThreadX 'in birincil amacıdır.</span><span class="sxs-lookup"><span data-stu-id="220da-195">This allocation of processing between competing tasks is the primary purpose of ThreadX.</span></span>

### <a name="tasks-vs-threads"></a><span data-ttu-id="220da-196">Görevler ve Iş parçacıkları</span><span class="sxs-lookup"><span data-stu-id="220da-196">Tasks vs. Threads</span></span>

<span data-ttu-id="220da-197">Görevlerle ilgili başka bir ayrım, *görev* teriminin çok çeşitli yollarla kullanılmalarıdır.</span><span class="sxs-lookup"><span data-stu-id="220da-197">Another distinction about tasks is that the term *task* is used in a variety of ways.</span></span> <span data-ttu-id="220da-198">Bazen ayrı olarak yüklenebilir bir program anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="220da-198">It sometimes means a separately loadable program.</span></span> <span data-ttu-id="220da-199">Diğer örneklerde, bir iç program segmentine başvurabilir.</span><span class="sxs-lookup"><span data-stu-id="220da-199">In other instances, it may refer to an internal program segment.</span></span> <span data-ttu-id="220da-200">Bu nedenle, çağdaş işletim sistemlerinde görev kullanımını daha fazla veya daha az olan iki terim vardır: *işlem* ve *iş parçacığı*.</span><span class="sxs-lookup"><span data-stu-id="220da-200">Therefore, in contemporary operating systems, there are two terms that more or less replace the use of task: *process* and *thread*.</span></span> <span data-ttu-id="220da-201">*İşlem* , kendi adres alanına sahip tamamen bağımsız bir programdır, *iş parçacığı* bir işlem içinde yürüten yarı bağımsız bir program segmentleridir.</span><span class="sxs-lookup"><span data-stu-id="220da-201">A *process* is a completely independent program that has its own address space, while a *thread* is a semi-independent program segment that executes within a process.</span></span> <span data-ttu-id="220da-202">İş parçacıkları aynı işlem adres alanını paylaşır.</span><span class="sxs-lookup"><span data-stu-id="220da-202">Threads share the same process address space.</span></span> <span data-ttu-id="220da-203">İş parçacığı yönetimiyle ilişkili ek yük düşüktür.</span><span class="sxs-lookup"><span data-stu-id="220da-203">The overhead associated with thread management is minimal.</span></span>

<span data-ttu-id="220da-204">Çoğu gömülü uygulama, tam bir işlem odaklı işletim sistemiyle ilişkili ek yükü (hem bellek hem de performans) alamaz.</span><span class="sxs-lookup"><span data-stu-id="220da-204">Most embedded applications cannot afford the overhead (both memory and performance) associated with a full-blown process-oriented operating system.</span></span> <span data-ttu-id="220da-205">Ayrıca, daha küçük mikro işlemciler, doğru bir işlem odaklı işletim sistemini desteklemeye yönelik donanım mimarisine sahip değildir.</span><span class="sxs-lookup"><span data-stu-id="220da-205">In addition, smaller microprocessors don't have the hardware architecture to support a true process-oriented operating system.</span></span> <span data-ttu-id="220da-206">Bu nedenlerden dolayı, ThreadX gerçek zamanlı gömülü uygulamaların çoğu için son derece etkili ve pratik olan bir iş parçacığı modeli uygular.</span><span class="sxs-lookup"><span data-stu-id="220da-206">For these reasons, ThreadX implements a thread model, which is both extremely efficient and practical for most real-time embedded applications.</span></span>

<span data-ttu-id="220da-207">Karışıklık olmaması için ThreadX, *görevini* kullanmaz.</span><span class="sxs-lookup"><span data-stu-id="220da-207">To avoid confusion, ThreadX does not use the term *task*.</span></span> <span data-ttu-id="220da-208">Bunun yerine, daha açıklayıcı ve çağdaş ad *iş parçacığı* kullanılır.</span><span class="sxs-lookup"><span data-stu-id="220da-208">Instead, the more descriptive and contemporary name *thread* is used.</span></span>

## <a name="threadx-benefits"></a><span data-ttu-id="220da-209">ThreadX avantajları</span><span class="sxs-lookup"><span data-stu-id="220da-209">ThreadX Benefits</span></span>

<span data-ttu-id="220da-210">ThreadX kullanmak, gömülü uygulamalara birçok avantaj sağlar.</span><span class="sxs-lookup"><span data-stu-id="220da-210">Using ThreadX provides many benefits to embedded applications.</span></span> <span data-ttu-id="220da-211">Tabii ki, birincil avantaj, gömülü uygulama iş parçacıklarının işleme zamanına nasıl ayrıldığı üzerine oturacaktır.</span><span class="sxs-lookup"><span data-stu-id="220da-211">Of course, the primary benefit rests in how embedded application threads are allocated processing time.</span></span>

### <a name="improved-responsiveness"></a><span data-ttu-id="220da-212">İyileştirilmiş yanıt hızı</span><span class="sxs-lookup"><span data-stu-id="220da-212">Improved Responsiveness</span></span>

<span data-ttu-id="220da-213">ThreadX gibi gerçek zamanlı çekirdekler öncesinde, genellikle C *Main* işlevinin içinden bir basit denetim döngüsüyle, en çok eklenmiş uygulamalar işlem süresi ayırmıştır.</span><span class="sxs-lookup"><span data-stu-id="220da-213">Prior to real-time kernels like ThreadX, most embedded applications allocated processing time with a simple control loop, usually from within the C *main* function.</span></span> <span data-ttu-id="220da-214">Bu yaklaşım, çok küçük veya basit uygulamalarda kullanılmaya devam etmektedir.</span><span class="sxs-lookup"><span data-stu-id="220da-214">This approach is still used in very small or simple applications.</span></span> <span data-ttu-id="220da-215">Öte yandan, büyük veya karmaşık uygulamalarda, herhangi bir olaya yanıt süresi, denetim döngüsü boyunca bir geçiş işleminin en kötü durum işleme süresinin bir işlevi olduğundan pratik değildir.</span><span class="sxs-lookup"><span data-stu-id="220da-215">However, in large or complex applications, it is not practical because the response time to any event is a function of the worst case processing time of one pass through the control loop.</span></span> 

<span data-ttu-id="220da-216">Önemli hale getirmek, denetim döngüsünde değişiklik yapıldığında uygulamanın zamanlama özellikleri değişir.</span><span class="sxs-lookup"><span data-stu-id="220da-216">Making matters worse, the timing characteristics of the application change whenever modifications are made to the control loop.</span></span> <span data-ttu-id="220da-217">Bu, uygulamayı doğal olarak kararsız hale getirir ve üzerinde bakım ve iyileştirilmesine olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="220da-217">This makes the application inherently unstable and difficult to maintain and improve on.</span></span>

<span data-ttu-id="220da-218">ThreadX önemli dış olaylara hızlı ve belirleyici yanıt süreleri sağlar.</span><span class="sxs-lookup"><span data-stu-id="220da-218">ThreadX provides fast and deterministic response times to important external events.</span></span> <span data-ttu-id="220da-219">ThreadX bunu, daha yüksek öncelikli bir iş parçacığının yürütülen düşük öncelikli iş parçacığını sağlamasına izin veren preemptive, öncelik tabanlı zamanlama algoritması aracılığıyla gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="220da-219">ThreadX accomplishes this through its preemptive, priority based scheduling algorithm, which allows a higher priority thread to preempt an executing lower-priority thread.</span></span> <span data-ttu-id="220da-220">Sonuç olarak, en kötü durum yanıt süresi bir bağlam anahtarı gerçekleştirmek için gereken zamana yaklaşır.</span><span class="sxs-lookup"><span data-stu-id="220da-220">As a result, the worst-case response time approaches the time required to perform a context switch.</span></span> <span data-ttu-id="220da-221">Bu yalnızca belirleyici değildir, ancak son derece hızlıdır.</span><span class="sxs-lookup"><span data-stu-id="220da-221">This is not only deterministic, but it is also extremely fast.</span></span>

### <a name="software-maintenance"></a><span data-ttu-id="220da-222">Yazılım Bakımı</span><span class="sxs-lookup"><span data-stu-id="220da-222">Software Maintenance</span></span>

<span data-ttu-id="220da-223">ThreadX çekirdeği, uygulama geliştiricilerinin uygulamanın diğer alanlarının zamanlamasını değiştirme konusunda endişelenmenize gerek kalmadan uygulama iş parçacıklarının belirli gereksinimlerine odaklanmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="220da-223">The ThreadX kernel enables application developers to concentrate on specific requirements of their application threads without having to worry about changing the timing of other areas of the application.</span></span> <span data-ttu-id="220da-224">Bu özellik ayrıca ThreadX kullanan bir uygulamayı onarmayı veya geliştirmeyi çok daha kolay hale getiriyor.</span><span class="sxs-lookup"><span data-stu-id="220da-224">This feature also makes it much easier to repair or enhance an application that utilizes ThreadX.</span></span>

### <a name="increased-throughput"></a><span data-ttu-id="220da-225">Artan verimlilik</span><span class="sxs-lookup"><span data-stu-id="220da-225">Increased Throughput</span></span>

<span data-ttu-id="220da-226">Denetim döngüsü yanıt süresi sorununa yönelik olası bir iş, daha fazla yoklama eklemektir.</span><span class="sxs-lookup"><span data-stu-id="220da-226">A possible work-around to the control loop response time problem is to add more polling.</span></span> <span data-ttu-id="220da-227">Bu işlem, yanıt verme süresini iyileştirir, ancak yine de sabit bir en kötü durum yanıt süresi garantisi vermez ve uygulamanın gelecekteki bir şekilde değiştirilmesini artırmaya hiçbir şey yapmaz.</span><span class="sxs-lookup"><span data-stu-id="220da-227">This improves the responsiveness, but it still doesn't guarantee a constant worst-case response time and does nothing to enhance future modification of the application.</span></span> <span data-ttu-id="220da-228">Ayrıca, işlemci artık fazladan yoklama nedeniyle daha gereksiz işlemler gerçekleştiriyor.</span><span class="sxs-lookup"><span data-stu-id="220da-228">Also, the processor is now performing even more unnecessary processing because of the extra polling.</span></span> <span data-ttu-id="220da-229">Bu gereksiz işlemenin hepsi sistemin genel verimini azaltır.</span><span class="sxs-lookup"><span data-stu-id="220da-229">All of this unnecessary processing reduces the overall throughput of the system.</span></span>

<span data-ttu-id="220da-230">Ek yükün ilgi çekici bir noktası, birçok geliştiricinin ThreadX gibi çok iş parçacıklı ortamların yük yükünü artırdığı ve toplam sistem verimlilik üzerinde olumsuz bir etkiye sahip olduğunu varsaymaktadır.</span><span class="sxs-lookup"><span data-stu-id="220da-230">An interesting point regarding overhead is that many developers assume that multithreaded environments like ThreadX increase overhead and have a negative impact on total system throughput.</span></span> <span data-ttu-id="220da-231">Ancak bazı durumlarda, çoklu iş parçacığı denetim döngüsü ortamlarında oluşan tüm gereksiz yoklamayı ortadan kaldırarak yükü azaltır.</span><span class="sxs-lookup"><span data-stu-id="220da-231">But in some cases, multithreading actually reduces overhead by eliminating all of the redundant polling that occurs in control loop environments.</span></span> <span data-ttu-id="220da-232">Çok iş parçacıklı çekirdekler ile ilişkili ek yük, genellikle bağlam değiştirme için gereken sürenin bir işlevidir.</span><span class="sxs-lookup"><span data-stu-id="220da-232">The overhead associated with multithreaded kernels is typically a function of the time required for context switching.</span></span> <span data-ttu-id="220da-233">Bağlam anahtarı süresi yoklama sürecinden küçükse ThreadX, daha az ek yük ve daha fazla verimlilik sağlayan bir çözüm sağlar.</span><span class="sxs-lookup"><span data-stu-id="220da-233">If the context switch time is less than the polling process, ThreadX provides a solution with the potential of less overhead and more throughput.</span></span> <span data-ttu-id="220da-234">Bu, ThreadX ' i herhangi bir karmaşıklık veya boyut gerektiren uygulamalar için belirgin bir seçenek haline getirir.</span><span class="sxs-lookup"><span data-stu-id="220da-234">This makes ThreadX an obvious choice for applications that have any degree of complexity or size.</span></span>

### <a name="processor-isolation"></a><span data-ttu-id="220da-235">İşlemci yalıtımı</span><span class="sxs-lookup"><span data-stu-id="220da-235">Processor Isolation</span></span>

<span data-ttu-id="220da-236">ThreadX, uygulama ile temel alınan işlemci arasında sağlam bir işlemcinin bağımsız arabirimi sağlar.</span><span class="sxs-lookup"><span data-stu-id="220da-236">ThreadX provides a robust processor-independent interface between the application and the underlying processor.</span></span> <span data-ttu-id="220da-237">Bu, geliştiricilerin önemli miktarda zaman öğrenme donanım ayrıntıları harcamasını yerine uygulamaya odaklanmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="220da-237">This allows developers to concentrate on the application rather than spending a significant amount of time learning hardware details.</span></span>

### <a name="dividing-the-application"></a><span data-ttu-id="220da-238">Uygulamayı bölme</span><span class="sxs-lookup"><span data-stu-id="220da-238">Dividing the Application</span></span>

<span data-ttu-id="220da-239">Denetim döngüsü tabanlı uygulamalarda, her geliştiricinin tüm uygulamanın çalışma zamanı davranışı ve gereksinimleri hakkında bir intimate bilgisine sahip olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="220da-239">In control loop-based applications, each developer must have an intimate knowledge of the entire application's run-time behavior and requirements.</span></span> <span data-ttu-id="220da-240">Bunun nedeni, işlemci ayırma mantığının tüm uygulama genelinde yayılmasının nedeni.</span><span class="sxs-lookup"><span data-stu-id="220da-240">This is because the processor allocation logic is dispersed throughout the entire application.</span></span> <span data-ttu-id="220da-241">Bir uygulamanın boyutu veya karmaşıklığı arttıkça, tüm geliştiricilerin uygulamanın tamamına yönelik kesin işleme gereksinimlerini anımsamasını imkansız hale gelir.</span><span class="sxs-lookup"><span data-stu-id="220da-241">As an application increases in size or complexity, it becomes impossible for all developers to remember the precise processing requirements of the entire application.</span></span>

<span data-ttu-id="220da-242">ThreadX, her geliştiriciyi işlemci ayırması ile ilişkili olan worrıes 'nin serbest bırakır ve ekli uygulamanın belirli parçaları üzerinde yoğunlaşmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="220da-242">ThreadX frees each developer from the worries associated with processor allocation and allows them to concentrate on their specific piece of the embedded application.</span></span> <span data-ttu-id="220da-243">Ayrıca, ThreadX, uygulamayı açıkça tanımlanmış iş parçacığına bölünmeye zorlar.</span><span class="sxs-lookup"><span data-stu-id="220da-243">In addition, ThreadX forces the application to be divided into clearly defined threads.</span></span> <span data-ttu-id="220da-244">Tek başına, uygulamanın iş parçacıkları için bu bölümü geliştirmeyi çok daha kolay hale getirir.</span><span class="sxs-lookup"><span data-stu-id="220da-244">By itself, this division of the application into threads makes development much simpler.</span></span>

### <a name="ease-of-use"></a><span data-ttu-id="220da-245">Kullanım kolaylığı</span><span class="sxs-lookup"><span data-stu-id="220da-245">Ease of Use</span></span>

<span data-ttu-id="220da-246">ThreadX, uygulama geliştiricisi göz önünde bulundurularak tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="220da-246">ThreadX is designed with the application developer in mind.</span></span> <span data-ttu-id="220da-247">ThreadX mimarisi ve hizmet çağrısı arabirimi kolayca anlaşılması için tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="220da-247">The ThreadX architecture and service call interface are designed to be easily understood.</span></span> <span data-ttu-id="220da-248">Sonuç olarak, ThreadX geliştiricileri gelişmiş özelliklerini hızlı bir şekilde kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="220da-248">As a result, ThreadX developers can quickly use its advanced features.</span></span>

### <a name="improve-time-to-market"></a><span data-ttu-id="220da-249">Pazarlamaya ulaşma süresini geliştirme</span><span class="sxs-lookup"><span data-stu-id="220da-249">Improve Time-to-market</span></span>

<span data-ttu-id="220da-250">ThreadX 'in tüm avantajları yazılım geliştirme sürecini hızlandırır.</span><span class="sxs-lookup"><span data-stu-id="220da-250">All of the benefits of ThreadX accelerate the software development process.</span></span> <span data-ttu-id="220da-251">ThreadX, çoğu işlemci sorununu ve en sık karşılaşılan güvenlik sertifikalarını ve bu çabayı geliştirme zamanlamalarından kaldırır.</span><span class="sxs-lookup"><span data-stu-id="220da-251">ThreadX takes care of most processor issues and the most common safety certifications, thereby removing this effort from the development schedule.</span></span> <span data-ttu-id="220da-252">Tüm bu, pazara daha hızlı bir zaman sağlar!</span><span class="sxs-lookup"><span data-stu-id="220da-252">All of this results in a faster time to market!</span></span>

### <a name="protecting-the-software-investment"></a><span data-ttu-id="220da-253">Yazılım yatırımınızı koruma</span><span class="sxs-lookup"><span data-stu-id="220da-253">Protecting the Software Investment</span></span>

<span data-ttu-id="220da-254">Mimarinin mimarisi nedeniyle, ThreadX yeni işlemci ve/veya geliştirme aracı ortamlarına kolayca gönderilir.</span><span class="sxs-lookup"><span data-stu-id="220da-254">Because of its architecture, ThreadX is easily ported to new processor and/or development tool environments.</span></span> <span data-ttu-id="220da-255">Bu, ThreadX 'in uygulamaları temeldeki işlemcilerin ayrıntılarından yalıtılmış hale getiren olgusuna bağlı olarak, ThreadX uygulamalarının yüksek oranda taşınabilir olmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="220da-255">This, coupled with the fact that ThreadX insulates applications from details of the underlying processors, makes ThreadX applications highly portable.</span></span> <span data-ttu-id="220da-256">Sonuç olarak, uygulamanın geçiş yolu garanti edilir ve orijinal geliştirme yatırımı korunur.</span><span class="sxs-lookup"><span data-stu-id="220da-256">As a result, the application's migration path is guaranteed, and the original development investment is protected.</span></span>
