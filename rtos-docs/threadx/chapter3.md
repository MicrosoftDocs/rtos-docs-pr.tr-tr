---
title: Bölüm 3-Azure RTOS ThreadX 'in Işlevsel bileşenleri
description: Bu bölümde, işlevsel bir perspektiften yüksek performanslı Azure RTOS ThreadX çekirdeğinin açıklaması yer almaktadır.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: aa66ad392171958e5d2cc765992fd1a9e41250a6
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/22/2021
ms.locfileid: "104827371"
---
# <a name="chapter-3---functional-components-of-azure-rtos-threadx"></a><span data-ttu-id="f6dcf-103">Bölüm 3-Azure RTOS ThreadX 'in Işlevsel bileşenleri</span><span class="sxs-lookup"><span data-stu-id="f6dcf-103">Chapter 3 - Functional Components of Azure RTOS ThreadX</span></span>

<span data-ttu-id="f6dcf-104">Bu bölümde, işlevsel bir perspektiften yüksek performanslı Azure RTOS ThreadX çekirdeğinin açıklaması yer almaktadır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-104">This chapter contains a description of the high-performance Azure RTOS ThreadX kernel from a functional perspective.</span></span> <span data-ttu-id="f6dcf-105">Her işlevsel bileşen kolay anlaşılır bir şekilde sunulur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-105">Each functional component is presented in an easy-to-understand manner.</span></span>

## <a name="execution-overview"></a><span data-ttu-id="f6dcf-106">Yürütmeye genel bakış</span><span class="sxs-lookup"><span data-stu-id="f6dcf-106">Execution Overview</span></span>

<span data-ttu-id="f6dcf-107">Bir ThreadX uygulaması içinde dört tür program yürütme vardır: başlatma, Iş parçacığı yürütme, kesme hizmeti yordamları (IRS) ve uygulama zamanlayıcıları.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-107">There are four types of program execution within a ThreadX application: Initialization, Thread Execution, Interrupt Service Routines (ISRs), and Application Timers.</span></span>

<span data-ttu-id="f6dcf-108">Şekil 2 ' de her farklı program yürütme türü gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-108">Figure 2 shows each different type of program execution.</span></span> <span data-ttu-id="f6dcf-109">Bu bölümün sonraki bölümlerinde bu türlerin her biri hakkında daha ayrıntılı bilgi bulabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-109">More detailed information about each of these types is found in subsequent sections of this chapter.</span></span>

### <a name="initialization"></a><span data-ttu-id="f6dcf-110">Başlatma</span><span class="sxs-lookup"><span data-stu-id="f6dcf-110">Initialization</span></span>

<span data-ttu-id="f6dcf-111">Adından da anlaşılacağı gibi, bu, bir ThreadX uygulamasında program yürütmenin ilk türüdür.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-111">As the name implies, this is the first type of program execution in a ThreadX application.</span></span> <span data-ttu-id="f6dcf-112">Başlatma, işlemci sıfırlaması ve *iş parçacığı zamanlama döngüsünün* giriş noktası arasındaki tüm program yürütmesini içerir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-112">Initialization includes all program execution between processor reset and the entry point of the *thread scheduling loop.*</span></span>

### <a name="thread-execution"></a><span data-ttu-id="f6dcf-113">İş parçacığı yürütme</span><span class="sxs-lookup"><span data-stu-id="f6dcf-113">Thread Execution</span></span>

<span data-ttu-id="f6dcf-114">Başlatma tamamlandıktan sonra ThreadX iş parçacığı zamanlama döngüsüne girer.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-114">After initialization is complete, ThreadX enters its thread scheduling loop.</span></span> <span data-ttu-id="f6dcf-115">Zamanlama döngüsü, bir uygulama iş parçacığını yürütmeye hazırsa bakar.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-115">The scheduling loop looks for an application thread ready for execution.</span></span> <span data-ttu-id="f6dcf-116">Bir ready iş parçacığı bulunduğunda, ThreadX denetimi buna aktarır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-116">When a ready thread is found, ThreadX transfers control to it.</span></span> <span data-ttu-id="f6dcf-117">İş parçacığı tamamlandıktan sonra (veya daha yüksek öncelikli bir iş parçacığı hazır hale gelirse), yürütme sonraki en yüksek önceliğe hazır iş parçacığını bulmak için iş parçacığı zamanlama döngüsüne geri aktarılır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-117">After the thread is finished (or another higher-priority thread becomes ready), execution transfers back to the thread scheduling loop to find the next highest priority ready thread.</span></span>

<span data-ttu-id="f6dcf-118">İş parçacıklarını sürekli olarak yürüten ve zamanlıyor olan bu işlem, ThreadX uygulamalarında en yaygın program yürütme türüdür.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-118">This process of continually executing and scheduling threads is the most common type of program execution in ThreadX applications.</span></span>

### <a name="interrupt-service-routines-isr"></a><span data-ttu-id="f6dcf-119">Kesme hizmeti yordamları (ıSR)</span><span class="sxs-lookup"><span data-stu-id="f6dcf-119">Interrupt Service Routines (ISR)</span></span>

<span data-ttu-id="f6dcf-120">Kesmeler gerçek zamanlı sistemlerin temel taşıdır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-120">Interrupts are the cornerstone of real-time systems.</span></span> <span data-ttu-id="f6dcf-121">Kesmeler olmadan dış dünyadaki değişikliklere zamanında yanıt vermek son derece zor olur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-121">Without interrupts it would be extremely difficult to respond to changes in the external world in a timely manner.</span></span> <span data-ttu-id="f6dcf-122">Bir kesmeyi algılamada, İşlemci geçerli program yürütme (genellikle yığında) hakkındaki önemli bilgileri kaydeder ve sonra denetimi önceden tanımlanmış bir program alanına aktarır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-122">On detection of an interrupt, the processor saves key information about the current program execution (usually on the stack), then transfers control to a predefined program area.</span></span> <span data-ttu-id="f6dcf-123">Bu önceden tanımlanmış program alanı, genellikle bir kesme hizmeti yordamı olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-123">This predefined program area is commonly called an Interrupt Service Routine.</span></span> <span data-ttu-id="f6dcf-124">Çoğu durumda, iş parçacığı yürütme sırasında (veya iş parçacığı zamanlama döngüsünde) kesmeler oluşur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-124">In most cases, interrupts occur during thread execution (or in the thread scheduling loop).</span></span> <span data-ttu-id="f6dcf-125">Ancak, kesmeler yürütülen bir ıSR veya bir uygulama süreölçeri içinde de gerçekleşebilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-125">However, interrupts may also occur inside of an executing ISR or an Application Timer.</span></span>

![Program yürütme türleri](./media/user-guide/types-program-execution.png)

<span data-ttu-id="f6dcf-127">**ŞEKIL 2. Program yürütme türleri**</span><span class="sxs-lookup"><span data-stu-id="f6dcf-127">**FIGURE 2. Types of Program Execution**</span></span>

### <a name="application-timers"></a><span data-ttu-id="f6dcf-128">Uygulama zamanlayıcıları</span><span class="sxs-lookup"><span data-stu-id="f6dcf-128">Application Timers</span></span>

<span data-ttu-id="f6dcf-129">Uygulama Zamanlayıcılarına benzer şekilde, donanım uygulaması (genellikle tek bir düzenli donanım kesmesi kullanıldığında) uygulamadan gizlenir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-129">Application Timers are similar to ISRs, except the hardware implementation (usually a single periodic hardware interrupt is used) is hidden from the application.</span></span> <span data-ttu-id="f6dcf-130">Bu tür zamanlayıcılar, uygulamalar tarafından zaman aşımları, dönems ve/veya izleme hizmetleri gerçekleştirmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-130">Such timers are used by applications to perform time-outs, periodics, and/or watchdog services.</span></span> <span data-ttu-id="f6dcf-131">ISRs gibi, uygulama zamanlayıcılar çoğu zaman iş parçacığı yürütmeyi keser.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-131">Just like ISRs, Application Timers most often interrupt thread execution.</span></span> <span data-ttu-id="f6dcf-132">Ancak, IRS 'nin aksine, uygulama zamanlayıcıları birbirini kesintiye uğratabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-132">Unlike ISRs, however, Application Timers cannot interrupt each other.</span></span>

## <a name="memory-usage"></a><span data-ttu-id="f6dcf-133">Bellek Kullanımı</span><span class="sxs-lookup"><span data-stu-id="f6dcf-133">Memory Usage</span></span>

<span data-ttu-id="f6dcf-134">ThreadX, uygulama programıyla birlikte bulunur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-134">ThreadX resides along with the application program.</span></span> <span data-ttu-id="f6dcf-135">Sonuç olarak, ThreadX 'in statik bellek (veya sabit bellek) kullanımı geliştirme araçları tarafından belirlenir; Örneğin, derleyici, bağlayıcı ve bulucu.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-135">As a result, the static memory (or fixed memory) usage of ThreadX is determined by the development tools; e.g., the compiler, linker, and locator.</span></span> <span data-ttu-id="f6dcf-136">Dinamik bellek (veya çalışma zamanı belleği) kullanımı, uygulamanın doğrudan denetimi altındadır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-136">Dynamic memory (or run-time memory) usage is under direct control of the application.</span></span>

### <a name="static-memory-usage"></a><span data-ttu-id="f6dcf-137">Statik bellek kullanımı</span><span class="sxs-lookup"><span data-stu-id="f6dcf-137">Static Memory Usage</span></span>

<span data-ttu-id="f6dcf-138">Geliştirme araçlarının çoğu, uygulama programı görüntüsünü beş temel alana böler: *yönerge*, *sabit*, *başlatılan veriler*, *başlatılmamış veriler* ve *Sistem yığını*.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-138">Most of the development tools divide the application program image into five basic areas: *instruction*, *constant*, *initialized data*, *uninitialized data*, and *system stack*.</span></span> <span data-ttu-id="f6dcf-139">Şekil 3 ' te bu bellek alanlarının bir örneği gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-139">Figure 3 shows an example of these memory areas.</span></span>

<span data-ttu-id="f6dcf-140">Bunun yalnızca bir örnek olduğunu anlamak önemlidir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-140">It is important to understand that this is only an example.</span></span> <span data-ttu-id="f6dcf-141">Gerçek statik bellek düzeni işlemci, geliştirme araçları ve temel alınan donanıma özeldir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-141">The actual static memory layout is specific to the processor, development tools, and the underlying hardware.</span></span>

<span data-ttu-id="f6dcf-142">Yönerge alanı, programın işlemci yönergelerini içerir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-142">The instruction area contains all of the program's processor instructions.</span></span> <span data-ttu-id="f6dcf-143">Bu alan genellikle en büyüktür ve genellikle ROM ' da bulunur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-143">This area is typically the largest and is often located in ROM.</span></span>

<span data-ttu-id="f6dcf-144">Sabit alan, program içinde tanımlanan veya başvurulan dizeler dahil olmak üzere çeşitli derlenmiş sabitler içerir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-144">The constant area contains various compiled constants, including strings defined or referenced within the program.</span></span> <span data-ttu-id="f6dcf-145">Ayrıca, bu alan başlatılan veri alanının "ilk kopyasını" içerir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-145">In addition, this area contains the "initial copy" of the initialized data area.</span></span> <span data-ttu-id="f6dcf-146">*Bellek kullanımı* derleyicisinin başlatma işlemi sırasında, sabit alanın bu bölümü RAM 'de başlatılmış veri alanını ayarlamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-146">During the *Memory Usage* compiler's initialization process, this portion of the constant area is used to set up the initialized data area in RAM.</span></span> <span data-ttu-id="f6dcf-147">Sabit alan genellikle yönerge alanını izler ve genellikle ROM 'da bulunur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-147">The constant area usually follows the instruction area and is often located in ROM.</span></span>

<span data-ttu-id="f6dcf-148">Başlatılmış veriler ve başlatılmamış veri alanlarında tüm genel ve statik değişkenler bulunur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-148">The initialized data and uninitialized data areas contain all of the global and static variables.</span></span> <span data-ttu-id="f6dcf-149">Bu bölgeler her zaman RAM olarak bulunur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-149">These areas are always located in RAM.</span></span>

<span data-ttu-id="f6dcf-150">Sistem yığını genellikle başlatılmış ve başlatılmamış veri alanlarından hemen sonra ayarlanır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-150">The system stack is generally set up immediately following the initialized and uninitialized data areas.</span></span>

<span data-ttu-id="f6dcf-151">Sistem yığını başlatma sırasında derleyici tarafından, başlatma sırasında ThreadX ve daha sonra ıSR işleminde kullanılır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-151">The system stack is used by the compiler during initialization, then by ThreadX during initialization and, subsequently, in ISR processing.</span></span>

![Bellek alanı örneği](./media/user-guide/memory-area-example.png)

<span data-ttu-id="f6dcf-153">**ŞEKIL 3. Bellek alanı örneği**</span><span class="sxs-lookup"><span data-stu-id="f6dcf-153">**FIGURE 3. Memory Area Example**</span></span>

### <a name="dynamic-memory-usage"></a><span data-ttu-id="f6dcf-154">Dinamik Bellek kullanımı</span><span class="sxs-lookup"><span data-stu-id="f6dcf-154">Dynamic Memory Usage</span></span>

<span data-ttu-id="f6dcf-155">Daha önce belirtildiği gibi, dinamik bellek kullanımı uygulamanın doğrudan denetimi altındadır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-155">As mentioned before, dynamic memory usage is under direct control of the application.</span></span> <span data-ttu-id="f6dcf-156">Yığınlar, kuyruklar ve bellek havuzlarıyla ilişkili denetim blokları ve bellek alanları, hedefin bellek alanında herhangi bir yere yerleştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-156">Control blocks and memory areas associated with stacks, queues, and memory pools can be placed anywhere in the target's memory space.</span></span> <span data-ttu-id="f6dcf-157">Bu önemli bir özelliktir çünkü farklı türlerdeki fiziksel belleğin kolay kullanımını kolaylaştırır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-157">This is an important feature because it facilitates easy utilization of different types of physical memory.</span></span>

<span data-ttu-id="f6dcf-158">Örneğin, bir hedef donanım ortamının hem hızlı bellek hem de yavaş bellek olduğunu varsayalım.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-158">For example, suppose a target hardware environment has both fast memory and slow memory.</span></span> <span data-ttu-id="f6dcf-159">Uygulamanın yüksek öncelikli bir iş parçacığı için ek performansa ihtiyacı varsa, denetim bloğu (TX_THREAD) ve Stack hızlı bellek alanına yerleştirilebilir ve bu da performansını önemli ölçüde geliştirebilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-159">If the application needs extra performance for a high-priority thread, its control block (TX_THREAD) and stack can be placed in the fast memory area, which may greatly enhance its performance.</span></span>

## <a name="initialization"></a><span data-ttu-id="f6dcf-160">Başlatma</span><span class="sxs-lookup"><span data-stu-id="f6dcf-160">Initialization</span></span>

<span data-ttu-id="f6dcf-161">Başlatma işlemini anlamak önemlidir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-161">Understanding the initialization process is important.</span></span> <span data-ttu-id="f6dcf-162">İlk donanım ortamı burada ayarlanır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-162">The initial hardware environment is set up here.</span></span> <span data-ttu-id="f6dcf-163">Buna ek olarak, uygulama ilk kişiliğine verilirler.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-163">In addition, this is where the application is given its initial personality.</span></span>

> [!NOTE]
> <span data-ttu-id="f6dcf-164">*ThreadX, tüm geliştirme aracının başlatma sürecini (mümkün olduğunda) kullanmaya çalışır. Bu, gelecekte geliştirme araçlarının yeni sürümlerine yükseltmeyi kolaylaştırır.*</span><span class="sxs-lookup"><span data-stu-id="f6dcf-164">*ThreadX attempts to utilize (whenever possible) the complete development tool's initialization process. This makes it easier to upgrade to new versions of the development tools in the future.*</span></span>

### <a name="system-reset-vector"></a><span data-ttu-id="f6dcf-165">Sistem sıfırlama vektörü</span><span class="sxs-lookup"><span data-stu-id="f6dcf-165">System Reset Vector</span></span>

<span data-ttu-id="f6dcf-166">Tüm mikro işlemcilerin sıfırlama mantığı vardır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-166">All microprocessors have reset logic.</span></span> <span data-ttu-id="f6dcf-167">Bir sıfırlama gerçekleştiğinde (donanım ya da yazılım), uygulamanın giriş noktasının adresi belirli bir bellek konumundan alınır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-167">When a reset occurs (either hardware or software), the address of the application's entry point is retrieved from a specific memory location.</span></span> <span data-ttu-id="f6dcf-168">Giriş noktası alındıktan sonra, işlemci denetimi bu konuma aktarır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-168">After the entry point is retrieved, the processor transfers control to that location.</span></span> <span data-ttu-id="f6dcf-169">Uygulama giriş noktası genellikle yerel derleme dilinde yazılır ve genellikle geliştirme araçları (en azından şablon biçiminde) tarafından sağlanır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-169">The application entry point is quite often written in the native assembly language and is usually supplied by the development tools (at least in template form).</span></span> <span data-ttu-id="f6dcf-170">Bazı durumlarda, bir giriş programının özel bir sürümü ThreadX ile birlikte sağlanır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-170">In some cases, a special version of the entry program is supplied with ThreadX.</span></span>

### <a name="development-tool-initialization"></a><span data-ttu-id="f6dcf-171">Geliştirme aracı başlatma</span><span class="sxs-lookup"><span data-stu-id="f6dcf-171">Development Tool Initialization</span></span>

<span data-ttu-id="f6dcf-172">Düşük düzey başlatma işlemi tamamlandıktan sonra, geliştirme aracının üst düzey başlatmasına yönelik denetimleri aktarır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-172">After the low-level initialization is complete, control transfers to the development tool's high-level initialization.</span></span> <span data-ttu-id="f6dcf-173">Bu genellikle başlatılmış Global ve statik C değişkenlerinin ayarlandığı yerdir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-173">This is usually the place where initialized global and static C variables are set up.</span></span> <span data-ttu-id="f6dcf-174">İlk değerlerinin sabit alandan alındığını unutmayın.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-174">Remember their initial values are retrieved from the constant area.</span></span> <span data-ttu-id="f6dcf-175">Tam başlatma işlemi, geliştirme aracına özgüdür.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-175">Exact initialization processing is development tool specific.</span></span>

### <a name="main-function"></a><span data-ttu-id="f6dcf-176">Main Işlevi</span><span class="sxs-lookup"><span data-stu-id="f6dcf-176">main Function</span></span>

<span data-ttu-id="f6dcf-177">Geliştirme aracı başlatması tamamlandığında, Kullanıcı tarafından sağlanan *ana* işleve yapılan aktarımları denetler.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-177">When the development tool initialization is complete, control transfers to the user-supplied *main* function.</span></span> <span data-ttu-id="f6dcf-178">Bu noktada, uygulama ileri ' yi denetler.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-178">At this point, the application controls what happens next.</span></span> <span data-ttu-id="f6dcf-179">Çoğu uygulama için, Main işlevi yalnızca ThreadX girişi olan *tx_kernel_enter* çağırır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-179">For most applications, the main function simply calls *tx_kernel_enter*, which is the entry into ThreadX.</span></span> <span data-ttu-id="f6dcf-180">Ancak, uygulamalar, ThreadX girmeden önce ön işleme (genellikle donanım başlatma için) gerçekleştirebilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-180">However, applications can perform preliminary processing (usually for hardware initialization) prior to entering ThreadX.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f6dcf-181">*Tx_kernel_enter çağrısı döndürmez, bu nedenle işlemden sonra herhangi bir işlem yerleştirmeyin.*</span><span class="sxs-lookup"><span data-stu-id="f6dcf-181">*The call to tx_kernel_enter does not return, so do not place any processing after it.*</span></span>

### <a name="tx_kernel_enter"></a><span data-ttu-id="f6dcf-182">tx_kernel_enter</span><span class="sxs-lookup"><span data-stu-id="f6dcf-182">tx_kernel_enter</span></span>

<span data-ttu-id="f6dcf-183">Giriş işlevi, çeşitli iç ThreadX veri yapılarının başlatılmasını koordine eder ve ardından uygulamanın tanım işlevini ***tx_application_define*** çağırır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-183">The entry function coordinates initialization of various internal ThreadX data structures and then calls the application's definition function ***tx_application_define***.</span></span>

<span data-ttu-id="f6dcf-184">***Tx_application_define*** döndüğünde denetim iş parçacığı zamanlama döngüsüne aktarılır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-184">When ***tx_application_define*** returns, control is transferred to the thread scheduling loop.</span></span> <span data-ttu-id="f6dcf-185">Bu, başlatma sonunu işaretler.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-185">This marks the end of initialization.</span></span>

### <a name="application-definition-function"></a><span data-ttu-id="f6dcf-186">Uygulama tanımı Işlevi</span><span class="sxs-lookup"><span data-stu-id="f6dcf-186">Application Definition Function</span></span>

<span data-ttu-id="f6dcf-187">***Tx_application_define*** işlevi, tüm ilk uygulama iş parçacıkları, kuyruklar, Semaforlar, zaman uyumu sağlayıcılar, olay bayrakları, bellek havuzları ve zamanlayıcılar tanımlar.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-187">The ***tx_application_define*** function defines all of the initial application threads, queues, semaphores, mutexes, event flags, memory pools, and timers.</span></span> <span data-ttu-id="f6dcf-188">Uygulamanın normal işlemi sırasında iş parçacıklarında sistem kaynakları oluşturmak ve silmek de mümkündür.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-188">It is also possible to create and delete system resources from threads during the normal operation of the application.</span></span> <span data-ttu-id="f6dcf-189">Ancak, tüm ilk uygulama kaynakları burada tanımlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-189">However, all initial application resources are defined here.</span></span>

<span data-ttu-id="f6dcf-190">\***Tx_application_define** _ işlevinin tek bir giriş parametresi vardır ve bu parametre kesinlikle önemlidir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-190">The \***tx_application_define** _ function has a single input parameter and it is certainly worth mentioning.</span></span> <span data-ttu-id="f6dcf-191">_First kullanılabilir \* RAM adresi, bu işleve yönelik tek giriş parametresidir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-191">The _first-available\* RAM address is the sole input parameter to this function.</span></span> <span data-ttu-id="f6dcf-192">Genellikle iş parçacığı yığınlarının, kuyruklarının ve bellek havuzlarının ilk çalışma zamanı bellek ayırmaları için başlangıç noktası olarak kullanılır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-192">It is typically used as a starting point for initial run-time memory allocations of thread stacks, queues, and memory pools.</span></span>

> [!NOTE]
> <span data-ttu-id="f6dcf-193">*Başlatma tamamlandıktan sonra, yalnızca bir çalışan iş parçacığı, diğer iş parçacıkları dahil olmak üzere sistem kaynaklarını oluşturabilir ve silebilir. Bu nedenle, başlatma sırasında en az bir iş parçacığının oluşturulması gerekir.*</span><span class="sxs-lookup"><span data-stu-id="f6dcf-193">*After initialization is complete, only an executing thread can create and delete system resources— including other threads. Therefore, at least one thread must be created during initialization.*</span></span>

### <a name="interrupts"></a><span data-ttu-id="f6dcf-194">Kesmelerini</span><span class="sxs-lookup"><span data-stu-id="f6dcf-194">Interrupts</span></span>

<span data-ttu-id="f6dcf-195">Kesmeler, başlatma işleminin tamamı sırasında devre dışı bırakılır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-195">Interrupts are left disabled during the entire initialization process.</span></span> <span data-ttu-id="f6dcf-196">Uygulama kesintiye yol açabilir, öngörülemeyen bir davranış meydana gelebilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-196">If the application somehow enables interrupts, unpredictable behavior may occur.</span></span> <span data-ttu-id="f6dcf-197">Şekil 4 ' te, uygulama özel başlatma aracılığıyla sistem sıfırlamalarından başlatma işleminin tamamı gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-197">Figure 4 shows the entire initialization process, from system reset through application-specific initialization.</span></span>

## <a name="thread-execution"></a><span data-ttu-id="f6dcf-198">İş parçacığı yürütme</span><span class="sxs-lookup"><span data-stu-id="f6dcf-198">Thread Execution</span></span>

<span data-ttu-id="f6dcf-199">Uygulama iş parçacıklarını zamanlama ve yürütme, ThreadX 'in en önemli etkinliğidir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-199">Scheduling and executing application threads is the most important activity of ThreadX.</span></span> <span data-ttu-id="f6dcf-200">İş parçacığı genellikle adanmış bir amaçla yarı bağımsız program segmenti olarak tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-200">A thread is typically defined as a semi-independent program segment with a dedicated purpose.</span></span> <span data-ttu-id="f6dcf-201">Tüm iş parçacıklarının birleştirilmiş işleme bir uygulama oluşturur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-201">The combined processing of all threads makes an application.</span></span>

<span data-ttu-id="f6dcf-202">İş parçacıkları, başlatma sırasında veya iş parçacığı yürütme sırasında \***tx_thread_create** _ çağırarak dinamik olarak oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-202">Threads are created dynamically by calling \***tx_thread_create** _ during initialization or during thread execution.</span></span> <span data-ttu-id="f6dcf-203">İş parçacıkları _ready \* veya *askıya alınma* durumunda oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-203">Threads are created in either a _ready\* or *suspended* state.</span></span>

![Başlatma Işlemi](./media/user-guide/initialization-process.png)

<span data-ttu-id="f6dcf-205">**ŞEKIL 4. Başlatma Işlemi**</span><span class="sxs-lookup"><span data-stu-id="f6dcf-205">**FIGURE 4. Initialization Process**</span></span>

### <a name="thread-execution-states"></a><span data-ttu-id="f6dcf-206">İş parçacığı yürütme durumları</span><span class="sxs-lookup"><span data-stu-id="f6dcf-206">Thread Execution States</span></span>

<span data-ttu-id="f6dcf-207">İş parçacıklarının farklı işleme durumlarını anlamak, çok iş parçacıklı ortamın tamamını anlamak için önemli bir ortamdır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-207">Understanding the different processing states of threads is a key ingredient to understanding the entire multithreaded environment.</span></span> <span data-ttu-id="f6dcf-208">ThreadX 'de, beş farklı iş parçacığı durumu vardır: *hazırlanıyor*, *askıya alındı*, *yürütülüyor*, *sonlandırıldı* ve *tamamlandı*.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-208">In ThreadX there are five distinct thread states: *ready*, *suspended*, *executing*, *terminated*, and *completed*.</span></span> <span data-ttu-id="f6dcf-209">Şekil 5 ' te ThreadX iş parçacığı durum geçişi diyagramı gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-209">Figure 5 shows the thread state transition diagram for ThreadX.</span></span>

![İş parçacığı durum geçişi](./media/user-guide/thread-state-transition.png)

<span data-ttu-id="f6dcf-211">**ŞEKIL 5. İş parçacığı durum geçişi**</span><span class="sxs-lookup"><span data-stu-id="f6dcf-211">**FIGURE 5. Thread State Transition**</span></span>

<span data-ttu-id="f6dcf-212">İş parçacığı, yürütülmeye hazırlanmaya hazırsa, *hazırlık* durumundadır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-212">A thread is in a *ready* state when it is ready for execution.</span></span> <span data-ttu-id="f6dcf-213">Hazırlık durumunda en yüksek öncelikli iş parçacığı olana kadar, Ready iş parçacığı yürütülmez.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-213">A ready thread is not executed until it is the highest priority thread in ready state.</span></span> <span data-ttu-id="f6dcf-214">Bu durumda, ThreadX iş parçacığını yürütür ve sonra durumunu *yürütülüyor* olarak değiştirir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-214">When this happens, ThreadX executes the thread, which then changes its state to *executing*.</span></span>

<span data-ttu-id="f6dcf-215">Daha yüksek öncelikli bir iş parçacığı hazır hale gelirse, çalıştırılan iş parçacığı *hazır* duruma geri döner.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-215">If a higher-priority thread becomes ready, the executing thread reverts back to a *ready* state.</span></span> <span data-ttu-id="f6dcf-216">Daha sonra yeni, yüksek öncelikli iş parçacığı yürütülür ve bu, mantıksal durumu *yürütülüyor* olarak değiştirir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-216">The newly ready high-priority thread is then executed, which changes its logical state to *executing*.</span></span> <span data-ttu-id="f6dcf-217">Hazırlama *ve* *yürütme* durumları arasındaki bu geçiş, iş parçacığı önalım her gerçekleştiğinde oluşur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-217">This transition between *ready* and *executing* states occurs every time thread preemption occurs.</span></span>

<span data-ttu-id="f6dcf-218">Herhangi bir anda yalnızca bir iş parçacığı *yürütülüyor* durumundadır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-218">At any given moment, only one thread is in an *executing* state.</span></span> <span data-ttu-id="f6dcf-219">Bunun nedeni, *yürütme* durumundaki bir iş parçacığının temeldeki işlemcinin denetimine sahip olmasından kaynaklanır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-219">This is because a thread in the *executing* state has control of the underlying processor.</span></span>

<span data-ttu-id="f6dcf-220">*Askıya alınmış* durumdaki iş parçacıkları yürütme için uygun değildir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-220">Threads in a *suspended* state are not eligible for execution.</span></span> <span data-ttu-id="f6dcf-221">*Askıya* alınma durumunda olma nedenleri, zaman, kuyruk iletileri, Semaforlar, zaman uyumu sağlayıcılar, olay bayrakları, bellek ve temel iş parçacığı askıya alma için askıya alma içerir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-221">Reasons for being in a *suspended* state include suspension for time, queue messages, semaphores, mutexes, event flags, memory, and basic thread suspension.</span></span> <span data-ttu-id="f6dcf-222">Askıya alma *işlemine* neden kaldırıldıktan sonra, iş parçacığı, hazırlama durumuna geri yerleştirilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-222">After the cause for suspension is removed, the thread is placed back in a *ready* state.</span></span>

<span data-ttu-id="f6dcf-223">*Tamamlanmış* durumdaki bir iş parçacığı, işlemini tamamlamış ve giriş işlevinden döndürülen bir iş parçacığıdır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-223">A thread in a *completed* state is a thread that has completed its processing and returned from its entry function.</span></span> <span data-ttu-id="f6dcf-224">Giriş işlevi iş parçacığı oluşturma sırasında belirtilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-224">The entry function is specified during thread creation.</span></span> <span data-ttu-id="f6dcf-225">*Tamamlanmış* durumdaki bir iş parçacığı yeniden çalıştırılamaz.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-225">A thread in a *completed* state cannot execute again.</span></span>

<span data-ttu-id="f6dcf-226">Başka bir iş parçacığı veya iş parçacığının kendisi *tx_thread_terminate* hizmeti olarak adlandırıldığından, iş parçacığı *sonlandırılmış* durumda olur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-226">A thread is in a *terminated* state because another thread or the thread itself called the *tx_thread_terminate* service.</span></span> <span data-ttu-id="f6dcf-227">*Sonlandırılmış* durumdaki bir iş parçacığı yeniden çalıştırılamaz.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-227">A thread in a *terminated* state cannot execute again.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f6dcf-228">*Tamamlanmış veya sonlandırılmış bir iş parçacığının yeniden başlatılması istenirse, uygulamanın iş parçacığını silmesi gerekir. Daha sonra yeniden oluşturulup yeniden başlatılabilir.*</span><span class="sxs-lookup"><span data-stu-id="f6dcf-228">*If re-starting a completed or terminated thread is desired, the application must first delete the thread. It can then be re-created and re-started.*</span></span>

### <a name="thread-entryexit-notification"></a><span data-ttu-id="f6dcf-229">İş parçacığı giriş/çıkış bildirimi</span><span class="sxs-lookup"><span data-stu-id="f6dcf-229">Thread Entry/Exit Notification</span></span>

<span data-ttu-id="f6dcf-230">Bazı uygulamalar, belirli bir iş parçacığının ilk kez girildiği, tamamlandığında veya sonlandırıldığı zaman bildirilmeye yönelik avantajı bulabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-230">Some applications may find it advantageous to be notified when a specific thread is entered for the first time, when it completes, or is terminated.</span></span> <span data-ttu-id="f6dcf-231">ThreadX, ***tx_thread_entry_exit_notify*** hizmeti aracılığıyla bu yeteneği sağlar.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-231">ThreadX provides this ability through the ***tx_thread_entry_exit_notify*** service.</span></span> <span data-ttu-id="f6dcf-232">Bu hizmet, iş parçacığı çalışmaya başladığında, tamamlandığında veya sonlandırıldığı zaman, ThreadX tarafından çağrılan belirli bir iş parçacığı için bir uygulama bildirim işlevi kaydeder.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-232">This service registers an application notification function for a specific thread, which is called by ThreadX whenever the thread starts running, completes, or is terminated.</span></span> <span data-ttu-id="f6dcf-233">Çağrıldıktan sonra, uygulama bildirim işlevi uygulamaya özgü işlemleri gerçekleştirebilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-233">After being invoked, the application notification function can perform the application-specific processing.</span></span> <span data-ttu-id="f6dcf-234">Bu genellikle, bir ThreadX eşitleme temel aracılığıyla olayın başka bir uygulama iş parçacığını bilgilendirmektir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-234">This typically involves informing another application thread of the event via a ThreadX synchronization primitive.</span></span>

### <a name="thread-priorities"></a><span data-ttu-id="f6dcf-235">İş parçacığı öncelikleri</span><span class="sxs-lookup"><span data-stu-id="f6dcf-235">Thread Priorities</span></span>

<span data-ttu-id="f6dcf-236">Daha önce bahsedildiği gibi, iş parçacığı adanmış bir amaca sahip yarı bağımsız bir program segmentine sahip olur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-236">As mentioned before, a thread is a semi-independent program segment with a dedicated purpose.</span></span> <span data-ttu-id="f6dcf-237">Ancak, tüm iş parçacıkları eşit olarak oluşturulmaz!</span><span class="sxs-lookup"><span data-stu-id="f6dcf-237">However, all threads are not created equal!</span></span> <span data-ttu-id="f6dcf-238">Bazı iş parçacıklarının adanmış amacı diğerlerine göre çok daha önemlidir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-238">The dedicated purpose of some threads is much more important than others.</span></span> <span data-ttu-id="f6dcf-239">Bu heterojen iş parçacığı önemi türü, gömülü gerçek zamanlı uygulamaların bir Hallmark.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-239">This heterogeneous type of thread importance is a hallmark of embedded realtime applications.</span></span>

<span data-ttu-id="f6dcf-240">ThreadX, *önceliğini* temsil eden bir sayısal değer atanarak iş parçacığı oluşturulduğu zaman bir iş parçacığının önemini belirler.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-240">ThreadX determines a thread's importance when the thread is created by assigning a numerical value representing its *priority*.</span></span> <span data-ttu-id="f6dcf-241">En fazla ThreadX öncelik sayısı, 32 ile 1024 arasında 32 arasında yapılandırılabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-241">The maximum number of ThreadX priorities is configurable from 32 through 1024 in increments of 32.</span></span> <span data-ttu-id="f6dcf-242">Fiili en fazla öncelik sayısı, ThreadX kitaplığı derlenirken **TX_MAX_PRIORITIES** sabiti tarafından belirlenir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-242">The actual maximum number of priorities is determined by the **TX_MAX_PRIORITIES** constant during compilation of the ThreadX library.</span></span> <span data-ttu-id="f6dcf-243">Daha fazla sayıda öncelik olması, işleme ek yükünü önemli ölçüde artırmaz.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-243">Having a larger number of priorities does not significantly increase processing overhead.</span></span> <span data-ttu-id="f6dcf-244">Ancak, her 32 öncelik düzeyindeki bir grup için, bunları yönetmek için ek 128 baytlık RAM gerekir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-244">However, for each group of 32 priority levels an additional 128 bytes of RAM is required to manage them.</span></span> <span data-ttu-id="f6dcf-245">Örneğin, 32 öncelik düzeyleri 128 bayt RAM gerektirir, 64 öncelik düzeyi 256 bayt RAM gerektirir ve 96 öncelik düzeyleri, 384 bayt RAM gerektirir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-245">For example, 32 priority levels require 128 bytes of RAM, 64 priority levels require 256 bytes of RAM, and 96 priority levels requires 384 bytes of RAM.</span></span>

<span data-ttu-id="f6dcf-246">Varsayılan olarak, ThreadX 32 öncelik düzeylerine sahiptir ve öncelik 0 ile öncelik 31 arasında değişir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-246">By default, ThreadX has 32 priority levels, ranging from priority 0 through priority 31.</span></span> <span data-ttu-id="f6dcf-247">Sayısal olarak daha küçük değerler daha yüksek önceliğe sahiptir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-247">Numerically smaller values imply higher priority.</span></span> <span data-ttu-id="f6dcf-248">Bu nedenle öncelik 0 en yüksek önceliği temsil ederken öncelik (**TX_MAX_PRIORITIES**-1) en düşük önceliği temsil eder.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-248">Hence, priority 0 represents the highest priority, while priority (**TX_MAX_PRIORITIES**-1) represents the lowest priority.</span></span>

<span data-ttu-id="f6dcf-249">Birden çok iş parçacığı, ortak zamanlamaya göre veya zaman dilimlemeye bağlı olarak aynı önceliğe sahip olabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-249">Multiple threads can have the same priority relying on cooperative scheduling or time-slicing.</span></span> <span data-ttu-id="f6dcf-250">Ayrıca, iş parçacığı öncelikleri çalışma zamanı sırasında değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-250">In addition, thread priorities can be changed during run-time.</span></span>

### <a name="thread-scheduling"></a><span data-ttu-id="f6dcf-251">İş parçacığı zamanlaması</span><span class="sxs-lookup"><span data-stu-id="f6dcf-251">Thread Scheduling</span></span>

<span data-ttu-id="f6dcf-252">ThreadX iş parçacıklarını önceliklerine göre zamanlar.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-252">ThreadX schedules threads based on their priority.</span></span> <span data-ttu-id="f6dcf-253">En yüksek önceliğe sahip olan Ready iş parçacığı önce yürütülür.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-253">The ready thread with the highest priority is executed first.</span></span> <span data-ttu-id="f6dcf-254">Aynı önceliğe sahip birden çok iş parçacığı hazır ise, ilk *çıkar* (FIFO) şekilde yürütülür.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-254">If multiple threads of the same priority are ready, they are executed in a *first-in-first-out* (FIFO) manner.</span></span>

### <a name="round-robin-scheduling"></a><span data-ttu-id="f6dcf-255">Hepsini bir kez deneme zamanlaması</span><span class="sxs-lookup"><span data-stu-id="f6dcf-255">Round-robin Scheduling</span></span>

<span data-ttu-id="f6dcf-256">ThreadX, aynı önceliğe sahip birden çok iş parçacığının *hepsini bir kez deneme* zamanlamasını destekler.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-256">ThreadX supports *round-robin* scheduling of multiple threads having the same priority.</span></span> <span data-ttu-id="f6dcf-257">Bu, \***tx_thread_relinquish** _ öğesine yönelik birlikte gerçekleştirilen çağrılar aracılığıyla gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-257">This is accomplished through cooperative calls to \***tx_thread_relinquish** _.</span></span> <span data-ttu-id="f6dcf-258">Bu hizmet, _ *_tx_thread_relinquish_*\* çağıranı yeniden yürütmeden önce yürütülmesi için aynı önceliğe sahip diğer tüm diğer iş parçacıklarını sağlar.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-258">This service gives all other ready threads of the same priority a chance to execute before the _ *_tx_thread_relinquish_*\* caller executes again.</span></span>

### <a name="time-slicing"></a><span data-ttu-id="f6dcf-259">Time-Slicing</span><span class="sxs-lookup"><span data-stu-id="f6dcf-259">Time-Slicing</span></span>

<span data-ttu-id="f6dcf-260">*Zaman Dilimleme* , bir hepsini bir kez deneme zamanlama biçimidir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-260">*Time-slicing* is another form of round-robin scheduling.</span></span> <span data-ttu-id="f6dcf-261">Zaman dilimi, bir iş parçacığının işlemciyi vermeden yürütebilmesi için en fazla Zamanlayıcı sayısını (süreölçer kesmesi) belirtir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-261">A time-slice specifies the maximum number of timer ticks (timer interrupts) that a thread can execute without giving up the processor.</span></span> <span data-ttu-id="f6dcf-262">ThreadX ' te, zaman dilimliğine iş parçacığı başına olarak erişilebilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-262">In ThreadX, time-slicing is available on a per-thread basis.</span></span> <span data-ttu-id="f6dcf-263">İş parçacığının zaman dilimi oluşturma sırasında atanır ve çalışma zamanında değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-263">The thread's time-slice is assigned during creation and can be modified during run-time.</span></span> <span data-ttu-id="f6dcf-264">Bir zaman dilimi süresi dolmuşsa, aynı öncelik düzeyindeki tüm diğer hazırlık iş parçacıklarının, saat dilimlenmiş iş parçacığı yeniden yürütülmeden önce yürütülmesi için bir şans verilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-264">When a time-slice expires, all other ready threads of the same priority level are given a chance to execute before the time-sliced thread executes again.</span></span>

<span data-ttu-id="f6dcf-265">Yeni bir iş parçacığı zaman dilimi, askıya alındıktan sonra bir iş parçacığına verildiğinde, yeniden, önalım veya kendi zaman dilimine neden olan bir ThreadX hizmeti çağrısı yapar.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-265">A fresh thread time-slice is given to a thread after it suspends, relinquishes, makes a ThreadX service call that causes preemption, or is itself time-sliced.</span></span>

<span data-ttu-id="f6dcf-266">Zaman dilimlenmiş bir iş parçacığı önceden boşaltıldı, zaman diliminin geri kalanı için eşit önceliğe sahip diğer iş parçacıklarından önce devam edecektir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-266">When a time-sliced thread is preempted, it will resume before other ready threads of equal priority for the remainder of its time-slice.</span></span>

> [!NOTE]
> <span data-ttu-id="f6dcf-267">*Zaman dilimletmek, daha hafif bir sistem yükü miktarına neden olur. Zaman dilimi yalnızca birden fazla iş parçacığının aynı önceliğe sahip olduğu durumlarda faydalıdır, benzersiz önceliğe sahip iş parçacıkları zaman dilimine atanmamalıdır.*</span><span class="sxs-lookup"><span data-stu-id="f6dcf-267">*Using time-slicing results in a slight amount of system overhead. Because time-slicing is only useful in cases in which multiple threads share the same priority, threads having a unique priority should not be assigned a time-slice.*</span></span>

### <a name="preemption"></a><span data-ttu-id="f6dcf-268">Önalım</span><span class="sxs-lookup"><span data-stu-id="f6dcf-268">Preemption</span></span>

<span data-ttu-id="f6dcf-269">Önalım, yürütülen bir iş parçacığını daha yüksek öncelikli bir iş parçacığına göre geçici olarak kesintiye uğratma işlemidir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-269">Preemption is the process of temporarily interrupting an executing thread in favor of a higher-priority thread.</span></span> <span data-ttu-id="f6dcf-270">Bu işlem yürütülmekte olan iş parçacığında görünmez.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-270">This process is invisible to the executing thread.</span></span> <span data-ttu-id="f6dcf-271">Yüksek öncelikli iş parçacığı tamamlandığında, denetim, önalım gerçekleştiği konuma doğru konuma aktarılır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-271">When the higher-priority thread is finished, control is transferred back to the exact place where the preemption took place.</span></span> <span data-ttu-id="f6dcf-272">Bu, önemli uygulama olaylarına hızlı yanıt sağladığından gerçek zamanlı sistemlerdeki çok önemli bir özelliktir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-272">This is a very important feature in real-time systems because it facilitates fast response to important application events.</span></span> <span data-ttu-id="f6dcf-273">Önalım çok önemli bir özellik olsa da,, aşırı yük ve öncelik Inversion gibi çeşitli sorunların bir kaynağı olabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-273">Although a very important feature, preemption can also be a source of a variety of problems, including starvation, excessive overhead, and priority inversion.</span></span>

### <a name="preemption-thresholdtrade"></a><span data-ttu-id="f6dcf-274">Önalım eşiği&trade;</span><span class="sxs-lookup"><span data-stu-id="f6dcf-274">Preemption Threshold&trade;</span></span>

<span data-ttu-id="f6dcf-275">ThreadX, önalım 'in bazı sorunlarından bazılarını kolaylaştırmak için *önalım-Threshold* adlı benzersiz ve gelişmiş bir özellik sunar.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-275">To ease some of the inherent problems of preemption, ThreadX provides a unique and advanced feature called *preemption-threshold*.</span></span>

<span data-ttu-id="f6dcf-276">Bir önalım-Threshold, bir iş parçacığının önalım 'yi devre dışı bırakmak için öncelikli *tavan* belirlemesine izin verir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-276">A preemption-threshold allows a thread to specify a priority *ceiling* for disabling preemption.</span></span> <span data-ttu-id="f6dcf-277">Tavan genişliğinden daha yüksek öncelikler olan iş parçacıklarının hala preempt olmasına izin verilmez.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-277">Threads that have higher priorities than the ceiling are still allowed to preempt, while those less than the ceiling are not allowed to preempt.</span></span>

<span data-ttu-id="f6dcf-278">Örneğin, 20 önceliğiyle bir iş parçacığının yalnızca 15 ile 20 arasında öncelikler olan bir iş parçacığı grubuyla etkileşimde bulunduğunu varsayalım.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-278">For example, suppose a thread of priority 20 only interacts with a group of threads that have priorities between 15 and 20.</span></span> <span data-ttu-id="f6dcf-279">Kritik bölümleri sırasında 20 öncelikli iş parçacığı, önalım eşiğini 15 olarak ayarlayabilir, böylece etkileşime girdiği tüm iş parçacıklarından önalım önler.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-279">During its critical sections, the thread of priority 20 can set its preemption-threshold to 15, thereby preventing preemption from all of the threads that it interacts with.</span></span> <span data-ttu-id="f6dcf-280">Bu, gerçekten önemli iş parçacıklarının (0 ve 14 arasındaki öncelikler), kritik bölüm işleme sırasında bu iş parçacığını hafiflemesine izin verir ve bu da daha fazla yanıt vermeye devam eder.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-280">This still permits really important threads (priorities between 0 and 14) to preempt this thread during its critical section processing, which results in much more responsive processing.</span></span>

<span data-ttu-id="f6dcf-281">Tabii ki, önalım eşiğini 0 olarak ayarlayarak bir iş parçacığının tüm önalım devre dışı bırakılması yine de mümkündür.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-281">Of course, it is still possible for a thread to disable all preemption by setting its preemption-threshold to 0.</span></span> <span data-ttu-id="f6dcf-282">Ayrıca, önalım-Threshold, çalışma zamanı sırasında değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-282">In addition, preemption-threshold can be changed during run-time.</span></span>

> [!NOTE]
> <span data-ttu-id="f6dcf-283">*Önalım-Threshold kullanılması, belirtilen iş parçacığı için zaman dilimini devre dışı bırakır.*</span><span class="sxs-lookup"><span data-stu-id="f6dcf-283">*Using preemption-threshold disables time-slicing for the specified thread.*</span></span>

### <a name="priority-inheritance"></a><span data-ttu-id="f6dcf-284">Öncelikli devralma</span><span class="sxs-lookup"><span data-stu-id="f6dcf-284">Priority Inheritance</span></span>

<span data-ttu-id="f6dcf-285">ThreadX, bu bölümün ilerleyen kısımlarında açıklanan mutex Hizmetleri içinde isteğe bağlı öncelik devralmayı da destekler.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-285">ThreadX also supports optional priority inheritance within its mutex services described later in this chapter.</span></span> <span data-ttu-id="f6dcf-286">Öncelikli devralma, düşük öncelikli iş parçacığına ait olan bir mutex için bekleyen yüksek öncelikli bir iş parçacığının önceliğini geçici olarak kabul etmesine olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-286">Priority inheritance allows a lower priority thread to temporarily assume the priority of a high priority thread that is waiting for a mutex owned by the lower priority thread.</span></span> <span data-ttu-id="f6dcf-287">Bu özellik, ara iş parçacığı önceliklerinin önalım ortadan kaldırarak, uygulamanın belirleyici olmayan öncelikli bir sürümden kaçınmanıza yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-287">This capability helps the application to avoid nondeterministic priority inversion by eliminating preemption of intermediate thread priorities.</span></span> <span data-ttu-id="f6dcf-288">Kuşkusuz, *önalım-Threshold* , benzer bir sonuç elde etmek için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-288">Of course, *preemption-threshold* may be used to achieve a similar result.</span></span>

### <a name="thread-creation"></a><span data-ttu-id="f6dcf-289">İş parçacığı oluşturma</span><span class="sxs-lookup"><span data-stu-id="f6dcf-289">Thread Creation</span></span>

<span data-ttu-id="f6dcf-290">Uygulama iş parçacıkları, başlatma sırasında veya diğer uygulama iş parçacıklarının yürütülmesi sırasında oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-290">Application threads are created during initialization or during the execution of other application threads.</span></span> <span data-ttu-id="f6dcf-291">Bir uygulama tarafından oluşturulabilen iş parçacığı sayısı için bir sınır yoktur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-291">There is no limit on the number of threads that can be created by an application.</span></span>

### <a name="thread-control-block-tx_thread"></a><span data-ttu-id="f6dcf-292">İş parçacığı denetim bloğu TX_THREAD</span><span class="sxs-lookup"><span data-stu-id="f6dcf-292">Thread Control Block TX_THREAD</span></span>

<span data-ttu-id="f6dcf-293">Her bir iş parçacığının özellikleri denetim bloğunda bulunur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-293">The characteristics of each thread are contained in its control block.</span></span> <span data-ttu-id="f6dcf-294">Bu yapı ***tx_api. h*** dosyasında tanımlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-294">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="f6dcf-295">Bir iş parçacığının denetim bloğu bellekte herhangi bir yerde bulunabilir, ancak herhangi bir işlevin kapsamı dışında tanımlayarak denetimin genel yapıyı engellemesini sağlamak en yaygın olarak kullanılır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-295">A thread's control block can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

<span data-ttu-id="f6dcf-296">Diğer alanlardaki denetim bloğunun bulunması, dinamik olarak ayrılan tüm bellekte olduğu gibi biraz daha dikkatli bir değer gerektirir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-296">Locating the control block in other areas requires a bit more care, just like all dynamically-allocated memory.</span></span> <span data-ttu-id="f6dcf-297">Bir denetim bloğu bir C işlevi içinde ayrılmışsa, onunla ilişkili bellek, çağıran iş parçacığının yığınının bir parçasıdır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-297">If a control block is allocated within a C function, the memory associated with it is part of the calling thread's stack.</span></span> <span data-ttu-id="f6dcf-298">Genel olarak, denetim blokları için yerel depolama kullanmaktan kaçının çünkü işlev dönmesinden sonra, başka bir iş parçacığının bir denetim bloğu için kullanıp kullanmadığını bağımsız olarak tüm yerel değişken yığın alanı serbest bırakılır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-298">In general, avoid using local storage for control blocks because after the function returns, all of its local variable stack space is released—regardless of whether another thread is using it for a control block.</span></span>

<span data-ttu-id="f6dcf-299">Çoğu durumda, uygulama iş parçacığının denetim bloğunun içeriğine göre yükümlülüğü olur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-299">In most cases, the application is oblivious to the contents of the thread's control block.</span></span> <span data-ttu-id="f6dcf-300">Ancak, özellikle hata ayıklama sırasında bazı durumlar vardır, bu da bazı üyelere göz at yararlı olur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-300">However, there are some situations, especially during debug, in which looking at certain members is useful.</span></span> <span data-ttu-id="f6dcf-301">Daha kullanışlı denetim bloğu üyelerinden bazıları aşağıda verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-301">The following are some of the more useful control block members.</span></span>

<span data-ttu-id="f6dcf-302">**tx_thread_run_count** , iş parçacığının zamanlandığı birçok kez bir sayaç içerir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-302">**tx_thread_run_count** contains a counter of the number of many times the thread has been scheduled.</span></span> <span data-ttu-id="f6dcf-303">Artan bir sayaç, iş parçacığının zamanlandığını ve yürütüldüğünü belirtir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-303">An increasing counter indicates the thread is being scheduled and executed.</span></span>

<span data-ttu-id="f6dcf-304">**tx_thread_state** ilişkili iş parçacığının durumunu içerir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-304">**tx_thread_state** contains the state of the associated thread.</span></span> <span data-ttu-id="f6dcf-305">Aşağıdaki, olası iş parçacığı durumlarını listeler.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-305">The following lists the possible thread states.</span></span>

|  <span data-ttu-id="f6dcf-306">İş parçacığı durumu</span><span class="sxs-lookup"><span data-stu-id="f6dcf-306">Thread state</span></span>   | <span data-ttu-id="f6dcf-307">Değer</span><span class="sxs-lookup"><span data-stu-id="f6dcf-307">Value</span></span> |
| --------------- | ------ |
| <span data-ttu-id="f6dcf-308">TX_READY</span><span class="sxs-lookup"><span data-stu-id="f6dcf-308">TX_READY</span></span>       | <span data-ttu-id="f6dcf-309">-</span><span class="sxs-lookup"><span data-stu-id="f6dcf-309">(0x00)</span></span> |
| <span data-ttu-id="f6dcf-310">TX_COMPLETED</span><span class="sxs-lookup"><span data-stu-id="f6dcf-310">TX_COMPLETED</span></span>   | <span data-ttu-id="f6dcf-311">0x01</span><span class="sxs-lookup"><span data-stu-id="f6dcf-311">(0x01)</span></span> |
| <span data-ttu-id="f6dcf-312">TX_TERMINATED</span><span class="sxs-lookup"><span data-stu-id="f6dcf-312">TX_TERMINATED</span></span>  | <span data-ttu-id="f6dcf-313">0x02 şeklindedir</span><span class="sxs-lookup"><span data-stu-id="f6dcf-313">(0x02)</span></span> |
| <span data-ttu-id="f6dcf-314">TX_SUSPENDED</span><span class="sxs-lookup"><span data-stu-id="f6dcf-314">TX_SUSPENDED</span></span>   | <span data-ttu-id="f6dcf-315">(0x03)</span><span class="sxs-lookup"><span data-stu-id="f6dcf-315">(0x03)</span></span> |
| <span data-ttu-id="f6dcf-316">TX_SLEEP</span><span class="sxs-lookup"><span data-stu-id="f6dcf-316">TX_SLEEP</span></span>       | <span data-ttu-id="f6dcf-317">(0x04)</span><span class="sxs-lookup"><span data-stu-id="f6dcf-317">(0x04)</span></span> |
| <span data-ttu-id="f6dcf-318">TX_QUEUE_SUSP</span><span class="sxs-lookup"><span data-stu-id="f6dcf-318">TX_QUEUE_SUSP</span></span> | <span data-ttu-id="f6dcf-319">(0x05)</span><span class="sxs-lookup"><span data-stu-id="f6dcf-319">(0x05)</span></span> |
| <span data-ttu-id="f6dcf-320">TX_SEMAPHORE_SUSP</span><span class="sxs-lookup"><span data-stu-id="f6dcf-320">TX_SEMAPHORE_SUSP</span></span> | <span data-ttu-id="f6dcf-321">(0x06)</span><span class="sxs-lookup"><span data-stu-id="f6dcf-321">(0x06)</span></span> |
| <span data-ttu-id="f6dcf-322">TX_EVENT_FLAG</span><span class="sxs-lookup"><span data-stu-id="f6dcf-322">TX_EVENT_FLAG</span></span>   | <span data-ttu-id="f6dcf-323">(0x07)</span><span class="sxs-lookup"><span data-stu-id="f6dcf-323">(0x07)</span></span> |
| <span data-ttu-id="f6dcf-324">TX_BLOCK_MEMORY</span><span class="sxs-lookup"><span data-stu-id="f6dcf-324">TX_BLOCK_MEMORY</span></span> | <span data-ttu-id="f6dcf-325">(0x08)</span><span class="sxs-lookup"><span data-stu-id="f6dcf-325">(0x08)</span></span> |
| <span data-ttu-id="f6dcf-326">TX_BYTE_MEMORY</span><span class="sxs-lookup"><span data-stu-id="f6dcf-326">TX_BYTE_MEMORY</span></span>  | <span data-ttu-id="f6dcf-327">0x09</span><span class="sxs-lookup"><span data-stu-id="f6dcf-327">(0x09)</span></span> |
| <span data-ttu-id="f6dcf-328">TX_MUTEX_SUSP</span><span class="sxs-lookup"><span data-stu-id="f6dcf-328">TX_MUTEX_SUSP</span></span>   | <span data-ttu-id="f6dcf-329">0x0D</span><span class="sxs-lookup"><span data-stu-id="f6dcf-329">(0x0D)</span></span> |

> [!NOTE]
> <span data-ttu-id="f6dcf-330">*Tabii ki, yığın işaretçisi, saat dilimi değeri, öncelikler vb. dahil olmak üzere iş parçacığı denetim bloğunda çok sayıda ilginç alan vardır. Kullanıcılar denetim bloğu üyelerini incelemeye hoş geldiniz, ancak değişikliklere kesinlikle izin verilmez!*</span><span class="sxs-lookup"><span data-stu-id="f6dcf-330">*Of course there are many other interesting fields in the thread control block, including the stack pointer, time-slice value, priorities, etc. Users are welcome to review control block members, but modifications are strictly prohibited!*</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f6dcf-331">*Bu bölümde daha önce bahsedilen "yürütülüyor" durumu için bir eş yoktur. Belirli bir zamanda yalnızca bir çalışan iş parçacığı olduğundan bu gerekli değildir. Yürütülen iş parçacığının durumu da* **TX_READY**.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-331">*There is no equate for the "executing" state mentioned earlier in this section. It is not necessary because there is only one executing thread at a given time. The state of an executing thread is also* **TX_READY**.</span></span>

### <a name="currently-executing-thread"></a><span data-ttu-id="f6dcf-332">Yürütülmekte olan Iş parçacığı</span><span class="sxs-lookup"><span data-stu-id="f6dcf-332">Currently Executing Thread</span></span>

<span data-ttu-id="f6dcf-333">Daha önce bahsedildiği gibi, belirli bir zamanda yalnızca bir iş parçacığı yürütüyordur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-333">As mentioned before, there is only one thread executing at any given time.</span></span> <span data-ttu-id="f6dcf-334">Yürütülen iş parçacığını, isteği yapan iş parçacığına bağlı olarak belirlemenin birkaç yolu vardır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-334">There are several ways to identify the executing thread, depending on which thread is making the request.</span></span>
<span data-ttu-id="f6dcf-335">Program kesimi, ***tx_thread_identify*** çağırarak yürütülen iş parçacığının denetim bloğu adresini alabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-335">A program segment can get the control block address of the executing thread by calling ***tx_thread_identify***.</span></span> <span data-ttu-id="f6dcf-336">Bu, birden çok iş parçacığından yürütülen uygulama kodunun paylaşılan bölümlerinde yararlıdır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-336">This is useful in shared portions of application code that are executed from multiple threads.</span></span>

<span data-ttu-id="f6dcf-337">Hata ayıklama oturumlarında, kullanıcılar iç ThreadX işaretçisini ***_tx_thread_current_ptr*** inceleyebilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-337">In debug sessions, users can examine the internal ThreadX pointer ***_tx_thread_current_ptr***.</span></span> <span data-ttu-id="f6dcf-338">Şu anda yürütülmekte olan iş parçacığının denetim bloğu adresini içerir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-338">It contains the control block address of the currently executing thread.</span></span> <span data-ttu-id="f6dcf-339">Bu işaretçi NULL ise, uygulama iş parçacığı yürütülmüyor; Yani, ThreadX bir iş parçacığının hazırlanması için zamanlama döngüsünde bekliyor.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-339">If this pointer is NULL, no application thread is executing; i.e., ThreadX is waiting in its scheduling loop for a thread to become ready.</span></span>

### <a name="thread-stack-area"></a><span data-ttu-id="f6dcf-340">İş parçacığı yığın alanı</span><span class="sxs-lookup"><span data-stu-id="f6dcf-340">Thread Stack Area</span></span>

<span data-ttu-id="f6dcf-341">Her iş parçacığının en son yürütme ve derleyici kullanımı bağlamını kaydetmek için kendi yığınına sahip olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-341">Each thread must have its own stack for saving the context of its last execution and compiler use.</span></span> <span data-ttu-id="f6dcf-342">Çoğu C derleyicileri, işlev çağrıları yapmak ve yerel değişkenleri geçici olarak ayırmak için yığın kullanır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-342">Most C compilers use the stack for making function calls and for temporarily allocating local variables.</span></span> <span data-ttu-id="f6dcf-343">Şekil 6 ' da tipik bir iş parçacığının yığını gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-343">Figure 6 shows a typical thread's stack.</span></span>

<span data-ttu-id="f6dcf-344">Bir iş parçacığı yığınının bellekte bulunduğu yer, uygulamaya göre yapılır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-344">Where a thread stack is located in memory is up to the application.</span></span> <span data-ttu-id="f6dcf-345">Yığın alanı, iş parçacığı oluşturma sırasında belirtilir ve hedefin adres alanının herhangi bir yerinden bulunabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-345">The stack area is specified during thread creation and can be located anywhere in the target's address space.</span></span> <span data-ttu-id="f6dcf-346">Bu önemli bir özelliktir çünkü, yığınlarını yüksek hızlı RAM 'e yerleştirerek uygulamaların önemli iş parçacıklarının performansını artırmasına olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-346">This is an important feature because it allows applications to improve performance of important threads by placing their stack in high-speed RAM.</span></span>

<span data-ttu-id="f6dcf-347">**Yığın bellek alanı** (örnek)</span><span class="sxs-lookup"><span data-stu-id="f6dcf-347">**Stack Memory Area** (example)</span></span>

![Tipik Iş parçacığı yığını](./media/user-guide/typical-thread-stack.png)

<span data-ttu-id="f6dcf-349">**ŞEKIL 6. Tipik Iş parçacığı yığını**</span><span class="sxs-lookup"><span data-stu-id="f6dcf-349">**FIGURE 6. Typical Thread Stack**</span></span>

<span data-ttu-id="f6dcf-350">Yığının ne kadar büyük olması, iş parçacıkları hakkında en sık sorulan sorulardan biridir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-350">How big a stack should be is one of the most frequently asked questions about threads.</span></span> <span data-ttu-id="f6dcf-351">Bir iş parçacığının yığın alanı, en kötü durum işlevi çağrısı iç içe geçme, yerel değişken ayırma ve son yürütme bağlamını kaydetmeye yetecek kadar büyük olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-351">A thread's stack area must be large enough to accommodate worst-case function call nesting, local variable allocation, and saving its last execution context.</span></span>

<span data-ttu-id="f6dcf-352">Minimum yığın boyutu **TX_MINIMUM_STACK**, threadx tarafından tanımlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-352">The minimum stack size, **TX_MINIMUM_STACK**, is defined by ThreadX.</span></span> <span data-ttu-id="f6dcf-353">Bu boyuttaki bir yığın, bir iş parçacığının bağlamını kaydetmeyi ve minimum işlev çağrısı sayısını ve yerel değişken ayırmayı destekler.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-353">A stack of this size supports saving a thread's context and minimum amount of function calls and local variable allocation.</span></span>

<span data-ttu-id="f6dcf-354">Ancak, çoğu iş parçacığı için, en düşük yığın boyutu çok küçük olur ve Kullanıcı, işlev çağrısı iç içe ve yerel değişken ayırmayı inceleyerek en kötü durum boyutu gereksinimini yoklamayı sağlamalıdır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-354">For most threads, however, the minimum stack size is too small, and the user must ascertain the worst-case size requirement by examining function-call nesting and local variable allocation.</span></span> <span data-ttu-id="f6dcf-355">Kuşkusuz, daha büyük bir yığın alanıyla başlamak her zaman daha iyidir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-355">Of course, it is always better to start with a larger stack area.</span></span>

<span data-ttu-id="f6dcf-356">Uygulamanın hataları ayıklandıktan sonra, bellek scarce ise iş parçacığı yığın boyutlarını ayarlamak mümkündür.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-356">After the application is debugged, it is possible to tune the thread stack sizes if memory is scarce.</span></span> <span data-ttu-id="f6dcf-357">Sık kullanılan bir yol, iş parçacıklarını oluşturmadan önce (0xEFEF) gibi kolay tanımlanabilir bir veri düzeniyle tüm yığın alanlarının önceden ayarlanmasıdır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-357">A favorite trick is to preset all stack areas with an easily identifiable data pattern like (0xEFEF) prior to creating the threads.</span></span> <span data-ttu-id="f6dcf-358">Uygulama, Paces üzerinden tamamen gerçekleştirildikten sonra, yığın alanlarının ne kadar yığın kullandığını görmek için veri deseninin hala bozulmakta olduğu yığının alanını buluyor.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-358">After the application has been thoroughly put through its paces, the stack areas can be examined to see how much stack was actually used by finding the area of the stack where the data pattern is still intact.</span></span> <span data-ttu-id="f6dcf-359">Şekil 7 ' de, tam iş parçacığı yürütme sonrasında 0xEFEF için bir yığın ön ayarı gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-359">Figure 7 shows a stack preset to 0xEFEF after thorough thread execution.</span></span>

<span data-ttu-id="f6dcf-360">**Yığın bellek alanı** (başka bir örnek)</span><span class="sxs-lookup"><span data-stu-id="f6dcf-360">**Stack Memory Area** (another example)</span></span>

![0xEFEF \* için yığın önayarı](./media/user-guide/stack-preset.png)

<span data-ttu-id="f6dcf-362">**ŞEKIL 7. Yığın önayarı 0xEFEF**</span><span class="sxs-lookup"><span data-stu-id="f6dcf-362">**FIGURE 7. Stack Preset to 0xEFEF**</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f6dcf-363">*Varsayılan olarak, ThreadX her bir iş parçacığı yığınının her baytını bir 0xEF değeri ile başlatır.*</span><span class="sxs-lookup"><span data-stu-id="f6dcf-363">*By default, ThreadX initializes every byte of each thread stack with a value of 0xEF.*</span></span>

### <a name="memory-pitfalls"></a><span data-ttu-id="f6dcf-364">Bellek sınırları</span><span class="sxs-lookup"><span data-stu-id="f6dcf-364">Memory Pitfalls</span></span>

<span data-ttu-id="f6dcf-365">İş parçacıkları için yığın gereksinimleri büyük olabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-365">The stack requirements for threads can be large.</span></span> <span data-ttu-id="f6dcf-366">Bu nedenle, uygulamayı makul sayıda iş parçacığına sahip olacak şekilde tasarlamak önemlidir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-366">Therefore, it is important to design the application to have a reasonable number of threads.</span></span> <span data-ttu-id="f6dcf-367">Ayrıca, iş parçacıkları içinde aşırı yığın kullanımını önlemek için bazı dikkatli olunmalıdır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-367">Furthermore, some care must be taken to avoid excessive stack usage within threads.</span></span> <span data-ttu-id="f6dcf-368">Özyinelemeli algoritmalar ve büyük yerel veri yapıları önlenmelidir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-368">Recursive algorithms and large local data structures should be avoided.</span></span>

<span data-ttu-id="f6dcf-369">Çoğu durumda, taşan bir yığın, iş parçacığı yürütmesinin yığın alanının bitişik (genellikle daha önce) bellek alanına ayrılmasına neden olur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-369">In most cases, an overflowed stack causes thread execution to corrupt memory adjacent (usually before) its stack area.</span></span> <span data-ttu-id="f6dcf-370">Sonuçlar tahmin edilemez, ancak çoğu zaman program sayacında doğal olmayan bir değişikliğe neden olur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-370">The results are unpredictable, but most often result in an unnatural change in the program counter.</span></span> <span data-ttu-id="f6dcf-371">Bu, genellikle "Weeds 'e atlama" olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-371">This is often called "jumping into the weeds."</span></span> <span data-ttu-id="f6dcf-372">Kuşkusuz, bunu önlemenin tek yolu tüm iş parçacığı yığınlarının yeterince büyük olmasını sağlamaktır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-372">Of course, the only way to prevent this is to ensure all thread stacks are large enough.</span></span>

### <a name="optional-run-time-stack-checking"></a><span data-ttu-id="f6dcf-373">İsteğe bağlı çalışma zamanı yığın denetimi</span><span class="sxs-lookup"><span data-stu-id="f6dcf-373">Optional Run-time Stack Checking</span></span>

<span data-ttu-id="f6dcf-374">ThreadX, çalışma zamanı sırasında her bir iş parçacığının yığınını bozulma için denetleme olanağı sağlar.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-374">ThreadX provides the ability to check each thread's stack for corruption during run-time.</span></span> <span data-ttu-id="f6dcf-375">Varsayılan olarak, ThreadX, oluşturma sırasında bir 0xEF veri düzeniyle iş parçacığı yığınlarının her baytını doldurur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-375">By default, ThreadX fills every byte of thread stacks with a 0xEF data pattern during creation.</span></span> <span data-ttu-id="f6dcf-376">Uygulama, ThreadX kitaplığını tanımlı **TX_ENABLE_STACK_CHECKING** ile oluşturmazsa, threadx her iş parçacığının yığınını, askıya alındığından veya sürdürüldüğünde bozulma için inceler.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-376">If the application builds the ThreadX library with **TX_ENABLE_STACK_CHECKING** defined, ThreadX will examine each thread's stack for corruption as it is suspended or resumed.</span></span> <span data-ttu-id="f6dcf-377">Yığın bozulması algılanırsa, ThreadX, uygulamanın yığın hata işleme yordamını tx_thread_stack_error_notify _ çağrısıyla belirtilen şekilde çağırır ***. Aksi halde, yığın hata işleyicisi belirtilmemişse, ThreadX iç _* _ _tx_thread_stack_error_handler_ yordamını çağırır** .</span><span class="sxs-lookup"><span data-stu-id="f6dcf-377">If stack corruption is detected, ThreadX will call the application's stack error handling routine as specified by the call to **_tx_thread_stack_error_notify_*_. Otherwise, if no stack error handler was specified, ThreadX will call the internal _\* _ _tx_thread_stack_error_handler_*\* routine.</span></span>

### <a name="reentrancy"></a><span data-ttu-id="f6dcf-378">Yeniden giriş</span><span class="sxs-lookup"><span data-stu-id="f6dcf-378">Reentrancy</span></span>

<span data-ttu-id="f6dcf-379">Çoklu iş parçacıklı gerçek Beauties biri aynı C işlevinin birden çok iş parçacığından çağrılabilir olması olabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-379">One of the real beauties of multithreading is that the same C function can be called from multiple threads.</span></span> <span data-ttu-id="f6dcf-380">Bu harika bir güç sağlar ve ayrıca kod alanını azaltmaya yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-380">This provides great power and also helps reduce code space.</span></span> <span data-ttu-id="f6dcf-381">Ancak, birden çok iş parçacığından çağrılan C işlevlerinin *yeniden kullanılabilir olmasını* gerektirir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-381">However, it does require that C functions called from multiple threads are *reentrant*.</span></span>

<span data-ttu-id="f6dcf-382">Temel olarak, bir yeniden alan işlevi çağıranın dönüş adresini geçerli yığında depolar ve daha önce ayarlamış olduğu genel veya statik C değişkenlerine bağlı değildir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-382">Basically, a reentrant function stores the caller's return address on the current stack and does not rely on global or static C variables that it previously set up.</span></span> <span data-ttu-id="f6dcf-383">Çoğu derleyiciler, dönüş adresini yığına yerleştirir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-383">Most compilers place the return address on the stack.</span></span> <span data-ttu-id="f6dcf-384">Bu nedenle, uygulama geliştiricileri yalnızca *genel* ve *statiklerin* kullanımı konusunda endişelenmelidir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-384">Hence, application developers must only worry about the use of *globals* and *statics*.</span></span>

<span data-ttu-id="f6dcf-385">Standart C Kitaplığı 'nda bulunan ***strtok*** dize belirteci, yeniden yer olmayan bir işleve bir örnektir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-385">An example of a non-reentrant function is the string token function ***strtok*** found in the standard C library.</span></span> <span data-ttu-id="f6dcf-386">Bu işlev, sonraki çağrılarındaki önceki dize işaretçisini "anımsar".</span><span class="sxs-lookup"><span data-stu-id="f6dcf-386">This function "remembers" the previous string pointer on subsequent calls.</span></span> <span data-ttu-id="f6dcf-387">Bunu bir statik dize işaretçisi ile yapar.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-387">It does this with a static string pointer.</span></span> <span data-ttu-id="f6dcf-388">Bu işlev birden çok iş parçacığından çağrılırsa, büyük olasılıkla geçersiz bir işaretçi döndürür.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-388">If this function is called from multiple threads, it would most likely return an invalid pointer.</span></span>

### <a name="thread-priority-pitfalls"></a><span data-ttu-id="f6dcf-389">İş parçacığı önceliği sınırları</span><span class="sxs-lookup"><span data-stu-id="f6dcf-389">Thread Priority Pitfalls</span></span>

<span data-ttu-id="f6dcf-390">İş parçacığı önceliklerinin seçilmesi, çoklu iş parçacığı oluşturma 'nın en önemli özelliklerinden biridir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-390">Selecting thread priorities is one of the most important aspects of multithreading.</span></span> <span data-ttu-id="f6dcf-391">Çalışma zamanı sırasında tam olarak gerekli olanları belirlemek yerine, algılanan iş parçacığı önem derecesine göre öncelikler atamak çok önemlidir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-391">It is sometimes very tempting to assign priorities based on a perceived notion of thread importance rather than determining what is exactly required during run-time.</span></span> <span data-ttu-id="f6dcf-392">İş parçacığı önceliklerinin kötüye kullanılması, diğer iş parçacıklarını gerçekleştirebilir, öncelik sürümü oluşturabilir, işlem bant genişliğini azaltabilir ve uygulamanın çalışma zamanı davranışını anlamayı zorlaştırır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-392">Misuse of thread priorities can starve other threads, create priority inversion, reduce processing bandwidth, and make the application's run-time behavior difficult to understand.</span></span>

<span data-ttu-id="f6dcf-393">Daha önce bahsedildiği gibi, ThreadX, öncelik temelli bir preemptive zamanlama algoritması sağlar.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-393">As mentioned before, ThreadX provides a priority-based, preemptive scheduling algorithm.</span></span> <span data-ttu-id="f6dcf-394">Düşük öncelikli iş parçacıkları, yürütmeye yönelik daha yüksek öncelikli iş parçacığı kalmayana kadar yürütülmez.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-394">Lower priority threads do not execute until there are no higher priority threads ready for execution.</span></span> <span data-ttu-id="f6dcf-395">Daha yüksek öncelikli iş parçacığı her zaman hazırsa, düşük öncelikli iş parçacıkları hiçbir zaman yürütülmez.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-395">If a higher priority thread is always ready, the lower priority threads never execute.</span></span> <span data-ttu-id="f6dcf-396">Bu koşul, *iş parçacığı başlangıçadı* olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-396">This condition is called *thread starvation*.</span></span>

<span data-ttu-id="f6dcf-397">Çoğu iş parçacığı sorunu hata ayıklamada erken algılanır ve daha yüksek öncelikli iş parçacıklarının sürekli yürütülmeyeceğinden çözülebilirler.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-397">Most thread starvation problems are detected early in debug and can be solved by ensuring that higher priority threads don't execute continuously.</span></span> <span data-ttu-id="f6dcf-398">Alternatif olarak, yürütme şansı alınana kadar, mantıksal olarak yürütülen iş parçacıklarının önceliğini kademeli olarak başlatan uygulamaya de bir mantık eklenebilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-398">Alternatively, logic can be added to the application that gradually raises the priority of starved threads until they get a chance to execute.</span></span>

<span data-ttu-id="f6dcf-399">İş parçacığı öncelikleriyle ilişkili başka bir *giriş ise öncelikli bir sürümdür*.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-399">Another pitfall associated with thread priorities is *priority inversion*.</span></span> <span data-ttu-id="f6dcf-400">Düşük öncelikli bir iş parçacığında gerekli bir kaynak olduğundan, yüksek öncelikli bir iş parçacığı askıya alındığında öncelik Inversion gerçekleşir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-400">Priority inversion takes place when a higher priority thread is suspended because a lower priority thread has a needed resource.</span></span> <span data-ttu-id="f6dcf-401">Kuşkusuz, bazı örneklerde, farklı öncelikteki iki iş parçacığının ortak bir kaynağı paylaşması gerekir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-401">Of course, in some instances it is necessary for two threads of different priority to share a common resource.</span></span> <span data-ttu-id="f6dcf-402">Bu iş parçacıkları etkin tek bir sürümse, öncelik Inversion saati, düşük öncelikli iş parçacığı kaynağı tutan zamana göre sınırlanır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-402">If these threads are the only ones active, the priority inversion time is bounded by the time the lower priority thread holds the resource.</span></span> <span data-ttu-id="f6dcf-403">Bu koşul hem belirleyici hem de oldukça normaldir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-403">This condition is both deterministic and quite normal.</span></span> <span data-ttu-id="f6dcf-404">Bununla birlikte, bu öncelik geçersiz kılma sırasında ara öncelikteki iş parçacıkları etkin hale gelirse, öncelik Inversion süresi artık belirleyici değildir ve bir uygulama hatasına neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-404">However, if threads of intermediate priority become active during this priority inversion condition, the priority inversion time is no longer deterministic and could cause an application failure.</span></span>

<span data-ttu-id="f6dcf-405">ThreadX 'te belirleyici olmayan öncelikli öncelikli sürümü önlemek için önemli ölçüde üç farklı yöntem vardır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-405">There are principally three distinct methods of preventing nondeterministic priority inversion in ThreadX.</span></span> <span data-ttu-id="f6dcf-406">İlk olarak, uygulama önceliği seçimleri ve çalışma zamanı davranışı, öncelik sürümü sorununun önlenebilmesini sağlayacak şekilde tasarlanabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-406">First, the application priority selections and run-time behavior can be designed in a manner that prevents the priority inversion problem.</span></span> <span data-ttu-id="f6dcf-407">İkincisi, daha yüksek öncelikli iş parçacıklarıyla kaynakları paylaştıklarında, daha düşük öncelikli iş parçacıkları *önalım eşiğini* kullanarak ara iş parçacıklarından önalım 'i engelleyebilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-407">Second, lower priority threads can utilize *preemption threshold* to block preemption from intermediate threads while they share resources with higher priority threads.</span></span> <span data-ttu-id="f6dcf-408">Son olarak, sistem kaynaklarını korumak için ThreadX mutex nesnelerini kullanan iş parçacıkları, belirleyici olmayan öncelikli bir sürümü ortadan kaldırmak için isteğe bağlı mutex *önceliği devrmasından* yararlanabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-408">Finally, threads using ThreadX mutex objects to protect system resources may utilize the optional mutex *priority inheritance* to eliminate nondeterministic priority inversion.</span></span>

### <a name="priority-overhead"></a><span data-ttu-id="f6dcf-409">Öncelik ek yükü</span><span class="sxs-lookup"><span data-stu-id="f6dcf-409">Priority Overhead</span></span>

<span data-ttu-id="f6dcf-410">Çoklu iş parçacığı içindeki ek yükü azaltmanın en fazla belirgin yolu, bağlam anahtarlarının sayısını azaltmaktır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-410">One of the most overlooked ways to reduce overhead in multithreading is to reduce the number of context switches.</span></span> <span data-ttu-id="f6dcf-411">Daha önce belirtildiği gibi, daha yüksek öncelikli bir iş parçacığının yürütülmesi yürütülen iş parçacığının üzerinde daha kırmızıysa bir bağlam anahtarı oluşur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-411">As previously mentioned, a context switch occurs when execution of a higher priority thread is favored over that of the executing thread.</span></span> <span data-ttu-id="f6dcf-412">Yüksek öncelikli iş parçacıklarının, hem dış olayların (kesmeler gibi) hem de yürütülen iş parçacığı tarafından yapılan hizmet çağrılarının bir sonucu olarak hazırlanabileceğini bahsetmek çok önemlidir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-412">It is worthwhile to mention that higher priority threads can become ready as a result of both external events (like interrupts) and from service calls made by the executing thread.</span></span>

<span data-ttu-id="f6dcf-413">Efekt iş parçacığı önceliklerinin bağlam anahtarı ek yükü üzerinde olduğunu göstermek için, *thread_1*, *thread_2* ve *thread_3* adlı iş parçacıklarından oluşan üç iş parçacığı ortamı olduğunu varsayalım.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-413">To illustrate the effects thread priorities have on context switch overhead, assume a three thread environment with threads named *thread_1*, *thread_2*, and *thread_3*.</span></span> <span data-ttu-id="f6dcf-414">Tüm iş parçacıklarının bir ileti bekleyen askıya alınma durumunda olduğunu varsayalım.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-414">Assume further that all of the threads are in a state of suspension waiting for a message.</span></span> <span data-ttu-id="f6dcf-415">Thread_1 bir ileti aldığında, bunu hemen thread_2 gönderir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-415">When thread_1 receives a message, it immediately forwards it to thread_2.</span></span> <span data-ttu-id="f6dcf-416">Thread_2 sonra iletiyi thread_3 iletir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-416">Thread_2 then forwards the message to thread_3.</span></span> <span data-ttu-id="f6dcf-417">Thread_3 yalnızca iletiyi atar.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-417">Thread_3 just discards the message.</span></span> <span data-ttu-id="f6dcf-418">Her iş parçacığı iletisini tamamladıktan sonra, geri döner ve başka bir ileti bekler.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-418">After each thread processes its message, it goes back and waits for another message.</span></span>

<span data-ttu-id="f6dcf-419">Bu üç iş parçacığını yürütmek için gereken işlem önceliklerinden büyük ölçüde farklılık gösterir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-419">The processing required to execute these three threads varies greatly depending on their priorities.</span></span> <span data-ttu-id="f6dcf-420">Tüm iş parçacıkları aynı önceliğe sahip ise, her iş parçacığının yürütülmesinden önce tek bir bağlam anahtarı oluşur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-420">If all of the threads have the same priority, a single context switch occurs before the execution of each thread.</span></span> <span data-ttu-id="f6dcf-421">Bağlam anahtarı, her iş parçacığı boş bir ileti kuyruğu üzerinde askıya aldığında oluşur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-421">The context switch occurs when each thread suspends on an empty message queue.</span></span>

<span data-ttu-id="f6dcf-422">Ancak, thread_2 thread_1 kıyasla daha yüksek önceliktir ve thread_3 thread_2 kıyasla daha yüksek önceliktir, bağlam anahtarlarının sayısı iki katına çıkar.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-422">However, if thread_2 is higher priority than thread_1 and thread_3 is higher priority than thread_2, the number of context switches doubles.</span></span> <span data-ttu-id="f6dcf-423">Bunun nedeni, daha yüksek öncelikli bir iş parçacığının artık hazır olduğunu algıladığında *tx_queue_send* hizmetinin içinde başka bir bağlam anahtarının gerçekleşmesinden kaynaklanır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-423">This is because another context switch occurs inside of the *tx_queue_send* service when it detects that a higher priority thread is now ready.</span></span>

<span data-ttu-id="f6dcf-424">ThreadX önalım-Threshold mekanizması, bu ek bağlam anahtarlarından kaçınabilir ve yine de yukarıda bahsedilen öncelik seçimlerini sağlayabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-424">The ThreadX preemption-threshold mechanism can avoid these extra context switches and still allow the previously mentioned priority selections.</span></span> <span data-ttu-id="f6dcf-425">Zamanlama sırasında birkaç iş parçacığı önceliklerinin sağladığından bu önemli bir özelliktir, ancak aynı zamanda iş parçacığı yürütme sırasında aralarında bazı istenmeyen bağlamla geçiş yapmayı ortadan kaldırır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-425">This is an important feature because it allows several thread priorities during scheduling, while at the same time eliminating some of the unwanted context switching between them during thread execution.</span></span>

### <a name="run-time-thread-performance-information"></a><span data-ttu-id="f6dcf-426">Çalışma zamanı Iş parçacığı performans bilgileri</span><span class="sxs-lookup"><span data-stu-id="f6dcf-426">Run-time Thread Performance Information</span></span>

<span data-ttu-id="f6dcf-427">ThreadX isteğe bağlı çalışma zamanı iş parçacığı performans bilgilerini sağlar.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-427">ThreadX provides optional run-time thread performance information.</span></span> <span data-ttu-id="f6dcf-428">ThreadX kitaplığı ve uygulaması tanımlanmış **TX_THREAD_ENABLE_PERFORMANCE_INFO** ile derlenip, threadx aşağıdaki bilgileri biriktirir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-428">If the ThreadX library and application is built with **TX_THREAD_ENABLE_PERFORMANCE_INFO** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="f6dcf-429">Genel sistem için toplam sayı:</span><span class="sxs-lookup"><span data-stu-id="f6dcf-429">Total number for the overall system:</span></span>

  - <span data-ttu-id="f6dcf-430">iş parçacığı bağlantının sürdürülmesi</span><span class="sxs-lookup"><span data-stu-id="f6dcf-430">thread resumptions</span></span>

  - <span data-ttu-id="f6dcf-431">iş parçacığı getirilmesi</span><span class="sxs-lookup"><span data-stu-id="f6dcf-431">thread suspensions</span></span>

  - <span data-ttu-id="f6dcf-432">hizmet çağrısı preemptions</span><span class="sxs-lookup"><span data-stu-id="f6dcf-432">service call preemptions</span></span>

  - <span data-ttu-id="f6dcf-433">kesme preemptions</span><span class="sxs-lookup"><span data-stu-id="f6dcf-433">interrupt preemptions</span></span>

  - <span data-ttu-id="f6dcf-434">öncelikli Inversions 'ları</span><span class="sxs-lookup"><span data-stu-id="f6dcf-434">priority inversions</span></span>

  - <span data-ttu-id="f6dcf-435">zaman dilimleri</span><span class="sxs-lookup"><span data-stu-id="f6dcf-435">time-slices</span></span>

  - <span data-ttu-id="f6dcf-436">relinquishes</span><span class="sxs-lookup"><span data-stu-id="f6dcf-436">relinquishes</span></span>

  - <span data-ttu-id="f6dcf-437">iş parçacığı zaman aşımları</span><span class="sxs-lookup"><span data-stu-id="f6dcf-437">thread timeouts</span></span>

  - <span data-ttu-id="f6dcf-438">askıya alma iptal edilecek</span><span class="sxs-lookup"><span data-stu-id="f6dcf-438">suspension aborts</span></span>

  - <span data-ttu-id="f6dcf-439">Boştaki sistem geri dönüşler</span><span class="sxs-lookup"><span data-stu-id="f6dcf-439">idle system returns</span></span>

  - <span data-ttu-id="f6dcf-440">boşta olmayan sistem dönüşleri</span><span class="sxs-lookup"><span data-stu-id="f6dcf-440">non-idle system returns</span></span>

<span data-ttu-id="f6dcf-441">Her iş parçacığının toplam sayısı:</span><span class="sxs-lookup"><span data-stu-id="f6dcf-441">Total number for each thread:</span></span>

  - <span data-ttu-id="f6dcf-442">bağlantının sürdürülmesi</span><span class="sxs-lookup"><span data-stu-id="f6dcf-442">resumptions</span></span>

  - <span data-ttu-id="f6dcf-443">getirilmesi</span><span class="sxs-lookup"><span data-stu-id="f6dcf-443">suspensions</span></span>

  - <span data-ttu-id="f6dcf-444">hizmet çağrısı preemptions</span><span class="sxs-lookup"><span data-stu-id="f6dcf-444">service call preemptions</span></span>

  - <span data-ttu-id="f6dcf-445">kesme preemptions</span><span class="sxs-lookup"><span data-stu-id="f6dcf-445">interrupt preemptions</span></span>

  - <span data-ttu-id="f6dcf-446">öncelikli Inversions 'ları</span><span class="sxs-lookup"><span data-stu-id="f6dcf-446">priority inversions</span></span>

  - <span data-ttu-id="f6dcf-447">zaman dilimleri</span><span class="sxs-lookup"><span data-stu-id="f6dcf-447">time-slices</span></span>

  - <span data-ttu-id="f6dcf-448">iş parçacığı relinkler</span><span class="sxs-lookup"><span data-stu-id="f6dcf-448">thread relinquishes</span></span>

  - <span data-ttu-id="f6dcf-449">iş parçacığı zaman aşımları</span><span class="sxs-lookup"><span data-stu-id="f6dcf-449">thread timeouts</span></span>

  - <span data-ttu-id="f6dcf-450">askıya alma iptal edilecek</span><span class="sxs-lookup"><span data-stu-id="f6dcf-450">suspension aborts</span></span>

<span data-ttu-id="f6dcf-451">Bu bilgiler, \***tx_thread_performance_info_get** _ ve _ *_tx_thread_performance_system_info_get_* \* Hizmetleri aracılığıyla çalışma zamanında kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-451">This information is available at run-time through the services ***tx_thread_performance_info_get** _ and _*_tx_thread_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="f6dcf-452">İş parçacığı performans bilgileri, uygulamanın düzgün çalışıp çalışmadığını belirlemek için faydalıdır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-452">Thread performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="f6dcf-453">Ayrıca, uygulamayı iyileştirmek için de kullanışlıdır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-453">It is also useful in optimizing the application.</span></span> <span data-ttu-id="f6dcf-454">Örneğin, görece yüksek sayıda hizmet çağrısı preemptions iş parçacığının önceliğini önerebilir ve/veya önalım eşiği çok düşüktür.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-454">For example, a relatively high number of service call preemptions might suggest the thread's priority and/or preemption-threshold is too low.</span></span> <span data-ttu-id="f6dcf-455">Ayrıca, görece düşük sayıda boşta sistem döndürmesi, daha düşük öncelikli iş parçacıklarının yeterince askıya alınması önerisinde bulunabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-455">Furthermore, a relatively low number of idle system returns might suggest that lower priority threads are not suspending enough.</span></span>

### <a name="debugging-pitfalls"></a><span data-ttu-id="f6dcf-456">Hata ayıklama sınırları</span><span class="sxs-lookup"><span data-stu-id="f6dcf-456">Debugging Pitfalls</span></span>

<span data-ttu-id="f6dcf-457">Birden çok iş parçacığından aynı program kodu yürütülemediğinden çok iş parçacıklı uygulamalarda hata ayıklama biraz daha zordur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-457">Debugging multithreaded applications is a little more difficult because the same program code can be executed from multiple threads.</span></span> <span data-ttu-id="f6dcf-458">Böyle durumlarda, bir kesme noktası tek başına yeterli olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-458">In such cases, a break-point alone may not be enough.</span></span> <span data-ttu-id="f6dcf-459">Hata ayıklayıcı, çağıran iş parçacığının hata ayıklaması için bir tane olup olmadığını görmek üzere bir koşullu kesme noktası kullanarak geçerli iş parçacığı işaretçisini **_tx_thread_current_ptr** de görüntülemesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-459">The debugger must also view the current thread pointer **_tx_thread_current_ptr** using a conditional breakpoint to see if the calling thread is the one to debug.</span></span>

<span data-ttu-id="f6dcf-460">Bunun çoğu, çeşitli geliştirme aracı satıcıları aracılığıyla sunulan çoklu iş parçacıklı destek paketlerinde işlenir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-460">Much of this is being handled in multithreading support packages offered through various development tool vendors.</span></span> <span data-ttu-id="f6dcf-461">Basit tasarımı nedeniyle, ThreadX 'i farklı geliştirme araçlarıyla tümleştirmek oldukça kolaydır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-461">Because of its simple design, integrating ThreadX with different development tools is relatively easy.</span></span>

<span data-ttu-id="f6dcf-462">Yığın boyutu her zaman çoklu iş parçacığı oluşturma konusunun önemli bir hata ayıklama konusu.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-462">Stack size is always an important debug topic in multithreading.</span></span> <span data-ttu-id="f6dcf-463">Açıklanamayan davranış gözlemlendiğinde, genellikle her iş parçacığı için yığın boyutlarını artırmak iyi bir ilk tahmindir; özellikle de son iş parçacığının yığın boyutu.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-463">Whenever unexplained behavior is observed, it is usually a good first guess to increase stack sizes for all threads—especially the stack size of the last thread to execute!</span></span>

> [!TIP]
> <span data-ttu-id="f6dcf-464">*Ayrıca, **TX_ENABLE_STACK_CHECKING** tanımlı olan threadx kitaplığını oluşturmak iyi bir fikirdir. Bu, yığın bozulması sorunlarını işleme mümkün olduğunca erken yalıtmak için yardımcı olur.*</span><span class="sxs-lookup"><span data-stu-id="f6dcf-464">*It is also a good idea to build the ThreadX library with **TX_ENABLE_STACK_CHECKING** defined. This will help isolate stack corruption problems as early in the processing as possible.*</span></span>

## <a name="message-queues"></a><span data-ttu-id="f6dcf-465">İleti kuyrukları</span><span class="sxs-lookup"><span data-stu-id="f6dcf-465">Message Queues</span></span>

<span data-ttu-id="f6dcf-466">İleti kuyrukları, ThreadX 'de iş parçacıkları arası iletişimin birincil yöntemidir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-466">Message queues are the primary means of inter-thread communication in ThreadX.</span></span> <span data-ttu-id="f6dcf-467">Bir veya daha fazla ileti bir ileti kuyruğunda bulunabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-467">One or more messages can reside in a message queue.</span></span> <span data-ttu-id="f6dcf-468">Tek bir iletiyi tutan bir ileti kuyruğu genellikle *posta kutusu* olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-468">A message queue that holds a single message is commonly called a *mailbox*.</span></span>

<span data-ttu-id="f6dcf-469">İletiler bir kuyruğa \***tx_queue_send** _ tarafından kopyalanır ve _ *_tx_queue_receive_* \* tarafından bir kuyruktan kopyalanır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-469">Messages are copied to a queue by ***tx_queue_send** _ and are copied from a queue by _*_tx_queue_receive_\*\*.</span></span> <span data-ttu-id="f6dcf-470">Bunun tek istisnası, boş bir kuyruktaki bir ileti beklenirken bir iş parçacığının askıya alındığı durumdur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-470">The only exception to this is when a thread is suspended while waiting for a message on an empty queue.</span></span> <span data-ttu-id="f6dcf-471">Bu durumda, sıraya gönderilen sonraki ileti, iş parçacığının hedef alanına doğrudan yerleştirilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-471">In this case, the next message sent to the queue is placed directly into the thread's destination area.</span></span>

<span data-ttu-id="f6dcf-472">Her ileti kuyruğu ortak bir kaynaktır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-472">Each message queue is a public resource.</span></span> <span data-ttu-id="f6dcf-473">ThreadX, ileti sıralarının nasıl kullanıldığına ilişkin bir kısıtlama yoktur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-473">ThreadX places no constraints on how message queues are used.</span></span>

### <a name="creating-message-queues"></a><span data-ttu-id="f6dcf-474">Ileti kuyrukları oluşturma</span><span class="sxs-lookup"><span data-stu-id="f6dcf-474">Creating Message Queues</span></span>

<span data-ttu-id="f6dcf-475">İleti kuyrukları, başlatma sırasında veya uygulama iş parçacıkları tarafından çalışma zamanı sırasında oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-475">Message queues are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="f6dcf-476">Bir uygulamadaki ileti kuyruğu sayısı için bir sınır yoktur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-476">There is no limit on the number of message queues in an application.</span></span>

### <a name="message-size"></a><span data-ttu-id="f6dcf-477">İleti boyutu</span><span class="sxs-lookup"><span data-stu-id="f6dcf-477">Message Size</span></span>

<span data-ttu-id="f6dcf-478">Her ileti kuyruğu, bir dizi sabit boyutlu iletiyi destekler.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-478">Each message queue supports a number of fixed-sized messages.</span></span> <span data-ttu-id="f6dcf-479">Kullanılabilir ileti boyutları, dahil olmak üzere 1 ile 16 32 bitlik sözcüklerdir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-479">The available message sizes are 1 through 16 32-bit words inclusive.</span></span> <span data-ttu-id="f6dcf-480">İleti boyutu, sıra oluşturulduğunda belirtilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-480">The message size is specified when the queue is created.</span></span> <span data-ttu-id="f6dcf-481">16 sözcükten daha büyük uygulama iletilerinin işaretçiden geçirilmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-481">Application messages greater than 16 words must be passed by pointer.</span></span> <span data-ttu-id="f6dcf-482">Bu, 1 sözcük boyutuna sahip bir sıra (bir işaretçiyi tutmak için yeterli) ve ardından ileti işaretçilerini tüm ileti yerine gönderip alarak gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-482">This is accomplished by creating a queue with a message size of 1 word (enough to hold a pointer) and then sending and receiving message pointers instead of the entire message.</span></span>

### <a name="message-queue-capacity"></a><span data-ttu-id="f6dcf-483">İleti sırası kapasitesi</span><span class="sxs-lookup"><span data-stu-id="f6dcf-483">Message Queue Capacity</span></span>

<span data-ttu-id="f6dcf-484">Bir kuyruğun tutabilecek ileti sayısı, ileti boyutunun bir işlevidir ve oluşturma sırasında sağlanan bellek alanının boyutudur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-484">The number of messages a queue can hold is a function of its message size and the size of the memory area supplied during creation.</span></span> <span data-ttu-id="f6dcf-485">Kuyruğun toplam ileti kapasitesi, her iletideki bayt sayısı, sağlanan bellek alanındaki toplam bayt sayısına bölünerek hesaplanır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-485">The total message capacity of the queue is calculated by dividing the number of bytes in each message into the total number of bytes in the supplied memory area.</span></span>

<span data-ttu-id="f6dcf-486">Örneğin, 100 baytlık bir bellek alanı ile 1 32 bitlik bir sözcüğün (4 bayt) ileti boyutunu destekleyen bir ileti kuyruğu oluşturulduysa, kapasitesi 25 mesaj olur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-486">For example, if a message queue that supports a message size of 1 32-bit word (4 bytes) is created with a 100-byte memory area, its capacity is 25 messages.</span></span>

### <a name="queue-memory-area"></a><span data-ttu-id="f6dcf-487">Kuyruk belleği alanı</span><span class="sxs-lookup"><span data-stu-id="f6dcf-487">Queue Memory Area</span></span>

<span data-ttu-id="f6dcf-488">Daha önce belirtildiği gibi, ileti arabelleğe alma bellek alanı sıra oluşturma sırasında belirtilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-488">As mentioned previously, the memory area for buffering messages is specified during queue creation.</span></span> <span data-ttu-id="f6dcf-489">ThreadX içindeki diğer bellek alanları gibi, hedefin adres alanında herhangi bir yerde bulunabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-489">Like other memory areas in ThreadX, it can be located anywhere in the target's address space.</span></span>

<span data-ttu-id="f6dcf-490">Bu önemli bir özelliktir çünkü uygulamanın önemli ölçüde esnekliğini sağlar.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-490">This is an important feature because it gives the application considerable flexibility.</span></span> <span data-ttu-id="f6dcf-491">Örneğin, bir uygulama performansı artırmak için yüksek hızda RAM 'teki önemli bir kuyruğun bellek alanını bulabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-491">For example, an application might locate the memory area of an important queue in high-speed RAM to improve performance.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="f6dcf-492">İş parçacığı askıya alma</span><span class="sxs-lookup"><span data-stu-id="f6dcf-492">Thread Suspension</span></span>

<span data-ttu-id="f6dcf-493">Bir kuyruktan ileti gönderilmeye ya da almaya çalışırken uygulama iş parçacıkları askıya alabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-493">Application threads can suspend while attempting to send or receive a message from a queue.</span></span> <span data-ttu-id="f6dcf-494">Genellikle, iş parçacığı askıya alma, boş bir kuyruktan ileti bekletmeyi içerir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-494">Typically, thread suspension involves waiting for a message from an empty queue.</span></span> <span data-ttu-id="f6dcf-495">Ancak, bir iş parçacığının bir iletiyi tam sıraya gönderme girişimi de askıya alınması mümkündür.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-495">However, it is also possible for a thread to suspend trying to send a message to a full queue.</span></span>

<span data-ttu-id="f6dcf-496">Askıya alma koşulu çözümlendikten sonra, istenen hizmet tamamlanır ve bekleyen iş parçacığı sürdürülür.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-496">After the condition for suspension is resolved, the service requested is completed and the waiting thread is resumed.</span></span> <span data-ttu-id="f6dcf-497">Aynı sırada birden çok iş parçacığı askıya alınırsa, bunlar askıya alındığı sırada sürdürülür (FıFO).</span><span class="sxs-lookup"><span data-stu-id="f6dcf-497">If multiple threads are suspended on the same queue, they are resumed in the order they were suspended (FIFO).</span></span>

<span data-ttu-id="f6dcf-498">Ancak, uygulama, iş parçacığı askıya alma işlemi için kuyruğa alma hizmeti 'nden önce ***tx_queue_prioritize*** çağırdığında öncelik sürdürme de mümkündür.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-498">However, priority resumption is also possible if the application calls ***tx_queue_prioritize*** prior to the queue service that lifts thread suspension.</span></span> <span data-ttu-id="f6dcf-499">Sıra önceliği belirleme hizmeti, en yüksek öncelikli iş parçacığını askıya alma listesinin önüne koyar, diğer tüm askıya alınan iş parçacıklarını aynı FıFO sırasıyla bırakır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-499">The queue prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

<span data-ttu-id="f6dcf-500">Zaman aşımları tüm sıra getirilmesi için de kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-500">Time-outs are also available for all queue suspensions.</span></span> <span data-ttu-id="f6dcf-501">Temel olarak bir zaman aşımı, iş parçacığının askıya alınmayacak en fazla Zamanlayıcı sayısını belirtir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-501">Basically, a time-out specifies the maximum number of timer ticks the thread will stay suspended.</span></span> <span data-ttu-id="f6dcf-502">Bir zaman aşımı oluşursa, iş parçacığı sürdürülür ve hizmet uygun hata kodu ile birlikte geri döner.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-502">If a time-out occurs, the thread is resumed and the service returns with the appropriate error code.</span></span>

### <a name="queue-send-notification"></a><span data-ttu-id="f6dcf-503">Kuyruk gönderme bildirimi</span><span class="sxs-lookup"><span data-stu-id="f6dcf-503">Queue Send Notification</span></span>

<span data-ttu-id="f6dcf-504">Bazı uygulamalar, bir sıraya her ileti yerleştirildiğinde bildirim almak için bu avantaja sahip olabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-504">Some applications may find it advantageous to be notified whenever a message is placed on a queue.</span></span> <span data-ttu-id="f6dcf-505">ThreadX, ***tx_queue_send_notify*** hizmeti aracılığıyla bu yeteneği sağlar.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-505">ThreadX provides this ability through the ***tx_queue_send_notify*** service.</span></span> <span data-ttu-id="f6dcf-506">Bu hizmet belirtilen sıraya sahip sağlanan uygulama bildirimi işlevini kaydeder.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-506">This service registers the supplied application notification function with the specified queue.</span></span> <span data-ttu-id="f6dcf-507">Daha sonra ThreadX, kuyruğa her ileti gönderildiğinde bu uygulama bildirim işlevini çağırır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-507">ThreadX will subsequently invoke this application notification function whenever a message is sent to the queue.</span></span> <span data-ttu-id="f6dcf-508">Uygulama bildirim işlevi içindeki tam işlem uygulama tarafından belirlenir; Bununla birlikte, genellikle yeni iletiyi işlemek için uygun iş parçacığını sürdürmeden oluşur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-508">The exact processing within the application notification function is determined by the application; however, it typically consists of resuming the appropriate thread for processing the new message.</span></span>

### <a name="queue-event-chainingtrade"></a><span data-ttu-id="f6dcf-509">Olay zincirlemesini sıraya al&trade;</span><span class="sxs-lookup"><span data-stu-id="f6dcf-509">Queue Event chaining&trade;</span></span>

<span data-ttu-id="f6dcf-510">ThreadX içindeki bildirim özellikleri, çeşitli eşitleme olaylarını birbirine zincirlemek için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-510">The notification capabilities in ThreadX can be used to chain various synchronization events together.</span></span> <span data-ttu-id="f6dcf-511">Bu, genellikle tek bir iş parçacığının birden çok eşitleme olayını işlemesi gerektiğinde faydalıdır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-511">This is typically useful when a single thread must process multiple synchronization events.</span></span>

<span data-ttu-id="f6dcf-512">Örneğin, tek bir iş parçacığının beş farklı kuyruktan gelen iletileri işlemekten sorumlu olduğunu ve kullanılabilir bir ileti olmadığında da askıya alınması gerektiğini varsayalım.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-512">For example, suppose a single thread is responsible for processing messages from five different queues and must also suspend when no messages are available.</span></span> <span data-ttu-id="f6dcf-513">Bu, her sıra için bir uygulama bildirim işlevi kaydederek ve ek bir sayma semaforu ile kolayca gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-513">This is easily accomplished by registering an application notification function for each queue and introducing an additional counting semaphore.</span></span> <span data-ttu-id="f6dcf-514">Özellikle, uygulama bildirim işlevi çağrıldığında bir *tx_semaphore_put* gerçekleştirir (semafor sayısı, beş kuyrumdan gelen toplam ileti sayısını temsil eder).</span><span class="sxs-lookup"><span data-stu-id="f6dcf-514">Specifically, the application notification function performs a *tx_semaphore_put* whenever it is called (the semaphore count represents the total number of messages in all five queues).</span></span> <span data-ttu-id="f6dcf-515">İşleme iş parçacığı, *tx_semaphore_get* hizmeti aracılığıyla bu semaforda askıya alınır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-515">The processing thread suspends on this semaphore via the *tx_semaphore_get* service.</span></span> <span data-ttu-id="f6dcf-516">Semafor kullanılabilir olduğunda (Bu durumda, bir ileti kullanılabilir olduğunda!), işleme iş parçacığı sürdürülür.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-516">When the semaphore is available (in this case, when a message is available!), the processing thread is resumed.</span></span> <span data-ttu-id="f6dcf-517">Ardından bir ileti için her kuyruğu birbirine kullanır, bulunan iletiyi işler ve sonraki iletiyi beklemek için başka bir ***tx_semaphore_get*** gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-517">It then interrogates each queue for a message, processes the found message, and performs another ***tx_semaphore_get*** to wait for the next message.</span></span> <span data-ttu-id="f6dcf-518">Bunu olay zincirleme olmadan yapmak oldukça zordur ve büyük olasılıkla daha fazla iş parçacığı ve/veya ek uygulama kodu gerektirir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-518">Accomplishing this without event-chaining is quite difficult and likely would require more threads and/or additional application code.</span></span>

<span data-ttu-id="f6dcf-519">Genel olarak, *olay zincirleme* daha az iş parçacığı, daha az ek yük ve daha küçük RAM gereksinimlerine neden olur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-519">In general, *event-chaining* results in fewer threads, less overhead, and smaller RAM requirements.</span></span> <span data-ttu-id="f6dcf-520">Ayrıca, daha karmaşık sistemlerin eşitleme gereksinimlerini işlemek için yüksek düzeyde esnek bir mekanizma sağlar.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-520">It also provides a highly flexible mechanism to handle synchronization requirements of more complex systems.</span></span>

### <a name="run-time-queue-performance-information"></a><span data-ttu-id="f6dcf-521">Çalışma zamanı sıra performans bilgileri</span><span class="sxs-lookup"><span data-stu-id="f6dcf-521">Run-time Queue Performance Information</span></span>
<span data-ttu-id="f6dcf-522">ThreadX isteğe bağlı çalışma zamanı sıra performans bilgilerini sağlar.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-522">ThreadX provides optional run-time queue performance information.</span></span> <span data-ttu-id="f6dcf-523">ThreadX kitaplığı ve uygulaması tanımlanmış ***TX_QUEUE_ENABLE_PERFORMANCE_INFO*** ile derlenip, threadx aşağıdaki bilgileri biriktirir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-523">If the ThreadX library and application is built with ***TX_QUEUE_ENABLE_PERFORMANCE_INFO*** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="f6dcf-524">Genel sistem için toplam sayı:</span><span class="sxs-lookup"><span data-stu-id="f6dcf-524">Total number for the overall system:</span></span>

  - <span data-ttu-id="f6dcf-525">gönderilen iletiler</span><span class="sxs-lookup"><span data-stu-id="f6dcf-525">messages sent</span></span>

  - <span data-ttu-id="f6dcf-526">alınan iletiler</span><span class="sxs-lookup"><span data-stu-id="f6dcf-526">messages received</span></span>

  - <span data-ttu-id="f6dcf-527">kuyruk boş getirilmesi</span><span class="sxs-lookup"><span data-stu-id="f6dcf-527">queue empty suspensions</span></span>

  - <span data-ttu-id="f6dcf-528">sıra Full getirilmesi</span><span class="sxs-lookup"><span data-stu-id="f6dcf-528">queue full suspensions</span></span>

  - <span data-ttu-id="f6dcf-529">Tam sıra hatası döndürür (askıya alma belirtilmemiş)</span><span class="sxs-lookup"><span data-stu-id="f6dcf-529">queue full error returns (suspension not specified)</span></span>

  - <span data-ttu-id="f6dcf-530">sıra zaman aşımları</span><span class="sxs-lookup"><span data-stu-id="f6dcf-530">queue timeouts</span></span>

<span data-ttu-id="f6dcf-531">Her kuyruğun toplam sayısı:</span><span class="sxs-lookup"><span data-stu-id="f6dcf-531">Total number for each queue:</span></span>

  - <span data-ttu-id="f6dcf-532">gönderilen iletiler</span><span class="sxs-lookup"><span data-stu-id="f6dcf-532">messages sent</span></span>

  - <span data-ttu-id="f6dcf-533">alınan iletiler</span><span class="sxs-lookup"><span data-stu-id="f6dcf-533">messages received</span></span>

  - <span data-ttu-id="f6dcf-534">kuyruk boş getirilmesi</span><span class="sxs-lookup"><span data-stu-id="f6dcf-534">queue empty suspensions</span></span>

  - <span data-ttu-id="f6dcf-535">sıra Full getirilmesi</span><span class="sxs-lookup"><span data-stu-id="f6dcf-535">queue full suspensions</span></span>

  - <span data-ttu-id="f6dcf-536">Tam sıra hatası döndürür (askıya alma belirtilmemiş)</span><span class="sxs-lookup"><span data-stu-id="f6dcf-536">queue full error returns (suspension not specified)</span></span>

  - <span data-ttu-id="f6dcf-537">sıra zaman aşımları</span><span class="sxs-lookup"><span data-stu-id="f6dcf-537">queue timeouts</span></span>

<span data-ttu-id="f6dcf-538">Bu bilgiler, \***tx_queue_performance_info_get** _ ve _ *_tx_queue_performance_system_info_get_* \* Hizmetleri aracılığıyla çalışma zamanında kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-538">This information is available at run-time through the services ***tx_queue_performance_info_get** _ and _*_tx_queue_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="f6dcf-539">Sıra performans bilgileri, uygulamanın düzgün çalışıp çalışmadığını belirlemek için faydalıdır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-539">Queue performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="f6dcf-540">Ayrıca, uygulamayı iyileştirmek için de kullanışlıdır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-540">It is also useful in optimizing the application.</span></span> <span data-ttu-id="f6dcf-541">Örneğin, görece yüksek sayıda "Queue Full getirilmesi", kuyruk boyutunun artışına bir artış önerisinde bulunabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-541">For example, a relatively high number of "queue full suspensions" suggests an increase in the queue size might be beneficial.</span></span>

### <a name="queue-control-block-tx_queue"></a><span data-ttu-id="f6dcf-542">Sıra denetim bloğu TX_QUEUE</span><span class="sxs-lookup"><span data-stu-id="f6dcf-542">Queue Control Block TX_QUEUE</span></span>

<span data-ttu-id="f6dcf-543">Her ileti sırasının özellikleri denetim bloğunda bulunur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-543">The characteristics of each message queue are found in its control block.</span></span> <span data-ttu-id="f6dcf-544">Kuyruktaki ileti sayısı gibi ilginç bilgiler içerir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-544">It contains interesting information such as the number of messages in the queue.</span></span> <span data-ttu-id="f6dcf-545">Bu yapı ***tx_api. h*** dosyasında tanımlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-545">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="f6dcf-546">İleti kuyruğu denetim blokları ayrıca bellekte herhangi bir yerde bulunabilir, ancak her bir işlevin kapsamı dışında tanımlayarak denetimin genel bir yapıyı engellemesini sağlamak en yaygın olarak kullanılır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-546">Message queue control blocks can also be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="message-destination-pitfall"></a><span data-ttu-id="f6dcf-547">İleti hedefi gizli</span><span class="sxs-lookup"><span data-stu-id="f6dcf-547">Message Destination Pitfall</span></span>

<span data-ttu-id="f6dcf-548">Daha önce belirtildiği gibi, iletiler kuyruk alanı ve uygulama veri alanı arasında kopyalanır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-548">As mentioned previously, messages are copied between the queue area and application data areas.</span></span> <span data-ttu-id="f6dcf-549">Alınan bir iletinin hedefinin tüm iletiyi tutabilecek kadar büyük olduğundan emin olmak önemlidir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-549">It is important to ensure the destination for a received message is large enough to hold the entire message.</span></span> <span data-ttu-id="f6dcf-550">Aksi takdirde, ileti hedefini izleyen bellek muhtemelen bozulmuş olur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-550">If not, the memory following the message destination will likely be corrupted.</span></span>

> [!NOTE]
> <span data-ttu-id="f6dcf-551">*Bu, yığında çok küçük bir ileti hedefi olduğunda (bir işlevin dönüş adresini bozmaya benzer bir şey), özellikle de oldukça zaman alır!*</span><span class="sxs-lookup"><span data-stu-id="f6dcf-551">*This is especially lethal when a too-small message destination is on the stack—nothing like corrupting the return address of a function!*</span></span>

## <a name="counting-semaphores"></a><span data-ttu-id="f6dcf-552">Semafor sayma</span><span class="sxs-lookup"><span data-stu-id="f6dcf-552">Counting Semaphores</span></span>

<span data-ttu-id="f6dcf-553">ThreadX, 0 ile 4.294.967.295 arasında değer olarak kullanılan 32 bitlik sayım semaforları sağlar.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-553">ThreadX provides 32-bit counting semaphores that range in value between 0 and 4,294,967,295.</span></span> <span data-ttu-id="f6dcf-554">Semaforları saymak için iki işlem vardır: *tx_semaphore_get* ve *tx_semaphore_put*.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-554">There are two operations for counting semaphores: *tx_semaphore_get* and *tx_semaphore_put*.</span></span> <span data-ttu-id="f6dcf-555">Get işlemi semaforu bir azaltır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-555">The get operation decreases the semaphore by one.</span></span> <span data-ttu-id="f6dcf-556">Semafor 0 ise, get işlemi başarılı olmaz.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-556">If the semaphore is 0, the get operation is not successful.</span></span> <span data-ttu-id="f6dcf-557">Get işleminin tersi, put işlemidir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-557">The inverse of the get operation is the put operation.</span></span>
<span data-ttu-id="f6dcf-558">Semaforu bir tane artırır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-558">It increases the semaphore by one.</span></span>

<span data-ttu-id="f6dcf-559">Her sayım semaforu ortak bir kaynaktır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-559">Each counting semaphore is a public resource.</span></span> <span data-ttu-id="f6dcf-560">ThreadX, sayım semaforlarıyla ilgili hiçbir kısıtlama vermez.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-560">ThreadX places no constraints on how counting semaphores are used.</span></span>

<span data-ttu-id="f6dcf-561">Sayım semaforları genellikle *karşılıklı dışlama* için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-561">Counting semaphores are typically used for *mutual exclusion*.</span></span> <span data-ttu-id="f6dcf-562">Ancak, sayım semaforları olay bildirimi için bir yöntem olarak da kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-562">However, counting semaphores can also be used as a method for event notification.</span></span>

### <a name="mutual-exclusion"></a><span data-ttu-id="f6dcf-563">Karşılıklı dışlama</span><span class="sxs-lookup"><span data-stu-id="f6dcf-563">Mutual Exclusion</span></span>

 <span data-ttu-id="f6dcf-564">Karşılıklı dışlama, iş parçacıklarının belirli uygulama bölümlerine erişimini denetlemeyle ilgilidir ( *kritik bölümler* veya *uygulama kaynakları* da denir).</span><span class="sxs-lookup"><span data-stu-id="f6dcf-564">Mutual exclusion pertains to controlling the access of threads to certain application areas (also called *critical sections* or *application resources*).</span></span> <span data-ttu-id="f6dcf-565">Karşılıklı dışlama için kullanıldığında, semaforun "geçerli sayısı", erişim izni verilen toplam iş parçacığı sayısını temsil eder.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-565">When used for mutual exclusion, the "current count" of a semaphore represents the total number of threads that are allowed access.</span></span> <span data-ttu-id="f6dcf-566">Çoğu durumda, karşılıklı dışlama için kullanılan sayım Semaforlar ilk değeri 1 olur, yani yalnızca bir iş parçacığının aynı anda ilişkili kaynağa erişebileceği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-566">In most cases, counting semaphores used for mutual exclusion will have an initial value of 1, meaning that only one thread can access the associated resource at a time.</span></span> <span data-ttu-id="f6dcf-567">Yalnızca 0 veya 1 değerlerine sahip olan Semaforlar genellikle *ikili Semaforlar* olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-567">Counting semaphores that only have values of 0 or 1 are commonly called *binary semaphores*.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f6dcf-568">*Bir ikili semafor kullanılıyorsa, kullanıcının sahip olduğu bir semaforda aynı iş parçacığının bir get işlemi gerçekleştirmesini önlemesi gerekir. İkinci bir get başarısız olur ve çağıran iş parçacığının sınırsız şekilde askıya alınmasına ve kaynağın kalıcı olmamasından oluşmasına neden olabilir.*</span><span class="sxs-lookup"><span data-stu-id="f6dcf-568">*If a binary semaphore is being used, the user must prevent the same thread from performing a get operation on a semaphore it already owns. A second get would be unsuccessful and could cause indefinite suspension of the calling thread and permanent unavailability of the resource.*</span></span>

### <a name="event-notification"></a><span data-ttu-id="f6dcf-569">Olay bildirimi</span><span class="sxs-lookup"><span data-stu-id="f6dcf-569">Event Notification</span></span>

<span data-ttu-id="f6dcf-570">Ayrıca, bir üretici TÜKETİCİSİNDE bir olay bildirimi olarak sayma semaforları kullanmak da mümkündür.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-570">It is also possible to use counting semaphores as event notification, in a producer-consumer fashion.</span></span> <span data-ttu-id="f6dcf-571">Üretici, her şey kullanılabilir olduğunda semaforu artırırken, Kullanıcı sayma semaforu almayı dener.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-571">The consumer attempts to get the counting semaphore while the producer increases the semaphore whenever something is available.</span></span> <span data-ttu-id="f6dcf-572">Bu tür Semaforlar genellikle 0 ' ın başlangıç değerine sahiptir ve üretici tüketiciye hazırlanmaya bir şey yapana kadar artmaz.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-572">Such semaphores usually have an initial value of 0 and will not increase until the producer has something ready for the consumer.</span></span> <span data-ttu-id="f6dcf-573">Olay bildirimi için kullanılan Semaforlar ***tx_semaphore_ceiling_put*** hizmeti çağrısının kullanımı da avantajlı olabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-573">Semaphores used for event notification may also benefit from use of the ***tx_semaphore_ceiling_put*** service call.</span></span> <span data-ttu-id="f6dcf-574">Bu hizmet, semafor sayısının çağrıda sağlanan değeri hiçbir şekilde aşmamasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-574">This service ensures that the semaphore count never exceeds the value supplied in the call.</span></span>

### <a name="creating-counting-semaphores"></a><span data-ttu-id="f6dcf-575">Sayım semaforları oluşturma</span><span class="sxs-lookup"><span data-stu-id="f6dcf-575">Creating Counting Semaphores</span></span>

<span data-ttu-id="f6dcf-576">Sayım semaforları, başlatma sırasında veya uygulama iş parçacıkları tarafından çalışma zamanında oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-576">Counting semaphores are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="f6dcf-577">Semaforun ilk sayısı oluşturma sırasında belirtilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-577">The initial count of the semaphore is specified during creation.</span></span> <span data-ttu-id="f6dcf-578">Bir uygulamadaki sayım semaforları sayısı için bir sınır yoktur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-578">There is no limit on the number of counting semaphores in an application.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="f6dcf-579">İş parçacığı askıya alma</span><span class="sxs-lookup"><span data-stu-id="f6dcf-579">Thread Suspension</span></span>

<span data-ttu-id="f6dcf-580">Geçerli 0 sayısı ile bir semafor üzerinde alma işlemi gerçekleştirmeye çalışırken uygulama iş parçacıkları askıya alabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-580">Application threads can suspend while attempting to perform a get operation on a semaphore with a current count of 0.</span></span>

<span data-ttu-id="f6dcf-581">Bir put işlemi gerçekleştirildikten sonra, askıya alınan iş parçacığının alma işlemi gerçekleştirilir ve iş parçacığı sürdürülür.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-581">After a put operation is performed, the suspended thread's get operation is performed and the thread is resumed.</span></span> <span data-ttu-id="f6dcf-582">Aynı sayım semaforu üzerinde birden çok iş parçacığı askıya alınırsa, bunlar askıya alındıkları sırada sürdürülür (FıFO).</span><span class="sxs-lookup"><span data-stu-id="f6dcf-582">If multiple threads are suspended on the same counting semaphore, they are resumed in the same order they were suspended (FIFO).</span></span>

<span data-ttu-id="f6dcf-583">Ancak, uygulama iş parçacığı askıya alma çağrısından önce tx_semaphore_prioritize, uygulamanın semafor put çağrısından önce  , öncelik sürdürme de mümkündür.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-583">However, priority resumption is also possible if the application calls ***tx_semaphore_prioritize*** prior to the semaphore put call that lifts thread suspension.</span></span> <span data-ttu-id="f6dcf-584">Semafor öncelik sıralaması hizmeti, en yüksek öncelikli iş parçacığını askıya alma listesinin önüne koyar, diğer tüm askıya alınan iş parçacıklarını aynı FıFO sırasıyla bırakır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-584">The semaphore prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

### <a name="semaphore-put-notification"></a><span data-ttu-id="f6dcf-585">Semafor put bildirimi</span><span class="sxs-lookup"><span data-stu-id="f6dcf-585">Semaphore Put Notification</span></span>

<span data-ttu-id="f6dcf-586">Bazı uygulamalar, bir semafor her gerçekleştiğinde bildirimde bulunulmaya yönelik avantajın olduğunu fark edebilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-586">Some applications may find it advantageous to be notified whenever a semaphore is put.</span></span> <span data-ttu-id="f6dcf-587">ThreadX, ***tx_semaphore_put_notify*** hizmeti aracılığıyla bu yeteneği sağlar.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-587">ThreadX provides this ability through the ***tx_semaphore_put_notify*** service.</span></span> <span data-ttu-id="f6dcf-588">Bu hizmet, belirtilen semafor ile sağlanan uygulama bildirimi işlevini kaydeder.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-588">This service registers the supplied application notification function with the specified semaphore.</span></span> <span data-ttu-id="f6dcf-589">Artık ThreadX, semafor her gerçekleştiğinde bu uygulama bildirim işlevini çağırır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-589">ThreadX will subsequently invoke this application notification function whenever the semaphore is put.</span></span> <span data-ttu-id="f6dcf-590">Uygulama bildirim işlevi içindeki tam işlem uygulama tarafından belirlenir; Bununla birlikte, genellikle yeni semafor put olayını işlemek için uygun iş parçacığını sürdürmeden oluşur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-590">The exact processing within the application notification function is determined by the application; however, it typically consists of resuming the appropriate thread for processing the new semaphore put event.</span></span>

### <a name="semaphore-event-chainingtrade"></a><span data-ttu-id="f6dcf-591">Semafor olay zinciri&trade;</span><span class="sxs-lookup"><span data-stu-id="f6dcf-591">Semaphore Event chaining&trade;</span></span>

<span data-ttu-id="f6dcf-592">ThreadX içindeki bildirim özellikleri, çeşitli eşitleme olaylarını birbirine zincirlemek için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-592">The notification capabilities in ThreadX can be used to chain various synchronization events together.</span></span> <span data-ttu-id="f6dcf-593">Bu, genellikle tek bir iş parçacığının birden çok eşitleme olayını işlemesi gerektiğinde faydalıdır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-593">This is typically useful when a single thread must process multiple synchronization events.</span></span>

<span data-ttu-id="f6dcf-594">Örneğin, bir kuyruk iletisi, olay bayrakları ve semafor için ayrı iş parçacıkları askıya almak yerine, uygulama her nesne için bir bildirim yordamı kaydedebilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-594">For example, instead of having separate threads suspend for a queue message, event flags, and a semaphore, the application can register a notification routine for each object.</span></span> <span data-ttu-id="f6dcf-595">Çağrıldığında, uygulama bildirimi yordamı tek bir iş parçacığını sürdürür, bu da her bir nesneye sorgulanamıyor, bu da yeni olayı bulup işleyebilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-595">When invoked, the application notification routine can then resume a single thread, which can interrogate each object to find and process the new event.</span></span>

<span data-ttu-id="f6dcf-596">Genel olarak, *olay zincirleme* daha az iş parçacığı, daha az ek yük ve daha küçük RAM gereksinimlerine neden olur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-596">In general, *event-chaining* results in fewer threads, less overhead, and smaller RAM requirements.</span></span> <span data-ttu-id="f6dcf-597">Ayrıca, daha karmaşık sistemlerin eşitleme gereksinimlerini işlemek için yüksek düzeyde esnek bir mekanizma sağlar.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-597">It also provides a highly flexible mechanism to handle synchronization requirements of more complex systems.</span></span>

### <a name="run-time-semaphore-performance-information"></a><span data-ttu-id="f6dcf-598">Çalışma zamanı semaforu performans bilgileri</span><span class="sxs-lookup"><span data-stu-id="f6dcf-598">Run-time Semaphore Performance Information</span></span>

<span data-ttu-id="f6dcf-599">ThreadX isteğe bağlı çalışma zamanı semaforu performans bilgilerini sağlar.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-599">ThreadX provides optional run-time semaphore performance information.</span></span> <span data-ttu-id="f6dcf-600">ThreadX kitaplığı ve uygulaması tanımlanmış **TX_SEMAPHORE_ENABLE_PERFORMANCE_INFO** ile derlenip, threadx aşağıdaki bilgileri biriktirir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-600">If the ThreadX library and application is built with **TX_SEMAPHORE_ENABLE_PERFORMANCE_INFO** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="f6dcf-601">Genel sistem için toplam sayı:</span><span class="sxs-lookup"><span data-stu-id="f6dcf-601">Total number for the overall system:</span></span>

  - <span data-ttu-id="f6dcf-602">semafor koyar</span><span class="sxs-lookup"><span data-stu-id="f6dcf-602">semaphore puts</span></span>

  - <span data-ttu-id="f6dcf-603">semafor alır</span><span class="sxs-lookup"><span data-stu-id="f6dcf-603">semaphore gets</span></span>

  - <span data-ttu-id="f6dcf-604">semafor Get getirilmesi</span><span class="sxs-lookup"><span data-stu-id="f6dcf-604">semaphore get suspensions</span></span>

  - <span data-ttu-id="f6dcf-605">Semafor zaman aşımlarını al</span><span class="sxs-lookup"><span data-stu-id="f6dcf-605">semaphore get timeouts</span></span>

<span data-ttu-id="f6dcf-606">Her semaforun toplam sayısı:</span><span class="sxs-lookup"><span data-stu-id="f6dcf-606">Total number for each semaphore:</span></span>

  - <span data-ttu-id="f6dcf-607">semafor koyar</span><span class="sxs-lookup"><span data-stu-id="f6dcf-607">semaphore puts</span></span>

  - <span data-ttu-id="f6dcf-608">semafor alır</span><span class="sxs-lookup"><span data-stu-id="f6dcf-608">semaphore gets</span></span>

  - <span data-ttu-id="f6dcf-609">semafor Get getirilmesi</span><span class="sxs-lookup"><span data-stu-id="f6dcf-609">semaphore get suspensions</span></span>

  - <span data-ttu-id="f6dcf-610">Semafor zaman aşımlarını al</span><span class="sxs-lookup"><span data-stu-id="f6dcf-610">semaphore get timeouts</span></span>

<span data-ttu-id="f6dcf-611">Bu bilgiler, \***tx_semaphore_performance_info_get** _ ve _ *_tx_semaphore_performance_system_info_get_* \* Hizmetleri aracılığıyla çalışma zamanında kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-611">This information is available at run-time through the services ***tx_semaphore_performance_info_get** _ and _*_tx_semaphore_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="f6dcf-612">Semafor performans bilgileri, uygulamanın düzgün çalışıp çalışmadığını belirlemek için faydalıdır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-612">Semaphore performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="f6dcf-613">Ayrıca, uygulamayı iyileştirmek için de kullanışlıdır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-613">It is also useful in optimizing the application.</span></span> <span data-ttu-id="f6dcf-614">Örneğin, görece yüksek sayıda "semafor Get zaman aşımları", diğer iş parçacıklarının kaynakları çok uzun süre olarak tuttuklarından kaynaklanabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-614">For example, a relatively high number of "semaphore get timeouts" might suggest that other threads are holding resources too long.</span></span>

### <a name="semaphore-control-block-tx_semaphore"></a><span data-ttu-id="f6dcf-615">Semafor denetim bloğu TX_SEMAPHORE</span><span class="sxs-lookup"><span data-stu-id="f6dcf-615">Semaphore Control Block TX_SEMAPHORE</span></span>

<span data-ttu-id="f6dcf-616">Her sayım semaforun özellikleri denetim bloğunda bulunur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-616">The characteristics of each counting semaphore are found in its control block.</span></span> <span data-ttu-id="f6dcf-617">Geçerli semafor sayısı gibi bilgileri içerir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-617">It contains information such as the current semaphore count.</span></span> <span data-ttu-id="f6dcf-618">Bu yapı ***tx_api. h*** dosyasında tanımlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-618">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="f6dcf-619">Semafor denetim blokları bellekte herhangi bir yerde bulunabilir, ancak herhangi bir işlevin kapsamı dışında tanımlayarak denetimin genel bir yapıyı engellemesini sağlamak yaygın olarak kullanılır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-619">Semaphore control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="deadly-embrace"></a><span data-ttu-id="f6dcf-620">Dar küme</span><span class="sxs-lookup"><span data-stu-id="f6dcf-620">Deadly Embrace</span></span>

<span data-ttu-id="f6dcf-621">Karşılıklı dışlama için kullanılan semaforlarla ilişkili en ilgi çekici ve tehlikeli her bir tane, büyük *küme ayracı* olur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-621">One of the most interesting and dangerous pitfalls associated with semaphores used for mutual exclusion is the *deadly embrace*.</span></span> <span data-ttu-id="f6dcf-622">, *Bir veya daha* fazla iş parçacığının, birbirini zaten sahip olan Semaforlar alınmaya çalışılırken süresiz olarak askıya alındığı bir durumdur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-622">A deadly embrace, or *deadlock*, is a condition in which two or more threads are suspended indefinitely while attempting to get semaphores already owned by each other.</span></span>

<span data-ttu-id="f6dcf-623">Bu koşul en iyi iki iş parçacığı, iki semafor örneği tarafından gösterilmiştir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-623">This condition is best illustrated by a two thread, two semaphore example.</span></span> <span data-ttu-id="f6dcf-624">İlk iş parçacığının ilk semafora sahip olduğunu ve ikinci iş parçacığının ikinci semafora sahip olduğunu varsayalım.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-624">Suppose the first thread owns the first semaphore and the second thread owns the second semaphore.</span></span> <span data-ttu-id="f6dcf-625">İlk iş parçacığı ikinci semaforu almayı denerse ve ikinci iş parçacığı ilk semaforu almaya çalışırsa, her iki iş parçacığı de bir kilitlenme koşulu girer.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-625">If the first thread attempts to get the second semaphore and at the same time the second thread attempts to get the first semaphore, both threads enter a deadlock condition.</span></span> <span data-ttu-id="f6dcf-626">Ayrıca, bu iş parçacıkları sonsuza kadar askıya alınırsa, ilişkili kaynakları da süresiz olarak kilitlenir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-626">In addition, if these threads stay suspended forever, their associated resources are locked-out forever as well.</span></span> <span data-ttu-id="f6dcf-627">Şekil 8 ' de bu örnek gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-627">Figure 8 illustrates this example.</span></span>

<span data-ttu-id="f6dcf-628">**Dar** (örnek)</span><span class="sxs-lookup"><span data-stu-id="f6dcf-628">**Deadly Embrace** (example)</span></span>

![Askıya alınan Iş parçacıkları örneği](./media/user-guide/example-suspended-threads.png)

<span data-ttu-id="f6dcf-630">**ŞEKIL 8. Askıya alınan Iş parçacıkları örneği**</span><span class="sxs-lookup"><span data-stu-id="f6dcf-630">**FIGURE 8. Example of Suspended Threads**</span></span>

<span data-ttu-id="f6dcf-631">Gerçek zamanlı sistemler için, iş parçacıklarının Semaforlar tarafından nasıl elde edileceği hakkında bazı kısıtlamalar yerleştirilerek, kilitlenmeleri engellenebilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-631">For real-time systems, deadly embraces can be prevented by placing certain restrictions on how threads obtain semaphores.</span></span> <span data-ttu-id="f6dcf-632">İş parçacıkları tek seferde yalnızca bir semafora sahip olabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-632">Threads can only have one semaphore at a time.</span></span> <span data-ttu-id="f6dcf-633">Alternatif olarak, iş parçacıkları bunları aynı sırada topladıklarında birden fazla semafora sahip olabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-633">Alternatively, threads can own multiple semaphores if they gather them in the same order.</span></span> <span data-ttu-id="f6dcf-634">Önceki örnekte, ilk ve ikinci semaforu sırayla ilk ve ikinci semaforu elde alıyorsa, bu, geçersiz ayraç engellenir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-634">In the previous example, if the first and second thread obtain the first and second semaphore in order, the deadly embrace is prevented.</span></span>

> [!TIP]
> <span data-ttu-id="f6dcf-635">*Ayrıca, bir küme ayracından kurtarmak üzere alma işlemiyle ilişkili askıya alma zaman aşımını kullanmak da mümkündür.*</span><span class="sxs-lookup"><span data-stu-id="f6dcf-635">*It is also possible to use the suspension time-out associated with the get operation to recover from a deadly embrace.*</span></span>

### <a name="priority-inversion"></a><span data-ttu-id="f6dcf-636">Öncelikli Inversion</span><span class="sxs-lookup"><span data-stu-id="f6dcf-636">Priority Inversion</span></span>

<span data-ttu-id="f6dcf-637">Karşılıklı dışlama semaforları ile ilişkili başka bir giriş de öncelikli bir sürümdür.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-637">Another pitfall associated with mutual exclusion semaphores is priority inversion.</span></span> <span data-ttu-id="f6dcf-638">Bu konu, "[Iş parçacığı önceliği](#thread-priority-pitfalls)konusundaki" bölümünde daha ayrıntılı olarak ele alınmıştır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-638">This topic is discussed more fully in "[Thread Priority Pitfalls](#thread-priority-pitfalls)".</span></span>

<span data-ttu-id="f6dcf-639">Temel sorun, düşük öncelikli bir iş parçacığının daha yüksek öncelikli iş parçacığı gerektiren bir semafora sahip olduğu bir durumdan kaynaklanır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-639">The basic problem results from a situation in which a lower-priority thread has a semaphore that a higher priority thread needs.</span></span> <span data-ttu-id="f6dcf-640">Bu, normal bir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-640">This in itself is normal.</span></span> <span data-ttu-id="f6dcf-641">Bununla birlikte, aralarında önceliklere sahip olan iş parçacıkları öncelik inen son kararlı olmayan bir süreye neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-641">However, threads with priorities in between them may cause the priority inversion to last a nondeterministic amount of time.</span></span> <span data-ttu-id="f6dcf-642">Bu, iş parçacığı önceliklerinin dikkatli bir şekilde seçilebileceği, önalım-Threshold kullanılarak işlenebilir ve kaynağın sahibi olan iş parçacığının önceliği yüksek öncelikli iş parçacığından daha geçici olarak oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-642">This can be handled through careful selection of thread priorities, using preemption-threshold, and temporarily raising the priority of the thread that owns the resource to that of the high priority thread.</span></span>

## <a name="mutexes"></a><span data-ttu-id="f6dcf-643">Zaman Uyumu Sağlayıcılar</span><span class="sxs-lookup"><span data-stu-id="f6dcf-643">Mutexes</span></span>

<span data-ttu-id="f6dcf-644">Semafora ek olarak, ThreadX bir mutex nesnesi de sağlar.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-644">In addition to semaphores, ThreadX also provides a mutex object.</span></span> <span data-ttu-id="f6dcf-645">Bir mutex, temelde bir iş parçacığının tek seferde bir mutex 'e sahip olabileceği anlamına gelen bir ikili semafor olur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-645">A mutex is basically a binary semaphore, which means that only one thread can own a mutex at a time.</span></span> <span data-ttu-id="f6dcf-646">Ayrıca, aynı iş parçacığı, sahip olunan bir mutex üzerinde başarılı bir mutex Get işlemini birden çok kez gerçekleştirebilir, 4.294.967.295 tam olarak olur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-646">In addition, the same thread may perform a successful mutex get operation on an owned mutex multiple times, 4,294,967,295 to be exact.</span></span> <span data-ttu-id="f6dcf-647">Mutex nesnesinde iki işlem vardır: \***tx_mutex_get** _ ve _ *_tx_mutex_put_* \*.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-647">There are two operations on the mutex object: ***tx_mutex_get** _ and _*_tx_mutex_put_\*\*.</span></span> <span data-ttu-id="f6dcf-648">Get işlemi, başka bir iş parçacığına ait bulunmayan bir mutex edinir, PUT işlemi daha önce edinilen bir mutex 'i serbest bırakır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-648">The get operation obtains a mutex not owned by another thread, while the put operation releases a previously obtained mutex.</span></span> <span data-ttu-id="f6dcf-649">Bir mutex 'i serbest bırakmak için bir iş parçacığında, put işlemlerinin sayısı önceki Get işlemlerinin sayısına eşit olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-649">For a thread to release a mutex, the number of put operations must equal the number of prior get operations.</span></span>

<span data-ttu-id="f6dcf-650">Her Mutex ortak bir kaynaktır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-650">Each mutex is a public resource.</span></span> <span data-ttu-id="f6dcf-651">ThreadX, zaman uyumu sağlayıcılar için kullanım kısıtlamaları yoktur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-651">ThreadX places no constraints on how mutexes are used.</span></span>

<span data-ttu-id="f6dcf-652">ThreadX *mukapsamalarla yalnızca karşılıklı dışlama* için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-652">ThreadX mutexes are used solely for *mutual exclusion*.</span></span> <span data-ttu-id="f6dcf-653">Sayma semaforlarından farklı olarak, zaman uyumu sağlayıcılar olay bildirimi için bir yöntem olarak kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-653">Unlike counting semaphores, mutexes have no use as a method for event notification.</span></span>

### <a name="mutex-mutual-exclusion"></a><span data-ttu-id="f6dcf-654">Mutex karşılıklı dışlaması</span><span class="sxs-lookup"><span data-stu-id="f6dcf-654">Mutex Mutual Exclusion</span></span>

<span data-ttu-id="f6dcf-655">Sayım semaforu bölümündeki tartışmaya benzer şekilde, karşılıklı dışlama, iş parçacıklarının belirli uygulama bölgelerine erişimini denetlemeyle ( *kritik bölümler* veya *uygulama kaynakları* olarak da bilinir) ilgilidir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-655">Similar to the discussion in the counting semaphore section, mutual exclusion pertains to controlling the access of threads to certain application areas (also called *critical sections* or *application resources*).</span></span> <span data-ttu-id="f6dcf-656">Kullanılabilir olduğunda, bir ThreadX mutex 'in sahiplik sayısı 0 olur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-656">When available, a ThreadX mutex will have an ownership count of 0.</span></span> <span data-ttu-id="f6dcf-657">Mutex bir iş parçacığı tarafından alındıktan sonra, mutex üzerinde gerçekleştirilen başarılı alma işlemleri için bir kez, her başarılı Put işlemi için azaltılır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-657">After the mutex is obtained by a thread, the ownership count is incremented once for every successful get operation performed on the mutex and decremented for every successful put operation.</span></span>

### <a name="creating-mutexes"></a><span data-ttu-id="f6dcf-658">Birbirini kapsamayan oluşturma</span><span class="sxs-lookup"><span data-stu-id="f6dcf-658">Creating Mutexes</span></span>

<span data-ttu-id="f6dcf-659">ThreadX muizlik, başlatma sırasında veya uygulama iş parçacıkları tarafından çalışma zamanı sırasında oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-659">ThreadX mutexes are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="f6dcf-660">Bir mutex 'in ilk koşulu her zaman "kullanılabilir" dır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-660">The initial condition of a mutex is always "available."</span></span> <span data-ttu-id="f6dcf-661">Ayrıca, *Öncelik devralma* seçili olarak bir mutex oluşturulabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-661">A mutex may also be created with *priority inheritance* selected.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="f6dcf-662">İş parçacığı askıya alma</span><span class="sxs-lookup"><span data-stu-id="f6dcf-662">Thread Suspension</span></span>

<span data-ttu-id="f6dcf-663">Uygulama iş parçacıkları, zaten başka bir iş parçacığına ait olan bir mutex üzerinde alma işlemi gerçekleştirmeye çalışırken askıya alabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-663">Application threads can suspend while attempting to perform a get operation on a mutex already owned by another thread.</span></span>

<span data-ttu-id="f6dcf-664">Sahip iş parçacığı tarafından aynı sayıda Put işlemi gerçekleştirildikten sonra, askıya alınan iş parçacığının alma işlemi gerçekleştirilir, bu da mutex 'in sahipliğini verir ve iş parçacığı sürdürülür.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-664">After the same number of put operations are performed by the owning thread, the suspended thread's get operation is performed, giving it ownership of the mutex, and the thread is resumed.</span></span> <span data-ttu-id="f6dcf-665">Aynı mutex üzerinde birden fazla iş parçacığı askıya alınırsa, bunlar askıya alındığı sırada sürdürülür (FıFO).</span><span class="sxs-lookup"><span data-stu-id="f6dcf-665">If multiple threads are suspended on the same mutex, they are resumed in the same order they were suspended (FIFO).</span></span>

<span data-ttu-id="f6dcf-666">Ancak, bir öncelik sürdürme, oluşturma sırasında mutex önceliği devralımı seçildiyse otomatik olarak yapılır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-666">However, priority resumption is done automatically if the mutex priority inheritance was selected during creation.</span></span> <span data-ttu-id="f6dcf-667">Uygulama, iş parçacığı askıya alma çağrısını askıya alan mutex put çağrısından önce ***tx_mutex_prioritize*** çağırdığında öncelik sürdürme de mümkündür.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-667">Priority resumption is also possible if the application calls ***tx_mutex_prioritize*** prior to the mutex put call that lifts thread suspension.</span></span> <span data-ttu-id="f6dcf-668">Mutex öncelik sıralaması hizmeti, en yüksek öncelikli iş parçacığını askıya alma listesinin önüne koyar, diğer tüm askıya alınan iş parçacıklarını aynı FıFO sırasıyla bırakır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-668">The mutex prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

### <a name="run-time-mutex-performance-information"></a><span data-ttu-id="f6dcf-669">Çalışma zamanı mutex performans bilgileri</span><span class="sxs-lookup"><span data-stu-id="f6dcf-669">Run-time Mutex Performance Information</span></span>

<span data-ttu-id="f6dcf-670">ThreadX isteğe bağlı çalışma zamanı mutex performans bilgilerini sağlar.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-670">ThreadX provides optional run-time mutex performance information.</span></span> <span data-ttu-id="f6dcf-671">ThreadX kitaplığı ve uygulaması tanımlanmış **TX_MUTEX_ENABLE_PERFORMANCE_INFO** ile derlenip, threadx aşağıdaki bilgileri biriktirir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-671">If the ThreadX library and application is built with **TX_MUTEX_ENABLE_PERFORMANCE_INFO** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="f6dcf-672">Genel sistem için toplam sayı:</span><span class="sxs-lookup"><span data-stu-id="f6dcf-672">Total number for the overall system:</span></span>

- <span data-ttu-id="f6dcf-673">mutex koyar</span><span class="sxs-lookup"><span data-stu-id="f6dcf-673">mutex puts</span></span>

- <span data-ttu-id="f6dcf-674">Mutex zaman alır</span><span class="sxs-lookup"><span data-stu-id="f6dcf-674">mutex gets</span></span>

- <span data-ttu-id="f6dcf-675">mutex Get getirilmesi</span><span class="sxs-lookup"><span data-stu-id="f6dcf-675">mutex get suspensions</span></span>

- <span data-ttu-id="f6dcf-676">Mutex zaman aşımlarını al</span><span class="sxs-lookup"><span data-stu-id="f6dcf-676">mutex get timeouts</span></span>

- <span data-ttu-id="f6dcf-677">mutex öncelik Inversions 'ları</span><span class="sxs-lookup"><span data-stu-id="f6dcf-677">mutex priority inversions</span></span>

- <span data-ttu-id="f6dcf-678">mutex öncelik Inheritances</span><span class="sxs-lookup"><span data-stu-id="f6dcf-678">mutex priority inheritances</span></span>

<span data-ttu-id="f6dcf-679">Her bir mutex için toplam sayı:</span><span class="sxs-lookup"><span data-stu-id="f6dcf-679">Total number for each mutex:</span></span>

  - <span data-ttu-id="f6dcf-680">mutex koyar</span><span class="sxs-lookup"><span data-stu-id="f6dcf-680">mutex puts</span></span>

  - <span data-ttu-id="f6dcf-681">Mutex zaman alır</span><span class="sxs-lookup"><span data-stu-id="f6dcf-681">mutex gets</span></span>

  - <span data-ttu-id="f6dcf-682">mutex Get getirilmesi</span><span class="sxs-lookup"><span data-stu-id="f6dcf-682">mutex get suspensions</span></span>

  - <span data-ttu-id="f6dcf-683">Mutex zaman aşımlarını al</span><span class="sxs-lookup"><span data-stu-id="f6dcf-683">mutex get timeouts</span></span>

  - <span data-ttu-id="f6dcf-684">mutex öncelik Inversions 'ları</span><span class="sxs-lookup"><span data-stu-id="f6dcf-684">mutex priority inversions</span></span>

  - <span data-ttu-id="f6dcf-685">mutex öncelik Inheritances</span><span class="sxs-lookup"><span data-stu-id="f6dcf-685">mutex priority inheritances</span></span>

<span data-ttu-id="f6dcf-686">Bu bilgiler, \***tx_mutex_performance_info_get** _ ve _ *_tx_mutex_performance_system_info_get_* \* Hizmetleri aracılığıyla çalışma zamanında kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-686">This information is available at run-time through the services ***tx_mutex_performance_info_get** _ and _*_tx_mutex_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="f6dcf-687">Mutex performans bilgileri, uygulamanın düzgün çalışıp çalışmadığını belirlemek için faydalıdır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-687">Mutex performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="f6dcf-688">Ayrıca, uygulamayı iyileştirmek için de kullanışlıdır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-688">It is also useful in optimizing the application.</span></span> <span data-ttu-id="f6dcf-689">Örneğin, görece yüksek sayıda "mutex Get zaman aşımları", diğer iş parçacıklarının kaynakları çok uzun tuttuklarından kaynaklanabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-689">For example, a relatively high number of "mutex get timeouts" might suggest that other threads are holding resources too long.</span></span>

### <a name="mutex-control-block-tx_mutex"></a><span data-ttu-id="f6dcf-690">Mutex denetim bloğu TX_MUTEX</span><span class="sxs-lookup"><span data-stu-id="f6dcf-690">Mutex Control Block TX_MUTEX</span></span>

<span data-ttu-id="f6dcf-691">Her bir mutex 'in özellikleri denetim bloğunda bulunur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-691">The characteristics of each mutex are found in its control block.</span></span> <span data-ttu-id="f6dcf-692">Mutex sahibi olan iş parçacığının işaretçisi ile birlikte geçerli mutex sahiplik sayısı gibi bilgileri içerir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-692">It contains information such as the current mutex ownership count along with the pointer of the thread that owns the mutex.</span></span> <span data-ttu-id="f6dcf-693">Bu yapı ***tx_api. h*** dosyasında tanımlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-693">This structure is defined in the ***tx_api.h*** file.</span></span> <span data-ttu-id="f6dcf-694">Mutex denetim blokları bellekte herhangi bir yerde bulunabilir, ancak herhangi bir işlevin kapsamı dışında tanımlayarak denetimin genel bir yapıyı engellemesini sağlamak yaygın olarak kullanılır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-694">Mutex control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="deadly-embrace"></a><span data-ttu-id="f6dcf-695">Dar küme</span><span class="sxs-lookup"><span data-stu-id="f6dcf-695">Deadly Embrace</span></span>

<span data-ttu-id="f6dcf-696">Mutex sahipliğiyle ilişkili en ilgi çekici ve tehlikeli her bir tane, büyük *küme ayracı* olur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-696">One of the most interesting and dangerous pitfalls associated with mutex ownership is the *deadly embrace*.</span></span> <span data-ttu-id="f6dcf-697">Bir veya daha fazla iş parçacığının, diğer iş parçacıklarından zaten sahip olan bir mutex alınmaya çalışılırken *süresiz olarak askıya* alındığı bir durumdur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-697">A deadly embrace, or *deadlock*, is a condition where two or more threads are suspended indefinitely while attempting to get a mutex already owned by the other threads.</span></span> <span data-ttu-id="f6dcf-698">Geçersiz kılmadan *ve düzeltmelerinin* tartışılması, mutex nesnesi için de tamamen geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-698">The discussion of *deadly embrace* and its remedies are completely valid for the mutex object as well.</span></span>

### <a name="priority-inversion"></a><span data-ttu-id="f6dcf-699">Öncelikli Inversion</span><span class="sxs-lookup"><span data-stu-id="f6dcf-699">Priority Inversion</span></span>

<span data-ttu-id="f6dcf-700">Daha önce belirtildiği gibi, karşılıklı dışlamaya ilişkin büyük bir ana hat öncelik Inversion olur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-700">As mentioned previously, a major pitfall associated with mutual exclusion is priority inversion.</span></span> <span data-ttu-id="f6dcf-701">Bu konu, "[Iş parçacığı önceliği](#thread-priority-pitfalls)konusundaki" bölümünde daha ayrıntılı olarak ele alınmıştır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-701">This topic is discussed more fully in "[Thread Priority Pitfalls](#thread-priority-pitfalls)".</span></span>

<span data-ttu-id="f6dcf-702">Temel sorun, düşük öncelikli bir iş parçacığının daha yüksek öncelikli iş parçacığı gerektiren bir semafora sahip olduğu bir durumdan kaynaklanır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-702">The basic problem results from a situation in which a lower priority thread has a semaphore that a higher priority thread needs.</span></span> <span data-ttu-id="f6dcf-703">Bu, normal bir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-703">This in itself is normal.</span></span> <span data-ttu-id="f6dcf-704">Bununla birlikte, aralarında önceliklere sahip olan iş parçacıkları öncelik inen son kararlı olmayan bir süreye neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-704">However, threads with priorities in between them may cause the priority inversion to last a nondeterministic amount of time.</span></span> <span data-ttu-id="f6dcf-705">Daha önce tartışılan Semaforlardan farklı olarak, ThreadX mutex nesnesi isteğe bağlı *öncelikli devralıma* sahiptir</span><span class="sxs-lookup"><span data-stu-id="f6dcf-705">Unlike semaphores discussed previously, the ThreadX mutex object has optional *priority inheritance*.</span></span> <span data-ttu-id="f6dcf-706">Öncelikli mirasın arkasındaki temel düşünce, düşük öncelikli bir iş parçacığının önceliği geçici olarak, düşük öncelikli iş parçacığına ait olan aynı mutex 'i isteyen yüksek öncelikli bir iş parçacığının önceliği olarak yükseltilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-706">The basic idea behind priority inheritance is that a lower priority thread has its priority raised temporarily to the priority of a high priority thread that wants the same mutex owned by the lower priority thread.</span></span> <span data-ttu-id="f6dcf-707">Düşük öncelikli iş parçacığı mutex 'i serbest bıraktığında, özgün önceliği geri yüklenir ve daha yüksek öncelikli iş parçacığına mutex 'in sahipliği verilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-707">When the lower priority thread releases the mutex, its original priority is then restored and the higher priority thread is given ownership of the mutex.</span></span> <span data-ttu-id="f6dcf-708">Bu özellik, düşük öncelikli iş parçacığının mutex 'i tuttuğu zamana kadar Inversion miktarı arasında sınırlama yaparak belirleyici olmayan öncelikli sürümü ortadan kaldırır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-708">This feature eliminates nondeterministic priority inversion by bounding the amount of inversion to the time the lower priority thread holds the mutex.</span></span> <span data-ttu-id="f6dcf-709">Tabii ki, bu bölümde daha önce ele alınan önemli olmayan öncelik Inversion 'ı ele almak için bahsedilen teknikler de de aynı zamanda zaman uyumu sağlayıcılar ile de geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-709">Of course, the techniques discussed earlier in this chapter to handle nondeterministic priority inversion are also valid with mutexes as well.</span></span>

## <a name="event-flags"></a><span data-ttu-id="f6dcf-710">Olay bayrakları</span><span class="sxs-lookup"><span data-stu-id="f6dcf-710">Event Flags</span></span>

<span data-ttu-id="f6dcf-711">Olay bayrakları, iş parçacığı eşitlemesi için güçlü bir araç sağlar.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-711">Event flags provide a powerful tool for thread synchronization.</span></span> <span data-ttu-id="f6dcf-712">Her olay bayrağı tek bir bit ile temsil edilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-712">Each event flag is represented by a single bit.</span></span> <span data-ttu-id="f6dcf-713">Olay bayrakları 32 gruplar halinde düzenlenir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-713">Event flags are arranged in groups of 32.</span></span> <span data-ttu-id="f6dcf-714">İş parçacıkları bir gruptaki tüm 32 olay bayraklarıyla aynı anda çalışabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-714">Threads can operate on all 32 event flags in a group at the same time.</span></span> <span data-ttu-id="f6dcf-715">Olaylar \***tx_event_flags_set** _ tarafından ayarlanır ve _ *_tx_event_flags_get_* \* tarafından alınır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-715">Events are set by ***tx_event_flags_set** _ and are retrieved by _*_tx_event_flags_get_\*\*.</span></span>

<span data-ttu-id="f6dcf-716">Olay bayraklarını ayarlama, geçerli olay bayrakları ve yeni olay bayrakları arasındaki mantıksal bir ve/veya işlemle yapılır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-716">Setting event flags is done with a logical AND/OR operation between the current event flags and the new event flags.</span></span> <span data-ttu-id="f6dcf-717">***Tx_event_flags_set*** çağrısında mantıksal işlemin türü (bir ve veya veya ya da) belirtilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-717">The type of logical operation (either an AND or OR) is specified in the ***tx_event_flags_set*** call.</span></span>

<span data-ttu-id="f6dcf-718">Olay bayraklarının alınması için benzer mantıksal seçenekler vardır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-718">There are similar logical options for retrieval of event flags.</span></span> <span data-ttu-id="f6dcf-719">Get isteği, belirtilen tüm olay bayraklarının gerektiğini (mantıksal ve) belirtebilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-719">A get request can specify that all specified event flags are required (a logical AND).</span></span>

<span data-ttu-id="f6dcf-720">Alternatif olarak, bir get isteği, belirtilen olay bayraklarının herhangi birinin isteği (mantıksal veya) yerine getireceğini belirtebilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-720">Alternatively, a get request can specify that any of the specified event flags will satisfy the request (a logical OR).</span></span> <span data-ttu-id="f6dcf-721">Olay bayrakları almayla ilişkili mantıksal işlemin türü ***tx_event_flags_get*** çağrısında belirtilmiştir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-721">The type of logical operation associated with event flags retrieval is specified in the ***tx_event_flags_get*** call.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f6dcf-722">*Bir get isteğini karşılayan olay bayrakları* , *istek tarafından* **TX_OR_CLEAR** *veya* **TX_AND_CLEAR** belirtilmişse, yani sıfır olarak ayarlanır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-722">*Event flags that satisfy a get request are consumed, i.e., set to zero, if* **TX_OR_CLEAR** *or* **TX_AND_CLEAR** *are specified by the request.*</span></span>

<span data-ttu-id="f6dcf-723">Her olay bayrakları grubu, ortak bir kaynaktır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-723">Each event flags group is a public resource.</span></span> <span data-ttu-id="f6dcf-724">ThreadX, olay bayrakları gruplarının nasıl kullanıldığına ilişkin bir kısıtlama yoktur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-724">ThreadX places no constraints on how event flags groups are used.</span></span>

### <a name="creating-event-flags-groups"></a><span data-ttu-id="f6dcf-725">Olay bayrakları grupları oluşturma</span><span class="sxs-lookup"><span data-stu-id="f6dcf-725">Creating Event Flags Groups</span></span>

<span data-ttu-id="f6dcf-726">Olay bayrakları grupları, başlatma sırasında veya uygulama iş parçacıkları tarafından çalışma zamanı sırasında oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-726">Event flags groups are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="f6dcf-727">Oluşturma sırasında, gruptaki tüm olay bayrakları sıfır olarak ayarlanır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-727">At the time of their creation, all event flags in the group are set to zero.</span></span> <span data-ttu-id="f6dcf-728">Bir uygulamadaki olay bayrakları gruplarının sayısı için bir sınır yoktur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-728">There is no limit on the number of event flags groups in an application.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="f6dcf-729">İş parçacığı askıya alma</span><span class="sxs-lookup"><span data-stu-id="f6dcf-729">Thread Suspension</span></span>

<span data-ttu-id="f6dcf-730">Uygulama iş parçacıkları bir gruptan olay bayraklarının herhangi bir mantıksal birleşimini almaya çalışırken askıya alabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-730">Application threads can suspend while attempting to get any logical combination of event flags from a group.</span></span> <span data-ttu-id="f6dcf-731">Bir olay bayrağı ayarlandıktan sonra, askıya alınmış tüm iş parçacıklarının get istekleri gözden geçirilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-731">After an event flag is set, the get requests of all suspended threads are reviewed.</span></span> <span data-ttu-id="f6dcf-732">Artık gerekli olay bayraklarına sahip olan tüm iş parçacıkları sürdürülür.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-732">All the threads that now have the required event flags are resumed.</span></span>

> [!NOTE]
> <span data-ttu-id="f6dcf-733">*Olay bayrağı grubundaki askıya alınmış tüm iş parçacıkları, olay bayrakları ayarlandığında gözden geçirilir. Kuşkusuz bu, ek yük getirir. Bu nedenle, aynı olay bayrağı grubunu kullanan iş parçacığı sayısını makul bir sayıyla sınırlamak iyi bir uygulamadır.*</span><span class="sxs-lookup"><span data-stu-id="f6dcf-733">*All suspended threads on an event flag group are reviewed when its event flags are set. This, of course, introduces additional overhead. Therefore, it is good practice to limit the number of threads using the same event flag group to a reasonable number.*</span></span>

### <a name="event-flags-set-notification"></a><span data-ttu-id="f6dcf-734">Olay bayrakları ayarlama bildirimi</span><span class="sxs-lookup"><span data-stu-id="f6dcf-734">Event Flags Set Notification</span></span>

<span data-ttu-id="f6dcf-735">Bazı uygulamalar, bir olay bayrağı her ayarlandığında bildirim almak için yararlı bulabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-735">Some applications may find it advantageous to be notified whenever an event flag is set.</span></span> <span data-ttu-id="f6dcf-736">ThreadX, ***tx_event_flags_set_notify*** hizmeti aracılığıyla bu yeteneği sağlar.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-736">ThreadX provides this ability through the ***tx_event_flags_set_notify*** service.</span></span> <span data-ttu-id="f6dcf-737">Bu hizmet, belirtilen olay bayrakları grubuyla sağlanan uygulama bildirim işlevini kaydeder.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-737">This service registers the supplied application notification function with the specified event flags group.</span></span> <span data-ttu-id="f6dcf-738">Daha sonra ThreadX, gruptaki bir olay bayrağı ayarlandığında, bu uygulama bildirim işlevini çağırır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-738">ThreadX will subsequently invoke this application notification function whenever an event flag in the group is set.</span></span> <span data-ttu-id="f6dcf-739">Uygulama bildirim işlevi içindeki tam işlem uygulama tarafından belirlenir, ancak genellikle yeni olay bayrağını işlemek için uygun iş parçacığını sürdürmeden oluşur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-739">The exact processing within the application notification function is determined by the application, but it typically consists of resuming the appropriate thread for processing the new event flag.</span></span>

### <a name="event-flags-event-chainingtrade"></a><span data-ttu-id="f6dcf-740">Olay bayrakları olay zinciri&trade;</span><span class="sxs-lookup"><span data-stu-id="f6dcf-740">Event Flags Event chaining&trade;</span></span>

<span data-ttu-id="f6dcf-741">ThreadX içindeki bildirim özellikleri, çeşitli eşitleme olaylarını birlikte "zincirleme" için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-741">The notification capabilities in ThreadX can be used to "chain" various synchronization events together.</span></span> <span data-ttu-id="f6dcf-742">Bu, genellikle tek bir iş parçacığının birden çok eşitleme olayını işlemesi gerektiğinde faydalıdır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-742">This is typically useful when a single thread must process multiple synchronization events.</span></span>

<span data-ttu-id="f6dcf-743">Örneğin, bir kuyruk iletisi, olay bayrakları ve semafor için ayrı iş parçacıkları askıya almak yerine, uygulama her nesne için bir bildirim yordamı kaydedebilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-743">For example, instead of having separate threads suspend for a queue message, event flags, and a semaphore, the application can register a notification routine for each object.</span></span> <span data-ttu-id="f6dcf-744">Çağrıldığında, uygulama bildirimi yordamı tek bir iş parçacığını sürdürür, bu da her bir nesneye sorgulanamıyor, bu da yeni olayı bulup işleyebilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-744">When invoked, the application notification routine can then resume a single thread, which can interrogate each object to find and process the new event.</span></span>

<span data-ttu-id="f6dcf-745">Genel olarak, *olay zincirleme* daha az iş parçacığı, daha az ek yük ve daha küçük RAM gereksinimlerine neden olur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-745">In general, *event-chaining* results in fewer threads, less overhead, and smaller RAM requirements.</span></span> <span data-ttu-id="f6dcf-746">Ayrıca, daha karmaşık sistemlerin eşitleme gereksinimlerini işlemek için yüksek düzeyde esnek bir mekanizma sağlar.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-746">It also provides a highly flexible mechanism to handle synchronization requirements of more complex systems.</span></span>

### <a name="run-time-event-flags-performance-information"></a><span data-ttu-id="f6dcf-747">Çalışma zamanı olay bayrakları performans bilgileri</span><span class="sxs-lookup"><span data-stu-id="f6dcf-747">Run-time Event Flags Performance Information</span></span>

<span data-ttu-id="f6dcf-748">ThreadX isteğe bağlı çalışma zamanı olay bayrakları performans bilgilerini sağlar.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-748">ThreadX provides optional run-time event flags performance information.</span></span> <span data-ttu-id="f6dcf-749">ThreadX kitaplığı ve uygulaması tanımlanmış **TX_EVENT_FLAGS_ENABLE_PERFORMANCE_INFO** ile derlenip, threadx aşağıdaki bilgileri biriktirir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-749">If the ThreadX library and application is built with **TX_EVENT_FLAGS_ENABLE_PERFORMANCE_INFO** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="f6dcf-750">Genel sistem için toplam sayı:</span><span class="sxs-lookup"><span data-stu-id="f6dcf-750">Total number for the overall system:</span></span>

  - <span data-ttu-id="f6dcf-751">olay bayrakları kümeleri</span><span class="sxs-lookup"><span data-stu-id="f6dcf-751">event flags sets</span></span>

  - <span data-ttu-id="f6dcf-752">olay bayrakları alır</span><span class="sxs-lookup"><span data-stu-id="f6dcf-752">event flags gets</span></span>

  - <span data-ttu-id="f6dcf-753">olay bayrakları getirilmesi al</span><span class="sxs-lookup"><span data-stu-id="f6dcf-753">event flags get suspensions</span></span>

  - <span data-ttu-id="f6dcf-754">olay bayrakları zaman aşımlarını al</span><span class="sxs-lookup"><span data-stu-id="f6dcf-754">event flags get timeouts</span></span>

<span data-ttu-id="f6dcf-755">Her olay bayrakları grubu için toplam sayı:</span><span class="sxs-lookup"><span data-stu-id="f6dcf-755">Total number for each event flags group:</span></span>

  - <span data-ttu-id="f6dcf-756">olay bayrakları kümeleri</span><span class="sxs-lookup"><span data-stu-id="f6dcf-756">event flags sets</span></span>

  - <span data-ttu-id="f6dcf-757">olay bayrakları alır</span><span class="sxs-lookup"><span data-stu-id="f6dcf-757">event flags gets</span></span>

  - <span data-ttu-id="f6dcf-758">olay bayrakları getirilmesi al</span><span class="sxs-lookup"><span data-stu-id="f6dcf-758">event flags get suspensions</span></span>

  - <span data-ttu-id="f6dcf-759">olay bayrakları zaman aşımlarını al</span><span class="sxs-lookup"><span data-stu-id="f6dcf-759">event flags get timeouts</span></span>

<span data-ttu-id="f6dcf-760">Bu bilgiler, ***tx_event_flags_performance_info_get** _ ve _*_tx_event_flags_performance_system_info_get_\*_ Hizmetleri aracılığıyla çalışma zamanında kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-760">This information is available at run-time through the services ***tx_event_flags_performance_info_get** _ and _*_tx_event_flags_performance_system_info_get_\*_.</span></span> <span data-ttu-id="f6dcf-761">Olay bayraklarının performans bilgileri, uygulamanın düzgün çalışıp çalışmadığını belirlemek için faydalıdır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-761">The performance information of event flags is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="f6dcf-762">Ayrıca, uygulamayı iyileştirmek için de kullanışlıdır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-762">It is also useful in optimizing the application.</span></span> <span data-ttu-id="f6dcf-763">Örneğin, _ *_tx_event_flags_get_*\* hizmetindeki görece yüksek sayıda zaman aşımı, olay bayrakları askıya alma zaman aşımı değerinin çok kısa olduğunu önerebilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-763">For example, a relatively high number of timeouts on the _ *_tx_event_flags_get_*\* service might suggest that the event flags suspension timeout is too short.</span></span>

### <a name="event-flags-group-control-block-tx_event_flags_group"></a><span data-ttu-id="f6dcf-764">Olay bayrakları Grup denetim bloğu TX_EVENT_FLAGS_GROUP</span><span class="sxs-lookup"><span data-stu-id="f6dcf-764">Event Flags Group Control Block TX_EVENT_FLAGS_GROUP</span></span>

<span data-ttu-id="f6dcf-765">Her olay bayrakları grubunun özellikleri denetim bloğunda bulunur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-765">The characteristics of each event flags group are found in its control block.</span></span> <span data-ttu-id="f6dcf-766">Geçerli olay bayrakları ayarları ve olaylar için askıya alınan iş parçacığı sayısı gibi bilgileri içerir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-766">It contains information such as the current event flags settings and the number of threads suspended for events.</span></span> <span data-ttu-id="f6dcf-767">Bu yapı ***tx_api. h*** dosyasında tanımlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-767">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="f6dcf-768">Olay grubu denetim blokları bellekte herhangi bir yerde bulunabilir, ancak herhangi bir işlevin kapsamı dışında tanımlayarak denetimin genel bir yapıyı engellemesini sağlamak yaygın olarak kullanılır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-768">Event group control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="memory-block-pools"></a><span data-ttu-id="f6dcf-769">Bellek blok havuzları</span><span class="sxs-lookup"><span data-stu-id="f6dcf-769">Memory Block Pools</span></span>

<span data-ttu-id="f6dcf-770">Bellek hızlı ve belirleyici bir şekilde ayrılırken gerçek zamanlı uygulamalarda her zaman bir zorluk vardır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-770">Allocating memory in a fast and deterministic manner is always a challenge in real-time applications.</span></span> <span data-ttu-id="f6dcf-771">Bu aklınızda, ThreadX, birden çok sabit boyutlu bellek bloğu havuzu oluşturma ve yönetme olanağı sağlar.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-771">With this in mind, ThreadX provides the ability to create and manage multiple pools of fixed-size memory blocks.</span></span>

<span data-ttu-id="f6dcf-772">Bellek blok havuzları sabit boyutlu bloklardan oluştuğundan hiçbir parçalama sorunu yoktur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-772">Because memory block pools consist of fixed-size blocks, there are never any fragmentation problems.</span></span> <span data-ttu-id="f6dcf-773">Tabii ki parçalama, doğal olarak belirleyici olmayan davranışa neden olur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-773">Of course, fragmentation causes behavior that is inherently nondeterministic.</span></span> <span data-ttu-id="f6dcf-774">Ayrıca, sabit boyutlu bir bellek bloğunu ayırmak ve serbest bırakmak için gereken süre, basit bağlantılı liste işleme ile karşılaştırılabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-774">In addition, the time required to allocate and free a fixed-size memory block is comparable to that of simple linked-list manipulation.</span></span> <span data-ttu-id="f6dcf-775">Ayrıca, bellek bloğu ayırma ve ayırmayı kaldırma, kullanılabilir listenin başında yapılır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-775">Furthermore, memory block allocation and de-allocation is done at the head of the available list.</span></span> <span data-ttu-id="f6dcf-776">Bu, mümkün olan en hızlı bağlantılı liste işlemesini sağlar ve gerçek bellek bloğunu önbellekte tutmaya yardımcı olabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-776">This provides the fastest possible linked list processing and might help keep the actual memory block in cache.</span></span>

<span data-ttu-id="f6dcf-777">Esneklik olmaması, sabit boyutlu bellek havuzlarının başlıca dezavantajıdır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-777">Lack of flexibility is the main drawback of fixed-size memory pools.</span></span> <span data-ttu-id="f6dcf-778">Havuzun blok boyutu, kullanıcılarının en kötü durum bellek gereksinimlerini karşılayacak kadar büyük olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-778">The block size of a pool must be large enough to handle the worst case memory requirements of its users.</span></span> <span data-ttu-id="f6dcf-779">Tabii ki aynı havuza çok sayıda farklı bellek isteği yapılırsa bellek harcanmayabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-779">Of course, memory may be wasted if many different size memory requests are made to the same pool.</span></span> <span data-ttu-id="f6dcf-780">Olası bir çözüm, farklı boyutlardaki bellek blokları içeren birkaç farklı bellek bloğu havuzu oluşturmak olur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-780">A possible solution is to make several different memory block pools that contain different sized memory blocks.</span></span>

<span data-ttu-id="f6dcf-781">Her bellek blok havuzu bir ortak kaynaktır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-781">Each memory block pool is a public resource.</span></span> <span data-ttu-id="f6dcf-782">ThreadX, havuzların nasıl kullanıldığına ilişkin bir kısıtlama yoktur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-782">ThreadX places no constraints on how pools are used.</span></span>

### <a name="creating-memory-block-pools"></a><span data-ttu-id="f6dcf-783">Bellek blok havuzları oluşturma</span><span class="sxs-lookup"><span data-stu-id="f6dcf-783">Creating Memory Block Pools</span></span>

<span data-ttu-id="f6dcf-784">Bellek blok havuzları, başlatma sırasında veya uygulama iş parçacıkları tarafından çalışma zamanı sırasında oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-784">Memory block pools are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="f6dcf-785">Bir uygulamadaki bellek bloğu havuzlarının sayısı için bir sınır yoktur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-785">There is no limit on the number of memory block pools in an application.</span></span>

### <a name="memory-block-size"></a><span data-ttu-id="f6dcf-786">Bellek blok boyutu</span><span class="sxs-lookup"><span data-stu-id="f6dcf-786">Memory Block Size</span></span>

<span data-ttu-id="f6dcf-787">Daha önce belirtildiği gibi, bellek blok havuzları bir dizi sabit boyutlu blok içerir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-787">As mentioned earlier, memory block pools contain a number of fixed-size blocks.</span></span> <span data-ttu-id="f6dcf-788">Havuzun oluşturulması sırasında blok boyutu bayt cinsinden belirtilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-788">The block size, in bytes, is specified during creation of the pool.</span></span>

> [!NOTE]
> <span data-ttu-id="f6dcf-789">*ThreadX, havuzdaki her bir bellek bloğuna küçük bir ek yük (C işaretçisi boyutu) ekler. Ayrıca, ThreadX ' in her bir bellek bloğunun başlangıcını doğru hizalamadan korumak için blok boyutunu doldurma gerekebilir.*</span><span class="sxs-lookup"><span data-stu-id="f6dcf-789">*ThreadX adds a small amount of overhead—the size of a C pointer—to each memory block in the pool. In addition, ThreadX might have to pad the block size to keep the beginning of each memory block on proper alignment.*</span></span>

### <a name="pool-capacity"></a><span data-ttu-id="f6dcf-790">Havuz kapasitesi</span><span class="sxs-lookup"><span data-stu-id="f6dcf-790">Pool Capacity</span></span>

<span data-ttu-id="f6dcf-791">Bir havuzdaki bellek bloklarının sayısı, blok boyutunun bir işlevidir ve oluşturma sırasında sağlanan bellek alanındaki toplam bayt sayısıdır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-791">The number of memory blocks in a pool is a function of the block size and the total number of bytes in the memory area supplied during creation.</span></span> <span data-ttu-id="f6dcf-792">Havuzun kapasitesi, blok boyutu (doldurma ve işaretçi ek yükü baytları dahil), sağlanan bellek alanındaki toplam bayt sayısına bölünerek hesaplanır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-792">The capacity of a pool is calculated by dividing the block size (including padding and the pointer overhead bytes) into the total number of bytes in the supplied memory area.</span></span>

### <a name="pools-memory-area"></a><span data-ttu-id="f6dcf-793">Havuzun bellek alanı</span><span class="sxs-lookup"><span data-stu-id="f6dcf-793">Pool's Memory Area</span></span>

<span data-ttu-id="f6dcf-794">Daha önce belirtildiği gibi, blok havuzu için bellek alanı oluşturma sırasında belirtilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-794">As mentioned before, the memory area for the block pool is specified during creation.</span></span> <span data-ttu-id="f6dcf-795">ThreadX içindeki diğer bellek alanları gibi, hedefin adres alanında herhangi bir yerde bulunabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-795">Like other memory areas in ThreadX, it can be located anywhere in the target's address space.</span></span>

<span data-ttu-id="f6dcf-796">Bu, sağladığı önemli esneklik nedeniyle önemli bir özelliktir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-796">This is an important feature because of the considerable flexibility it provides.</span></span> <span data-ttu-id="f6dcf-797">Örneğin, bir iletişim ürününün g/ç için bir Highspeed bellek alanı olduğunu varsayalım.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-797">For example, suppose that a communication product has a highspeed memory area for I/O.</span></span> <span data-ttu-id="f6dcf-798">Bu bellek alanı, bir ThreadX bellek blok havuzunda yapılarak kolayca yönetilebilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-798">This memory area is easily managed by making it into a ThreadX memory block pool.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="f6dcf-799">İş parçacığı askıya alma</span><span class="sxs-lookup"><span data-stu-id="f6dcf-799">Thread Suspension</span></span>

<span data-ttu-id="f6dcf-800">Uygulama iş parçacıkları boş havuzdan bir bellek bloğunun beklediği sırada askıya alabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-800">Application threads can suspend while waiting for a memory block from an empty pool.</span></span> <span data-ttu-id="f6dcf-801">Havuza bir blok döndürüldüğünde, askıya alınan iş parçacığına bu blok verilir ve iş parçacığı sürdürülür.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-801">When a block is returned to the pool, the suspended thread is given this block and the thread is resumed.</span></span>

<span data-ttu-id="f6dcf-802">Aynı bellek bloğu havuzunda birden çok iş parçacığı askıya alınırsa, bunlar askıya alındığı sırada sürdürülür (FıFO).</span><span class="sxs-lookup"><span data-stu-id="f6dcf-802">If multiple threads are suspended on the same memory block pool, they are resumed in the order they were suspended (FIFO).</span></span>

<span data-ttu-id="f6dcf-803">Ancak, uygulama, iş parçacığı askıya alma işleminden önce blok yayın çağrısından önce ***tx_block_pool_prioritize*** çağırırsa öncelik sürdürme de mümkündür.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-803">However, priority resumption is also possible if the application calls ***tx_block_pool_prioritize*** prior to the block release call that lifts thread suspension.</span></span> <span data-ttu-id="f6dcf-804">Blok havuzu öncelik sıralaması hizmeti, en yüksek öncelikli iş parçacığını askıya alma listesinin önüne koyar, diğer tüm askıya alınan iş parçacıklarını aynı FıFO sırasıyla bırakır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-804">The block pool prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

### <a name="run-time-block-pool-performance-information"></a><span data-ttu-id="f6dcf-805">Çalışma zamanı blok havuzu performans bilgileri</span><span class="sxs-lookup"><span data-stu-id="f6dcf-805">Run-time Block Pool Performance Information</span></span>

<span data-ttu-id="f6dcf-806">ThreadX isteğe bağlı çalışma zamanı blok havuzu performans bilgilerini sağlar.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-806">ThreadX provides optional run-time block pool performance information.</span></span> <span data-ttu-id="f6dcf-807">ThreadX kitaplığı ve uygulaması tanımlanmış **TX_BLOCK_POOL_ENABLE_PERFORMANCE_INFO** ile derlenip, threadx aşağıdaki bilgileri biriktirir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-807">If the ThreadX library and application is built with **TX_BLOCK_POOL_ENABLE_PERFORMANCE_INFO** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="f6dcf-808">Genel sistem için toplam sayı:</span><span class="sxs-lookup"><span data-stu-id="f6dcf-808">Total number for the overall system:</span></span>

  - <span data-ttu-id="f6dcf-809">ayrılan bloklar</span><span class="sxs-lookup"><span data-stu-id="f6dcf-809">blocks allocated</span></span>

  - <span data-ttu-id="f6dcf-810">çıkarılan bloklar</span><span class="sxs-lookup"><span data-stu-id="f6dcf-810">blocks released</span></span>

  - <span data-ttu-id="f6dcf-811">ayırma getirilmesi</span><span class="sxs-lookup"><span data-stu-id="f6dcf-811">allocation suspensions</span></span>

  - <span data-ttu-id="f6dcf-812">ayırma zaman aşımları</span><span class="sxs-lookup"><span data-stu-id="f6dcf-812">allocation timeouts</span></span>

<span data-ttu-id="f6dcf-813">Her blok havuzu için toplam sayı:</span><span class="sxs-lookup"><span data-stu-id="f6dcf-813">Total number for each block pool:</span></span>

  - <span data-ttu-id="f6dcf-814">ayrılan bloklar</span><span class="sxs-lookup"><span data-stu-id="f6dcf-814">blocks allocated</span></span>

  - <span data-ttu-id="f6dcf-815">çıkarılan bloklar</span><span class="sxs-lookup"><span data-stu-id="f6dcf-815">blocks released</span></span>

  - <span data-ttu-id="f6dcf-816">ayırma getirilmesi</span><span class="sxs-lookup"><span data-stu-id="f6dcf-816">allocation suspensions</span></span>

  - <span data-ttu-id="f6dcf-817">ayırma zaman aşımları</span><span class="sxs-lookup"><span data-stu-id="f6dcf-817">allocation timeouts</span></span>

<span data-ttu-id="f6dcf-818">Bu bilgiler, \***tx_block_pool_performance_info_get** _ ve _ *_tx_block_pool_performance_system_info_get_* \* Hizmetleri aracılığıyla çalışma zamanında kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-818">This information is available at run-time through the services ***tx_block_pool_performance_info_get** _ and _*_tx_block_pool_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="f6dcf-819">Blok havuzu performans bilgileri, uygulamanın düzgün çalışıp çalışmadığını belirlemek için faydalıdır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-819">Block pool performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="f6dcf-820">Ayrıca, uygulamayı iyileştirmek için de kullanışlıdır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-820">It is also useful in optimizing the application.</span></span> <span data-ttu-id="f6dcf-821">Örneğin, görece yüksek sayıda "Allocation getirilmesi", blok havuzunun çok küçük olmasını önerebilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-821">For example, a relatively high number of "allocation suspensions" might suggest that the block pool is too small.</span></span>

### <a name="memory-block-pool-control-block-tx_block_pool"></a><span data-ttu-id="f6dcf-822">Bellek blok havuzu denetim bloğu TX_BLOCK_POOL</span><span class="sxs-lookup"><span data-stu-id="f6dcf-822">Memory Block Pool Control Block TX_BLOCK_POOL</span></span>

<span data-ttu-id="f6dcf-823">Her bir bellek bloğu havuzunun özellikleri denetim bloğunda bulunur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-823">The characteristics of each memory block pool are found in its control block.</span></span> <span data-ttu-id="f6dcf-824">Kullanılabilir bellek bloğu sayısı ve bellek havuzu blok boyutu gibi bilgileri içerir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-824">It contains information such as the number of memory blocks available and the memory pool block size.</span></span> <span data-ttu-id="f6dcf-825">Bu yapı ***tx_api. h*** dosyasında tanımlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-825">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="f6dcf-826">Havuz denetim blokları ayrıca bellekte herhangi bir yerde bulunabilir, ancak her bir işlevin kapsamı dışında tanımlayarak denetimin genel bir yapıyı engellemesini sağlamak en yaygın hale gelir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-826">Pool control blocks can also be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="overwriting-memory-blocks"></a><span data-ttu-id="f6dcf-827">Bellek bloklarının üzerine yazma</span><span class="sxs-lookup"><span data-stu-id="f6dcf-827">Overwriting Memory Blocks</span></span>

<span data-ttu-id="f6dcf-828">Ayrılmış bir bellek bloğunun kullanıcısının sınırlarının dışına yazmadığından emin olmak önemlidir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-828">It is important to ensure that the user of an allocated memory block does not write outside its boundaries.</span></span> <span data-ttu-id="f6dcf-829">Bu durumda, bir komşu (genellikle sonraki) bellek alanında bozulma oluşur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-829">If this happens, corruption occurs in an adjacent (usually subsequent) memory area.</span></span> <span data-ttu-id="f6dcf-830">Sonuçlar tahmin edilemez ve genellikle uygulama için önemli olur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-830">The results are unpredictable and often fatal to the application.</span></span>

## <a name="memory-byte-pools"></a><span data-ttu-id="f6dcf-831">Bellek bayt havuzları</span><span class="sxs-lookup"><span data-stu-id="f6dcf-831">Memory Byte Pools</span></span>

<span data-ttu-id="f6dcf-832">ThreadX bellek bayt havuzları standart C yığınına benzer.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-832">ThreadX memory byte pools are similar to a standard C heap.</span></span> <span data-ttu-id="f6dcf-833">Standart C yığınının aksine, birden çok bellek bayt havuzu olması mümkündür.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-833">Unlike the standard C heap, it is possible to have multiple memory byte pools.</span></span> <span data-ttu-id="f6dcf-834">Ayrıca, iş parçacıkları istenen bellek kullanılabilir olana kadar bir havuzda askıda olabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-834">In addition, threads can suspend on a pool until the requested memory is available.</span></span>

<span data-ttu-id="f6dcf-835">Bellek bayt havuzlarından ayırmalar, istenen bellek miktarını (bayt cinsinden) içeren geleneksel \***malloc** _ çağrılarına benzerdir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-835">Allocations from memory byte pools are similar to traditional \***malloc** _ calls, which include the amount of memory desired (in bytes).</span></span> <span data-ttu-id="f6dcf-836">Bellek, havuzdan bir _first uyacak şekilde ayrılır; Yani, isteği karşılayan ilk boş bellek bloğu kullanılır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-836">Memory is allocated from the pool in a _first-fit\* manner; i.e., the first free memory block that satisfies the request is used.</span></span> <span data-ttu-id="f6dcf-837">Bu bloktaki aşırı bellek yeni bir bloğa dönüştürülür ve boş bellek listesine geri yerleştirilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-837">Excess memory from this block is converted into a new block and placed back in the free memory list.</span></span> <span data-ttu-id="f6dcf-838">Bu işleme *parçalanma* adı verilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-838">This process is called *fragmentation*.</span></span>

<span data-ttu-id="f6dcf-839">Bitişik boş bellek blokları, daha sonraki bir ayırma araması sırasında, çok sayıda boş bellek bloğu için birlikte *birleştirilir* .</span><span class="sxs-lookup"><span data-stu-id="f6dcf-839">Adjacent free memory blocks are *merged* together during a subsequent allocation search for a large enough free memory block.</span></span> <span data-ttu-id="f6dcf-840">Bu işleme *birleştirme* adı verilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-840">This process is called *defragmentation*.</span></span>

<span data-ttu-id="f6dcf-841">Her bellek bayt havuzu ortak bir kaynaktır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-841">Each memory byte pool is a public resource.</span></span> <span data-ttu-id="f6dcf-842">ThreadX, havuzların nasıl kullanıldığına ilişkin hiçbir kısıtlama vermez, bu da bellek bayt Hizmetleri ISRs 'den çağrılamaz.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-842">ThreadX places no constraints on how pools are used, except that memory byte services cannot be called from ISRs.</span></span>

### <a name="creating-memory-byte-pools"></a><span data-ttu-id="f6dcf-843">Bellek bayt havuzları oluşturma</span><span class="sxs-lookup"><span data-stu-id="f6dcf-843">Creating Memory Byte Pools</span></span>

<span data-ttu-id="f6dcf-844">Bellek bayt havuzları, başlatma sırasında veya uygulama iş parçacıkları tarafından çalışma zamanı sırasında oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-844">Memory byte pools are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="f6dcf-845">Bir uygulamadaki bellek baytı havuzlarının sayısı için bir sınır yoktur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-845">There is no limit on the number of memory byte pools in an application.</span></span>

### <a name="pool-capacity"></a><span data-ttu-id="f6dcf-846">Havuz kapasitesi</span><span class="sxs-lookup"><span data-stu-id="f6dcf-846">Pool Capacity</span></span>

<span data-ttu-id="f6dcf-847">Bellek bayt havuzunda ayrılan ayrıtı bayt sayısı, oluşturma sırasında belirtilenden biraz daha düşüktür.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-847">The number of allocatable bytes in a memory byte pool is slightly less than what was specified during creation.</span></span> <span data-ttu-id="f6dcf-848">Bunun nedeni, boş bellek alanının yönetiminde bazı ek yük tanıtılmaktadır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-848">This is because management of the free memory area introduces some overhead.</span></span> <span data-ttu-id="f6dcf-849">Havuzdaki her bir boş bellek bloğu, iki C ek yük işaretçinin eşdeğerini gerektirir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-849">Each free memory block in the pool requires the equivalent of two C pointers of overhead.</span></span> <span data-ttu-id="f6dcf-850">Ayrıca havuz, büyük bir boş blok ve bellek alanının sonunda küçük bir kalıcı olarak ayrılmış blok ile oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-850">In addition, the pool is created with two blocks, a large free block and a small permanently allocated block at the end of the memory area.</span></span> <span data-ttu-id="f6dcf-851">Bu ayrılmış blok, ayırma algoritmasının performansını geliştirmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-851">This allocated block is used to improve performance of the allocation algorithm.</span></span> <span data-ttu-id="f6dcf-852">Birleştirme sırasında havuz alanının sonuna sürekli denetleme gereksinimini ortadan kaldırır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-852">It eliminates the need to continuously check for the end of the pool area during merging.</span></span>

<span data-ttu-id="f6dcf-853">Çalışma zamanı sırasında havuzdaki ek yük miktarı genellikle artar.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-853">During run-time, the amount of overhead in the pool typically increases.</span></span> <span data-ttu-id="f6dcf-854">Bir sonraki bellek bloğunun doğru hizalamasını sağlamak için tek sayılı baytların ayırmaları doldurulur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-854">Allocations of an odd number of bytes are padded to ensure proper alignment of the next memory block.</span></span> <span data-ttu-id="f6dcf-855">Ayrıca, havuz daha parçalanmış hale geldiği için ek yük artar.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-855">In addition, overhead increases as the pool becomes more fragmented.</span></span>

### <a name="pools-memory-area"></a><span data-ttu-id="f6dcf-856">Havuzun bellek alanı</span><span class="sxs-lookup"><span data-stu-id="f6dcf-856">Pool's Memory Area</span></span>

<span data-ttu-id="f6dcf-857">Bellek bayt havuzu için bellek alanı oluşturma sırasında belirtilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-857">The memory area for a memory byte pool is specified during creation.</span></span> <span data-ttu-id="f6dcf-858">ThreadX içindeki diğer bellek alanları gibi, hedefin adres alanında herhangi bir yerde bulunabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-858">Like other memory areas in ThreadX, it can be located anywhere in the target's address space.</span></span> <span data-ttu-id="f6dcf-859">Bu, sağladığı önemli esneklik nedeniyle önemli bir özelliktir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-859">This is an important feature because of the considerable flexibility it provides.</span></span> <span data-ttu-id="f6dcf-860">Örneğin, hedef donanımın yüksek hızlı bellek alanı ve düşük hızlı bellek alanı varsa, her birinde bir havuz oluşturarak Kullanıcı her iki alan için bellek ayırmayı yönetebilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-860">For example, if the target hardware has a high-speed memory area and a low-speed memory area, the user can manage memory allocation for both areas by creating a pool in each of them.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="f6dcf-861">İş parçacığı askıya alma</span><span class="sxs-lookup"><span data-stu-id="f6dcf-861">Thread Suspension</span></span>

<span data-ttu-id="f6dcf-862">Bir havuzdan bellek baytları beklenirken uygulama iş parçacıkları askıya alabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-862">Application threads can suspend while waiting for memory bytes from a pool.</span></span> <span data-ttu-id="f6dcf-863">Yeterli bitişik bellek kullanılabilir olduğunda, askıya alınan iş parçacıklarına istenen bellek verilir ve iş parçacıkları sürdürülür.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-863">When sufficient contiguous memory becomes available, the suspended threads are given their requested memory and the threads are resumed.</span></span>

<span data-ttu-id="f6dcf-864">Aynı bellek bayt havuzunda birden çok iş parçacığı askıya alınırsa, bunlar askıya alınan (FıFO) sırada bellek olarak verilir (devam ettirildi).</span><span class="sxs-lookup"><span data-stu-id="f6dcf-864">If multiple threads are suspended on the same memory byte pool, they are given memory (resumed) in the order they were suspended (FIFO).</span></span>

<span data-ttu-id="f6dcf-865">Ancak, uygulama, iş parçacığı askıya alma işlemi için bayt yayın çağrısından önce ***tx_byte_pool_prioritize*** çağırdığında öncelik sürdürme de mümkündür.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-865">However, priority resumption is also possible if the application calls ***tx_byte_pool_prioritize*** prior to the byte release call that lifts thread suspension.</span></span> <span data-ttu-id="f6dcf-866">Bayt havuzu öncelik sıralaması hizmeti, en yüksek öncelikli iş parçacığını askıya alma listesinin önüne koyar, diğer tüm askıya alınan iş parçacıklarını aynı FıFO sırasıyla bırakır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-866">The byte pool prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

### <a name="run-time-byte-pool-performance-information"></a><span data-ttu-id="f6dcf-867">Çalışma zamanı bayt havuzu performans bilgileri</span><span class="sxs-lookup"><span data-stu-id="f6dcf-867">Run-time Byte Pool Performance Information</span></span>

<span data-ttu-id="f6dcf-868">ThreadX isteğe bağlı çalışma zamanı bayt havuzu performans bilgilerini sağlar.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-868">ThreadX provides optional run-time byte pool performance information.</span></span> <span data-ttu-id="f6dcf-869">ThreadX kitaplığı ve uygulaması tanımlanmış ***TX_BYTE_POOL_ENABLE_PERFORMANCE_INFO*** ile derlenip, threadx aşağıdaki bilgileri biriktirir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-869">If the ThreadX library and application is built with ***TX_BYTE_POOL_ENABLE_PERFORMANCE_INFO*** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="f6dcf-870">Genel sistem için toplam sayı:</span><span class="sxs-lookup"><span data-stu-id="f6dcf-870">Total number for the overall system:</span></span>

  - <span data-ttu-id="f6dcf-871">ayırmalarını</span><span class="sxs-lookup"><span data-stu-id="f6dcf-871">allocations</span></span>

  - <span data-ttu-id="f6dcf-872">yayınlar</span><span class="sxs-lookup"><span data-stu-id="f6dcf-872">releases</span></span>

  - <span data-ttu-id="f6dcf-873">Aranan parçalar</span><span class="sxs-lookup"><span data-stu-id="f6dcf-873">fragments searched</span></span>

  - <span data-ttu-id="f6dcf-874">Birleştirilen parçalar</span><span class="sxs-lookup"><span data-stu-id="f6dcf-874">fragments merged</span></span>

  - <span data-ttu-id="f6dcf-875">oluşturulan parçalar</span><span class="sxs-lookup"><span data-stu-id="f6dcf-875">fragments created</span></span>

  - <span data-ttu-id="f6dcf-876">ayırma getirilmesi</span><span class="sxs-lookup"><span data-stu-id="f6dcf-876">allocation suspensions</span></span>

  - <span data-ttu-id="f6dcf-877">ayırma zaman aşımları</span><span class="sxs-lookup"><span data-stu-id="f6dcf-877">allocation timeouts</span></span>

<span data-ttu-id="f6dcf-878">Her bayt havuzunun toplam sayısı:</span><span class="sxs-lookup"><span data-stu-id="f6dcf-878">Total number for each byte pool:</span></span>

  - <span data-ttu-id="f6dcf-879">ayırmalarını</span><span class="sxs-lookup"><span data-stu-id="f6dcf-879">allocations</span></span>

  - <span data-ttu-id="f6dcf-880">yayınlar</span><span class="sxs-lookup"><span data-stu-id="f6dcf-880">releases</span></span>

  - <span data-ttu-id="f6dcf-881">Aranan parçalar</span><span class="sxs-lookup"><span data-stu-id="f6dcf-881">fragments searched</span></span>

  - <span data-ttu-id="f6dcf-882">Birleştirilen parçalar</span><span class="sxs-lookup"><span data-stu-id="f6dcf-882">fragments merged</span></span>

  - <span data-ttu-id="f6dcf-883">oluşturulan parçalar</span><span class="sxs-lookup"><span data-stu-id="f6dcf-883">fragments created</span></span>

  - <span data-ttu-id="f6dcf-884">ayırma getirilmesi</span><span class="sxs-lookup"><span data-stu-id="f6dcf-884">allocation suspensions</span></span>

  - <span data-ttu-id="f6dcf-885">ayırma zaman aşımları</span><span class="sxs-lookup"><span data-stu-id="f6dcf-885">allocation timeouts</span></span>

<span data-ttu-id="f6dcf-886">Bu bilgiler, \***tx_byte_pool_performance_info_get** _ ve _ *_tx_byte_pool_performance_system_info_get_* \* Hizmetleri aracılığıyla çalışma zamanında kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-886">This information is available at run-time through the services ***tx_byte_pool_performance_info_get** _ and _*_tx_byte_pool_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="f6dcf-887">Bayt havuzu performans bilgileri, uygulamanın düzgün çalışıp çalışmadığını belirlemek için faydalıdır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-887">Byte pool performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="f6dcf-888">Ayrıca, uygulamayı iyileştirmek için de kullanışlıdır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-888">It is also useful in optimizing the application.</span></span> <span data-ttu-id="f6dcf-889">Örneğin, görece yüksek sayıda "Allocation getirilmesi", bayt havuzunun çok küçük olduğunu önerebilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-889">For example, a relatively high number of "allocation suspensions" might suggest that the byte pool is too small.</span></span>

### <a name="memory-byte-pool-control-block-tx_byte_pool"></a><span data-ttu-id="f6dcf-890">Bellek bayt havuzu denetim bloğu TX_BYTE_POOL</span><span class="sxs-lookup"><span data-stu-id="f6dcf-890">Memory Byte Pool Control Block TX_BYTE_POOL</span></span>

<span data-ttu-id="f6dcf-891">Her bir bellek bayt havuzunun özellikleri denetim bloğunda bulunur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-891">The characteristics of each memory byte pool are found in its control block.</span></span> <span data-ttu-id="f6dcf-892">Havuzdaki kullanılabilir bayt sayısı gibi yararlı bilgiler içerir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-892">It contains useful information such as the number of available bytes in the pool.</span></span> <span data-ttu-id="f6dcf-893">Bu yapı ***tx_api. h*** dosyasında tanımlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-893">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="f6dcf-894">Havuz denetim blokları ayrıca bellekte herhangi bir yerde bulunabilir, ancak her bir işlevin kapsamı dışında tanımlayarak denetimin genel bir yapıyı engellemesini sağlamak en yaygın hale gelir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-894">Pool control blocks can also be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="nondeterministic-behavior"></a><span data-ttu-id="f6dcf-895">Belirleyici olmayan davranış</span><span class="sxs-lookup"><span data-stu-id="f6dcf-895">Nondeterministic Behavior</span></span>

<span data-ttu-id="f6dcf-896">Bellek bayt havuzları en esnek bellek ayırmayı sağlasa da, önemli olmayan davranışlardan de zarar verir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-896">Although memory byte pools provide the most flexible memory allocation, they also suffer from somewhat nondeterministic behavior.</span></span> <span data-ttu-id="f6dcf-897">Örneğin, bir bellek bayt havuzunda 2.000 baytlık bellek bulunabilir, ancak 1.000 baytlık bir ayırma isteğini karşılayamayabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-897">For example, a memory byte pool may have 2,000 bytes of memory available but may not be able to satisfy an allocation request of 1,000 bytes.</span></span> <span data-ttu-id="f6dcf-898">Bunun nedeni, boş baytların kaç tane bitişik olduğunu garanti etmez.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-898">This is because there are no guarantees on how many of the free bytes are contiguous.</span></span> <span data-ttu-id="f6dcf-899">1.000 baytlık boş bir blok mevcut olsa bile, bloğu bulmak için ne kadar süreceğine ilişkin garanti yoktur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-899">Even if a 1,000 byte free block exists, there are no guarantees on how long it might take to find the block.</span></span> <span data-ttu-id="f6dcf-900">Tüm bellek havuzunun, 1.000 bayt bloğunu bulmak için aranması gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-900">It is completely possible that the entire memory pool would need to be searched to find the 1,000 byte block.</span></span>

> [!TIP]
> <span data-ttu-id="f6dcf-901">*Bellek bayt havuzlarının belirleyici olmayan davranışının bir sonucu olarak, belirleyici ve gerçek zamanlı davranışın gerekli olduğu alanlarda bellek bayt hizmetlerini kullanmaktan kaçınmak genellikle iyi bir uygulamadır. Birçok uygulama başlatma veya çalışma zamanı yapılandırması sırasında gereken belleği önceden ayırır.*</span><span class="sxs-lookup"><span data-stu-id="f6dcf-901">*As a result of the nondeterministic behavior of memory byte pools, it is generally good practice to avoid using memory byte services in areas where deterministic, real-time behavior is required. Many applications pre-allocate their required memory during initialization or run-time configuration.*</span></span>

### <a name="overwriting-memory-blocks"></a><span data-ttu-id="f6dcf-902">Bellek bloklarının üzerine yazma</span><span class="sxs-lookup"><span data-stu-id="f6dcf-902">Overwriting Memory Blocks</span></span>

<span data-ttu-id="f6dcf-903">Ayrılan bellek kullanıcısının sınırlarının dışına yazmadığından emin olmak önemlidir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-903">It is important to ensure that the user of allocated memory does not write outside its boundaries.</span></span> <span data-ttu-id="f6dcf-904">Bu durumda, bir komşu (genellikle sonraki) bellek alanında bozulma oluşur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-904">If this happens, corruption occurs in an adjacent (usually subsequent) memory area.</span></span> <span data-ttu-id="f6dcf-905">Sonuçlar tahmin edilemez ve genellikle program yürütmesi için çok zararlı olur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-905">The results are unpredictable and often catastrophic for program execution.</span></span>

## <a name="application-timers"></a><span data-ttu-id="f6dcf-906">Uygulama zamanlayıcıları</span><span class="sxs-lookup"><span data-stu-id="f6dcf-906">Application Timers</span></span>

<span data-ttu-id="f6dcf-907">Zaman uyumsuz dış olaylara hızlı yanıt gerçek zamanlı, katıştırılmış uygulamaların en önemli işlevidir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-907">Fast response to asynchronous external events is the most important function of real-time, embedded applications.</span></span> <span data-ttu-id="f6dcf-908">Ancak, bu uygulamaların birçoğu önceden belirlenen zaman aralıklarında belirli etkinlikler gerçekleştirmelidir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-908">However, many of these applications must also perform certain activities at predetermined intervals of time.</span></span>

<span data-ttu-id="f6dcf-909">ThreadX uygulama zamanlayıcıları, uygulamalar için belirli zaman aralıklarında uygulama C işlevlerini yürütme yeteneği sağlar.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-909">ThreadX application timers provide applications with the ability to execute application C functions at specific intervals of time.</span></span> <span data-ttu-id="f6dcf-910">Ayrıca, bir uygulama süreölçerinin yalnızca bir kez kullanım süreleri de mümkündür.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-910">It is also possible for an application timer to expire only once.</span></span> <span data-ttu-id="f6dcf-911">Bu tür bir zamanlayıcıya tek bir *Zamanlayıcı* denir, ancak yineleme aralığı zamanlayıcıları *düzenli* zamanlayıcı olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-911">This type of timer is called a *one-shot timer*, while repeating interval timers are called *periodic timers*.</span></span>

<span data-ttu-id="f6dcf-912">Her uygulama süreölçeri ortak bir kaynaktır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-912">Each application timer is a public resource.</span></span> <span data-ttu-id="f6dcf-913">ThreadX, uygulama süreölçerlerine ilişkin bir kısıtlama yoktur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-913">ThreadX places no constraints on how application timers are used.</span></span>

### <a name="timer-intervals"></a><span data-ttu-id="f6dcf-914">Süreölçer aralıkları</span><span class="sxs-lookup"><span data-stu-id="f6dcf-914">Timer Intervals</span></span>

<span data-ttu-id="f6dcf-915">ThreadX zaman aralıklarında düzenli Zamanlayıcı kesintileri ile ölçülür.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-915">In ThreadX time intervals are measured by periodic timer interrupts.</span></span> <span data-ttu-id="f6dcf-916">Her süreölçer kesmeye Zamanlayıcı *onay* işareti denir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-916">Each timer interrupt is called a timer *tick*.</span></span> <span data-ttu-id="f6dcf-917">Zamanlayıcı işaretleri arasındaki gerçek süre uygulama tarafından belirtilir, ancak 10 MS çoğu uygulamanın norm olur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-917">The actual time between timer ticks is specified by the application, but 10ms is the norm for most implementations.</span></span> <span data-ttu-id="f6dcf-918">Düzenli süreölçer kurulumu genellikle ***tx_initialize_low_level*** derleme dosyasında bulunur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-918">The periodic timer setup is typically found in the ***tx_initialize_low_level*** assembly file.</span></span>

<span data-ttu-id="f6dcf-919">Temel alınan donanımın, uygulama zamanlayıcılarının çalışması için düzenli kesmeler oluşturma yeteneğinin olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-919">It is worth mentioning that the underlying hardware must have the ability to generate periodic interrupts for application timers to function.</span></span> <span data-ttu-id="f6dcf-920">Bazı durumlarda, işlemcinin yerleşik bir düzenli kesme özelliği vardır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-920">In some cases, the processor has a built-in periodic interrupt capability.</span></span> <span data-ttu-id="f6dcf-921">İşlemcinin bu özelliği yoksa, kullanıcının panosunun düzenli kesmeler oluşturabilen bir çevresel cihaz olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-921">If the processor doesn't have this ability, the user's board must have a peripheral device that can generate periodic interrupts.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f6dcf-922">*ThreadX, düzenli bir kesme kaynağı olmadan bile çalışmaya devam edebilir. Ancak, süreölçer ile ilgili tüm işlemler devre dışı bırakılır. Bu, zaman aşımlama, askıya alınma süresi ve Zamanlayıcı hizmetleri içerir.*</span><span class="sxs-lookup"><span data-stu-id="f6dcf-922">*ThreadX can still function even without a periodic interrupt source. However, all timer-related processing is then disabled. This includes timeslicing, suspension time-outs, and timer services.*</span></span>

### <a name="timer-accuracy"></a><span data-ttu-id="f6dcf-923">Süreölçer doğruluğu</span><span class="sxs-lookup"><span data-stu-id="f6dcf-923">Timer Accuracy</span></span>

<span data-ttu-id="f6dcf-924">Süreölçer süre sonları, onay işaretleri bakımından belirtilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-924">Timer expirations are specified in terms of ticks.</span></span> <span data-ttu-id="f6dcf-925">Belirtilen süre sonu değeri her bir Zamanlayıcı Tick 'i için azaltılır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-925">The specified expiration value is decreased by one on each timer tick.</span></span> <span data-ttu-id="f6dcf-926">Bir uygulama süreölçeri bir Zamanlayıcı kesmesinden (veya zamanlayıcı Tick 'ten) önce etkinleştirilemediğinden, gerçek süre sonu süresi erken bir kısa süre önce olabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-926">Because an application timer could be enabled just prior to a timer interrupt (or timer tick), the actual expiration time could be up to one tick early.</span></span>

<span data-ttu-id="f6dcf-927">Süreölçer değer oranı 10ms ise, uygulama zamanlayıcıları yaklaşık 10 MS 'ye kadar zaman alabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-927">If the timer tick rate is 10ms, application timers may expire up to 10ms early.</span></span> <span data-ttu-id="f6dcf-928">Bu, 1 saniyelik zamanlayıcıdan daha fazla 10 MS Zamanlayıcı için daha önemlidir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-928">This is more significant for 10ms timers than 1 second timers.</span></span> <span data-ttu-id="f6dcf-929">Tabii ki Zamanlayıcı kesme sıklığını artırmak hatanın bu kenar boşluğunu düşürür.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-929">Of course, increasing the timer interrupt frequency decreases this margin of error.</span></span>

### <a name="timer-execution"></a><span data-ttu-id="f6dcf-930">Süreölçer yürütme</span><span class="sxs-lookup"><span data-stu-id="f6dcf-930">Timer Execution</span></span>

<span data-ttu-id="f6dcf-931">Uygulama zamanlayıcıları etkin hale geldiği sırada yürütülür.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-931">Application timers execute in the order they become active.</span></span> <span data-ttu-id="f6dcf-932">Örneğin, aynı süre sonu değeri ile üç Zamanlayıcı oluşturulursa ve etkinleştirilirse, karşılık gelen süre sonu işlevlerinin etkinleştirildikleri sırada yürütülmesi garanti edilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-932">For example, if three timers are created with the same expiration value and activated, their corresponding expiration functions are guaranteed to execute in the order they were activated.</span></span>

### <a name="creating-application-timers"></a><span data-ttu-id="f6dcf-933">Uygulama zamanlayıcıları oluşturma</span><span class="sxs-lookup"><span data-stu-id="f6dcf-933">Creating Application Timers</span></span>

<span data-ttu-id="f6dcf-934">Uygulama zamanlayıcıları, başlatma sırasında veya uygulama iş parçacıkları tarafından çalışma zamanı sırasında oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-934">Application timers are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="f6dcf-935">Bir uygulamadaki uygulama süreölçerinin sayısı için bir sınır yoktur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-935">There is no limit on the number of application timers in an application.</span></span>

### <a name="run-time-application-timer-performance-information"></a><span data-ttu-id="f6dcf-936">Çalışma zamanı uygulama süreölçeri performans bilgileri</span><span class="sxs-lookup"><span data-stu-id="f6dcf-936">Run-time Application Timer Performance Information</span></span>

<span data-ttu-id="f6dcf-937">ThreadX isteğe bağlı çalışma zamanı uygulama süreölçeri performans bilgilerini sağlar.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-937">ThreadX provides optional run-time application timer performance information.</span></span> <span data-ttu-id="f6dcf-938">ThreadX kitaplığı ve uygulaması tanımlanmış **TX_TIMER_ENABLE_PERFORMANCE_INFO** ile derlenip, threadx aşağıdaki bilgileri biriktirir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-938">If the ThreadX library and application are built with **TX_TIMER_ENABLE_PERFORMANCE_INFO** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="f6dcf-939">Genel sistem için toplam sayı:</span><span class="sxs-lookup"><span data-stu-id="f6dcf-939">Total number for the overall system:</span></span>

- <span data-ttu-id="f6dcf-940">etkinleştir</span><span class="sxs-lookup"><span data-stu-id="f6dcf-940">activations</span></span>

- <span data-ttu-id="f6dcf-941">etkinleştirme kaldırma</span><span class="sxs-lookup"><span data-stu-id="f6dcf-941">deactivations</span></span>

- <span data-ttu-id="f6dcf-942">yeniden etkinleştirme (dönemsel zamanlayıcılar)</span><span class="sxs-lookup"><span data-stu-id="f6dcf-942">reactivations (periodic timers)</span></span>

- <span data-ttu-id="f6dcf-943">süreleri</span><span class="sxs-lookup"><span data-stu-id="f6dcf-943">expirations</span></span>

- <span data-ttu-id="f6dcf-944">süre sonu ayarlamaları</span><span class="sxs-lookup"><span data-stu-id="f6dcf-944">expiration adjustments</span></span>

<span data-ttu-id="f6dcf-945">Her uygulama süreölçerinin toplam sayısı:</span><span class="sxs-lookup"><span data-stu-id="f6dcf-945">Total number for each application timer:</span></span>

- <span data-ttu-id="f6dcf-946">etkinleştir</span><span class="sxs-lookup"><span data-stu-id="f6dcf-946">activations</span></span>

- <span data-ttu-id="f6dcf-947">etkinleştirme kaldırma</span><span class="sxs-lookup"><span data-stu-id="f6dcf-947">deactivations</span></span>

- <span data-ttu-id="f6dcf-948">yeniden etkinleştirme (dönemsel zamanlayıcılar)</span><span class="sxs-lookup"><span data-stu-id="f6dcf-948">reactivations (periodic timers)</span></span>

- <span data-ttu-id="f6dcf-949">süreleri</span><span class="sxs-lookup"><span data-stu-id="f6dcf-949">expirations</span></span>

- <span data-ttu-id="f6dcf-950">süre sonu ayarlamaları</span><span class="sxs-lookup"><span data-stu-id="f6dcf-950">expiration adjustments</span></span>

<span data-ttu-id="f6dcf-951">Bu bilgiler, \***tx_timer_performance_info_get** _ ve _ *_tx_timer_performance_system_info_get_* \* Hizmetleri aracılığıyla çalışma zamanında kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-951">This information is available at run-time through the services ***tx_timer_performance_info_get** _ and _*_tx_timer_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="f6dcf-952">Uygulama süreölçer performans bilgileri, uygulamanın düzgün çalışıp çalışmadığını belirlemek için faydalıdır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-952">Application Timer performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="f6dcf-953">Ayrıca, uygulamayı iyileştirmek için de kullanışlıdır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-953">It is also useful in optimizing the application.</span></span>

### <a name="application-timer-control-block-tx_timer"></a><span data-ttu-id="f6dcf-954">Uygulama Zamanlayıcı denetim bloğu TX_TIMER</span><span class="sxs-lookup"><span data-stu-id="f6dcf-954">Application Timer Control Block TX_TIMER</span></span>

<span data-ttu-id="f6dcf-955">Her bir uygulama süreölçerinin özellikleri denetim bloğunda bulunur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-955">The characteristics of each application timer are found in its control block.</span></span> <span data-ttu-id="f6dcf-956">32 bitlik süre sonu tanımlama değeri gibi yararlı bilgiler içerir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-956">It contains useful information such as the 32-bit expiration identification value.</span></span> <span data-ttu-id="f6dcf-957">Bu yapı ***tx_api. h*** dosyasında tanımlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-957">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="f6dcf-958">Uygulama Zamanlayıcı denetim blokları bellekte herhangi bir yerde bulunabilir, ancak herhangi bir işlevin kapsamı dışında tanımlayarak denetimin genel bir yapıyı engellemesini sağlamak yaygın olarak kullanılır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-958">Application timer control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="excessive-timers"></a><span data-ttu-id="f6dcf-959">Aşırı Zamanlayıcı</span><span class="sxs-lookup"><span data-stu-id="f6dcf-959">Excessive Timers</span></span>

<span data-ttu-id="f6dcf-960">Varsayılan olarak, uygulama zamanlayıcıları, genellikle herhangi bir uygulama iş parçacığından daha yüksek olan bir gizli sistem iş parçacığı içinden yürütülür.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-960">By default, application timers execute from within a hidden system thread that runs at priority zero, which is typically higher than any application thread.</span></span> <span data-ttu-id="f6dcf-961">Bu nedenle, uygulama zamanlayıcıları içinde işleme en az bir olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-961">Because of this, processing inside application timers should be kept to a minimum.</span></span>

<span data-ttu-id="f6dcf-962">Mümkün olduğunda, her zaman Zamanlayıcı Tick 'i dolan zamanlayıcılar olmaması da önemlidir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-962">It is also important to avoid, whenever possible, timers that expire every timer tick.</span></span> <span data-ttu-id="f6dcf-963">Böyle bir durum, uygulamada aşırı yüke neden olur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-963">Such a situation might induce excessive overhead in the application.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f6dcf-964">*Daha önce belirtildiği gibi, uygulama zamanlayıcıları gizli bir sistem iş parçacığından yürütülür. Bu nedenle, uygulama süreölçerinin süre sonu işlevinin içinden yapılan tüm ThreadX hizmeti çağrılarında askıya alma ' yı seçmemelidir.*</span><span class="sxs-lookup"><span data-stu-id="f6dcf-964">*As mentioned previously, application timers are executed from a hidden system thread. It is, therefore, important not to select suspension on any ThreadX service calls made from within the application timer's expiration function.*</span></span>

## <a name="relative-time"></a><span data-ttu-id="f6dcf-965">Göreli saat</span><span class="sxs-lookup"><span data-stu-id="f6dcf-965">Relative Time</span></span>

<span data-ttu-id="f6dcf-966">ThreadX, daha önce bahsedilen uygulama zamanlayıcılar ' ne ek olarak tek bir sürekli artan 32 bit onay sayacı sağlar.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-966">In addition to the application timers mentioned previously, ThreadX provides a single continuously incrementing 32-bit tick counter.</span></span> <span data-ttu-id="f6dcf-967">Onay sayacı veya saati her bir Zamanlayıcı *kesilmesinde* bir artırılır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-967">The tick counter or *time* is increased by one on each timer interrupt.</span></span>

<span data-ttu-id="f6dcf-968">Uygulama, sırasıyla \***tx_time_get** _ ve _ *_tx_time_set_* \* çağrıları aracılığıyla bu 32 bitlik sayacı okuyabilir veya ayarlayabilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-968">The application can read or set this 32-bit counter through calls to ***tx_time_get** _ and _*_tx_time_set_\*\*, respectively.</span></span> <span data-ttu-id="f6dcf-969">Bu onay sayacının kullanımı, uygulama tarafından tamamen belirlenir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-969">The use of this tick counter is determined completely by the application.</span></span> <span data-ttu-id="f6dcf-970">Bu, Işparçacığıx tarafından dahili olarak kullanılmaz.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-970">It is not used internally by ThreadX.</span></span>

## <a name="interrupts"></a><span data-ttu-id="f6dcf-971">Kesmelerini</span><span class="sxs-lookup"><span data-stu-id="f6dcf-971">Interrupts</span></span>

<span data-ttu-id="f6dcf-972">Zaman uyumsuz olaylara hızlı yanıt gerçek zamanlı, katıştırılmış uygulamaların asıl işlevidir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-972">Fast response to asynchronous events is the principal function of real-time, embedded applications.</span></span> <span data-ttu-id="f6dcf-973">Uygulama, donanım kesintileri aracılığıyla böyle bir olayın mevcut olduğunu bilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-973">The application knows such an event is present through hardware interrupts.</span></span>

<span data-ttu-id="f6dcf-974">Kesme, işlemci yürütmede zaman uyumsuz bir değişiklik olur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-974">An interrupt is an asynchronous change in processor execution.</span></span> <span data-ttu-id="f6dcf-975">Genellikle, bir kesme gerçekleştiğinde, *kesmeler* işlemcisi yığında geçerli yürütmenin küçük bir bölümünü kaydeder ve denetimi uygun kesme vektörüne aktarır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-975">Typically, when an interrupt occurs, the *Interrupts* processor saves a small portion of the current execution on the stack and transfers control to the appropriate interrupt vector.</span></span> <span data-ttu-id="f6dcf-976">Kesme vektörü temel olarak yalnızca belirli tür kesmeyi işlemekten sorumlu olan yordamın adresidir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-976">The interrupt vector is basically just the address of the routine responsible for handling the specific type interrupt.</span></span> <span data-ttu-id="f6dcf-977">Kesin kesme işleme yordamı, işlemciye özeldir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-977">The exact interrupt handling procedure is processor specific.</span></span>

### <a name="interrupt-control"></a><span data-ttu-id="f6dcf-978">Kesme denetimi</span><span class="sxs-lookup"><span data-stu-id="f6dcf-978">Interrupt Control</span></span>

<span data-ttu-id="f6dcf-979">***Tx_interrupt_control*** hizmeti, uygulamaların kesmeleri etkinleştirmesine ve devre dışı bırakmasına izin verir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-979">The ***tx_interrupt_control*** service allows applications to enable and disable interrupts.</span></span> <span data-ttu-id="f6dcf-980">Önceki kesme etkinleştirme/devre dışı bırakma, bu hizmet tarafından döndürülür.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-980">The previous interrupt enable/disable posture is returned by this service.</span></span> <span data-ttu-id="f6dcf-981">Kesme denetiminin yalnızca yürütülmekte olan program segmentini etkileyeceğini bahsetmek önemlidir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-981">It is important to mention that interrupt control only affects the currently executing program segment.</span></span> <span data-ttu-id="f6dcf-982">Örneğin, bir iş parçacığı kesintileri devre dışı bırakırsa, bu iş parçacığının yürütülmesi sırasında yalnızca devre dışı kalır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-982">For example, if a thread disables interrupts, they only remain disabled during execution of that thread.</span></span>

> [!NOTE]
> <span data-ttu-id="f6dcf-983">*Maskelenemeyen kesme (NMI), donanım tarafından devre dışı bırakılamaz. Bu tür bir kesme, ThreadX uygulamaları tarafından kullanılabilir. Ancak, uygulamanın NMI işleme yordamının ThreadX bağlam yönetimini veya herhangi bir API hizmetini kullanmasına izin verilmez.*</span><span class="sxs-lookup"><span data-stu-id="f6dcf-983">*A Non-Maskable Interrupt (NMI) is an interrupt that cannot be disabled by the hardware. Such an interrupt may be used by ThreadX applications. However, the application's NMI handling routine is not allowed to use ThreadX context management or any API services.*</span></span>

### <a name="threadx-managed-interrupts"></a><span data-ttu-id="f6dcf-984">ThreadX yönetilen kesmeler</span><span class="sxs-lookup"><span data-stu-id="f6dcf-984">ThreadX Managed Interrupts</span></span>

<span data-ttu-id="f6dcf-985">ThreadX, tüm kesme yönetimine sahip uygulamalar sağlar.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-985">ThreadX provides applications with complete interrupt management.</span></span> <span data-ttu-id="f6dcf-986">Bu yönetim, kesilen yürütmenin bağlamını kaydetmeyi ve geri yüklemeyi içerir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-986">This management includes saving and restoring the context of the interrupted execution.</span></span> <span data-ttu-id="f6dcf-987">Ayrıca, ThreadX, belirli hizmetlerin kesme hizmeti yordamları (ISRS) içinden çağrılmasına izin verir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-987">In addition, ThreadX allows certain services to be called from within Interrupt Service Routines (ISRs).</span></span> <span data-ttu-id="f6dcf-988">Aşağıda, uygulama ISRs 'den izin verilen ThreadX hizmetlerinin bir listesi verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-988">The following is a list of ThreadX services allowed from application ISRs.</span></span>

```c
tx_block_allocate
tx_block_pool_info_get tx_block_pool_prioritize
tx_block_pool_performance_info_get
tx_block_pool_performance_system_info_get tx_block_release
tx_byte_pool_info_get tx_byte_pool_performance_info_get
tx_byte_pool_performance_system_info_get
tx_byte_pool_prioritize tx_event_flags_info_get
tx_event_flags_get tx_event_flags_set
tx_event_flags_performance_info_get
tx_event_flags_performance_system_info_get
tx_event_flags_set_notify tx_interrupt_control
tx_mutex_performance_info_get
tx_mutex_performance_system_info_get tx_queue_front_send
tx_queue_info_get tx_queue_performance_info_get
tx_queue_performance_system_info_get tx_queue_prioritize
tx_queue_receive tx_queue_send tx_semaphore_get
tx_queue_send_notify tx_semaphore_ceiling_put
tx_semaphore_info_get tx_semaphore_performance_info_get
tx_semaphore_performance_system_info_get
tx_semaphore_prioritize tx_semaphore_put tx_thread_identify
tx_semaphore_put_notify tx_thread_entry_exit_notify
tx_thread_info_get tx_thread_resume
tx_thread_performance_info_get
tx_thread_performance_system_info_get
tx_thread_stack_error_notify tx_thread_wait_abort tx_time_get
tx_time_set tx_timer_activate tx_timer_change
tx_timer_deactivate tx_timer_info_get
tx_timer_performance_info_get
tx_timer_performance_system_info_get
```

> [!IMPORTANT]
> <span data-ttu-id="f6dcf-989">*ISRs 'den askıya alma yapılmasına izin verilmez. Bu nedenle, bir ıSR 'den yapılan tüm ThreadX hizmeti çağrılarının **wait_option** parametresi **TX_NO_WAIT** olarak ayarlanmalıdır.*</span><span class="sxs-lookup"><span data-stu-id="f6dcf-989">*Suspension is not allowed from ISRs. Therefore, the **wait_option** parameter for all ThreadX service calls made from an ISR must be set to **TX_NO_WAIT**.*</span></span>

### <a name="isr-template"></a><span data-ttu-id="f6dcf-990">ISR şablonu</span><span class="sxs-lookup"><span data-stu-id="f6dcf-990">ISR Template</span></span>

<span data-ttu-id="f6dcf-991">Uygulama kesmelerini yönetmek için uygulama ISRs 'nin başında ve sonunda birkaç ThreadX yardımcı programı çağrılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-991">To manage application interrupts, several ThreadX utilities must be called in the beginning and end of application ISRs.</span></span> <span data-ttu-id="f6dcf-992">Kesme işleme için tam biçim, bağlantı noktaları arasında farklılık gösterir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-992">The exact format for interrupt handling varies between ports.</span></span>

<span data-ttu-id="f6dcf-993">Aşağıdaki küçük kod segmenti, en çok ThreadX yönetilen ISRs 'nin tipik bir parçasıdır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-993">The following small code segment is typical of most ThreadX managed ISRs.</span></span> <span data-ttu-id="f6dcf-994">Çoğu durumda, bu işlem derleme dilidir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-994">In most cases, this processing is in assembly language.</span></span>

```c
_application_ISR_vector_entry:

; Save context and prepare for

; ThreadX use by calling the ISR

; entry function.

CALL _tx_thread_context_save

; The ISR can now call ThreadX

; services and its own C functions

; When the ISR is finished, context

; is restored (or thread preemption)

; by calling the context restore ; function. Control does not return!

JUMP _tx_thread_context_restore
```

### <a name="high-frequency-interrupts"></a><span data-ttu-id="f6dcf-995">Yüksek frekanslı kesmeler</span><span class="sxs-lookup"><span data-stu-id="f6dcf-995">High-frequency Interrupts</span></span>

<span data-ttu-id="f6dcf-996">Bazı kesmeler, her kesme sırasında tam bağlam kaydetme ve geri yükleme işlemlerinin çok fazla işlem bant genişliği tükettiği bir sıklıkta oluşur.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-996">Some interrupts occur at such a high frequency that saving and restoring full context upon each interrupt would consume excessive processing bandwidth.</span></span> <span data-ttu-id="f6dcf-997">Bu gibi durumlarda, uygulamanın bu yüksek frekanslı kesmelerin çoğu için sınırlı miktarda işleme yapan küçük bir derleme dili ıSR olması yaygındır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-997">In such cases, it is common for the application to have a small assembly language ISR that does a limited amount of processing for a majority of these high-frequency interrupts.</span></span>

<span data-ttu-id="f6dcf-998">Belirli bir noktadan sonra, küçük ıSR 'nin ThreadX ile etkileşimde olması gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-998">After a certain point in time, the small ISR may need to interact with ThreadX.</span></span> <span data-ttu-id="f6dcf-999">Bu, yukarıdaki şablonda açıklanan giriş ve çıkış işlevleri çağırarak gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-999">This is accomplished by calling the entry and exit functions described in the above template.</span></span>

### <a name="interrupt-latency"></a><span data-ttu-id="f6dcf-1000">Kesme gecikmesi</span><span class="sxs-lookup"><span data-stu-id="f6dcf-1000">Interrupt Latency</span></span>

<span data-ttu-id="f6dcf-1001">ThreadX, kısa bir süre içinde kesmeleri kilitler.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-1001">ThreadX locks out interrupts over brief periods of time.</span></span> <span data-ttu-id="f6dcf-1002">En fazla süre kesmesi devre dışı, bir iş parçacığının bağlamını kaydetmek veya geri yüklemek için gereken sürenin sıraındadır.</span><span class="sxs-lookup"><span data-stu-id="f6dcf-1002">The maximum amount of time interrupts are disabled is on the order of the time required to save or restore a thread's context.</span></span>
