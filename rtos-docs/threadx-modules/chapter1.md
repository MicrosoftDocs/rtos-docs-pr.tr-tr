---
title: Bölüm 1-genel bakış
author: philmea
description: Bu makale, Azure RTOS ThreadX modüllerine genel bakış
ms.author: philmea
ms.date: 07/15/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 0c9698086468d7bb41c33ebe9fa9d1ebb61b5f1f
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/22/2021
ms.locfileid: "104825498"
---
# <a name="chapter-1-overview"></a><span data-ttu-id="b3a6a-103">Bölüm 1: genel bakış</span><span class="sxs-lookup"><span data-stu-id="b3a6a-103">Chapter 1: Overview</span></span>

<span data-ttu-id="b3a6a-104">ThreadX modülü bileşeni, uygulamaların, uygulamanın yerleşik bölümünden ayrı olarak oluşturulan modülleri dinamik olarak yüklemesi için bir altyapı sağlar.</span><span class="sxs-lookup"><span data-stu-id="b3a6a-104">The ThreadX Module component provides an infrastructure for applications to dynamically load modules that are built separately from the resident portion of the application.</span></span> <span data-ttu-id="b3a6a-105">Bu, özellikle uygulama kodu boyutunun kullanılabilir belleği aşması durumunda faydalıdır.</span><span class="sxs-lookup"><span data-stu-id="b3a6a-105">This is especially useful in situations where the application code size exceeds available memory.</span></span> <span data-ttu-id="b3a6a-106">Ayrıca, çekirdek görüntü dağıtıldıktan sonra yeni özelliklerin eklenmesi gerektiği zaman da yardımcı olabilir.</span><span class="sxs-lookup"><span data-stu-id="b3a6a-106">It can also help when new features are required to be added after the core image is deployed.</span></span> <span data-ttu-id="b3a6a-107">Bunlara ek olarak, kısmi bellenim güncelleştirmeleri gerektiğinde dinamik yükleme modülleri de kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="b3a6a-107">In addition, dynamically loading modules can be used when partial firmware updates are required.</span></span>

<span data-ttu-id="b3a6a-108">Yüklü modül için bellek koruması, modül girişi içinde belirtilen özelliklere göre isteğe bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="b3a6a-108">Memory protection for the loaded module is optional, based on the properties specified in the module preamble.</span></span> <span data-ttu-id="b3a6a-109">Bellek koruması belirtildiğinde, işlemcinin bellek yönetimi donanımı, modülün tüm iş parçacıklarının yalnızca modülün koduna ve veri belleğine erişimine izin verilen şekilde yapılandırılır.</span><span class="sxs-lookup"><span data-stu-id="b3a6a-109">When memory protection is specified, the processor's memory management hardware is configured such that all threads of the module are only allowed access to the module's code and data memory.</span></span> <span data-ttu-id="b3a6a-110">Herhangi bir gereksiz bellek erişimi veya yürütme, bellek hatasına neden olur ve sorunlu modül iş parçacığı sonlandırılır.</span><span class="sxs-lookup"><span data-stu-id="b3a6a-110">Any extraneous memory access or execution will result in a memory fault and the offending module thread will be terminated.</span></span> <span data-ttu-id="b3a6a-111">Uygulama bir bellek hatası bildirimi geri çağırması kaydederse, bu da bellek hatasının uygulamasını uyarmak için de çağırılır.</span><span class="sxs-lookup"><span data-stu-id="b3a6a-111">If the application registers a memory fault notification callback, this will also be called to alert the application of the memory fault.</span></span>

<span data-ttu-id="b3a6a-112">ThreadX modülü bileşeni, modüllerin yüklenebildiği bir bellek alanı sağlamak için uygulamayı kullanır.</span><span class="sxs-lookup"><span data-stu-id="b3a6a-112">The ThreadX Module component relies on the application to provide a memory area where modules can be loaded.</span></span> <span data-ttu-id="b3a6a-113">Her modülün yönerge alanı yerinde çalıştırılabilir veya yürütme için RAM modülü bellek alanına kopyalanabilir.</span><span class="sxs-lookup"><span data-stu-id="b3a6a-113">The instruction area of each module may execute in place or be copied into the RAM module memory area for execution.</span></span> <span data-ttu-id="b3a6a-114">Her durumda, modül veri belleği gereksinimleri modül bellek alanından ayrılır.</span><span class="sxs-lookup"><span data-stu-id="b3a6a-114">In all cases, the module data memory requirements are allocated from the module memory area.</span></span>

<span data-ttu-id="b3a6a-115">Yerleşik modül yöneticisi kodunun yalnızca bir kopyası varken, aynı anda yüklenebilen modül sayısıyla ilgili hiçbir sınır yoktur (kullanılabilir bellek miktarı üzerinden).</span><span class="sxs-lookup"><span data-stu-id="b3a6a-115">There are no limits on the number of modules that can be loaded at the same time (aside from the amount of memory available), while there is only one copy of the resident Module Manager code.</span></span> <span data-ttu-id="b3a6a-116">Şekil 1 ' de Modül Yöneticisi ve modüllerle ilişkili ilişki gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="b3a6a-116">Figure 1 illustrates the relationship of the Module Manager and the modules themselves.</span></span>

![Modüller ve Modül Yöneticisi Ilişkisi](media/image2.png)

<span data-ttu-id="b3a6a-118">**Şekil 1** Modüller ve Modül Yöneticisi</span><span class="sxs-lookup"><span data-stu-id="b3a6a-118">**Figure 1** Modules and Module Manager</span></span>

<span data-ttu-id="b3a6a-119">Her modülün, uygulamanın tanımlanması sorumluluğu olan kendi bellek alanı olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="b3a6a-119">Each module must have its own memory area, which is the application's responsibility to define.</span></span> <span data-ttu-id="b3a6a-120">Modül ve Modül Yöneticisi, modül tarafından istenen ThreadX hizmetlerine karşılık gelen önceden tanımlanmış istek kimlikleri aracılığıyla bir yazılım gönderme işlevi aracılığıyla etkileşim kurar.</span><span class="sxs-lookup"><span data-stu-id="b3a6a-120">The Module and the Module Manager interact through a software dispatch function via pre-defined request IDs that correspond to ThreadX services requested by the module.</span></span> <span data-ttu-id="b3a6a-121">Ayrıca modül, tek bir iş parçacığı giriş noktası ve gerekli yığın boyutu, öncelik, modül KIMLIĞI, geri çağırma iş parçacığı yığın boyutu/öncelik vb. sağlamak için gereklidir. Bu bilgiler, her modülün girişi içinde tanımlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="b3a6a-121">In addition, the module is required to provide a single thread entry point as well as the required stack size, priority, module ID, callback thread stack size/priority, etc. This information is defined in each module's preamble.</span></span>

<span data-ttu-id="b3a6a-122">Modül Yöneticisi, ilk modül iş parçacığını oluşturmaktan ve yürütmesini başlatmaktan sorumludur.</span><span class="sxs-lookup"><span data-stu-id="b3a6a-122">The Module Manager is responsible for creating the initial module thread and initiating its execution.</span></span> <span data-ttu-id="b3a6a-123">Modülün ilk iş parçacığı yürütüldükten sonra Modül Yöneticisi, modül tarafından yapılan tüm ThreadX API isteklerinin zincirinden sorumlu olur.</span><span class="sxs-lookup"><span data-stu-id="b3a6a-123">Once the module's initial thread is executing, the Module Manager is responsible for fielding all ThreadX API requests made by the module.</span></span> <span data-ttu-id="b3a6a-124">Modül içinde ek iş parçacıkları oluşturma özelliği de dahil olmak üzere, bir modülün ThreadX API 'sine tam erişimi vardır.</span><span class="sxs-lookup"><span data-stu-id="b3a6a-124">A module has full access to the ThreadX API, including the ability to create additional threads within the module.</span></span>  
  
<span data-ttu-id="b3a6a-125">Modül kaynak kodu adlandırma kuralları basittir: tüm Modül Yöneticisi kaynak dosyaları ***txm_module_manager_ \**** olarak adlandırılır ve modülün tamamen ilişkili tüm dosyaları adın "**_Manager_*_" kısmını atlayın. Ana içerme dosyası _*_txm_module. h_** , yönetici ve modül kaynak kodu tarafından paylaşılır.</span><span class="sxs-lookup"><span data-stu-id="b3a6a-125">The module source code naming conventions are straightforward: all Module Manager source files are named ***txm_module_manager_\**** and all files associated exclusively with the module omit the "**_manager_*_" portion of the name. The main include file _*_txm_module.h_** is shared by the manager and module source code.</span></span>
